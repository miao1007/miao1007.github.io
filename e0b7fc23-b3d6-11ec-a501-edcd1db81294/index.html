<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="目前有很多厂家/APP都在做Blur，比如魅族高端机(mx4以后的机器)提供了实时模糊选项，并给第三方相应的sdk。有的第三方app（比如最美壁纸，雅虎天气，开眼等）看似使用了实时模糊，实际上只是两张截图的alpha变换而已，网上大多数开源项目亦是如此；还有的第三方库，比如14年非常火的GlassActionbar，的确可以实现动态模糊，可是fps不太满意，而且内部使用了AsyncTask作为异步处理，考虑到线程池中创建，销毁，上下文切换的损失，也不太敢用。"><meta name="keyword" content="Android,Blur"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Android的实时Blur渲染-－-BlurDrawable</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://eu.umami.is/script.js" data-website-id="449a84b6-be9e-49de-a4cc-e0fa6fea1df9"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">Android的实时Blur渲染-－-BlurDrawable</div><div class="date no-print">2016-09-23 / modified at 2022-04-04 / 1.2k words / 4 mins</div><div class="content"><blockquote><span>️This article has been <strong>over 3 years</strong> since the last update.</span></blockquote><p>目前有很多厂家/APP都在做Blur，比如魅族高端机(mx4以后的机器)提供了实时模糊选项，并给第三方相应的sdk。有的第三方app（比如最美壁纸，雅虎天气，开眼等）看似使用了实时模糊，实际上只是两张截图的alpha变换而已，网上大多数开源项目亦是如此；还有的第三方库，比如14年非常火的<a target="_blank" rel="noopener" href="https://github.com/ManuelPeinado/GlassActionBar">GlassActionbar</a>，的确可以实现动态模糊，可是fps不太满意，而且内部使用了<code>AsyncTask</code>作为异步处理，考虑到线程池中创建，销毁，上下文切换的损失，也不太敢用。</p><span id="more"></span><p><img src="http://upload-images.jianshu.io/upload_images/98641-9fb76804acb62063.gif?imageMogr2/auto-orient/strip" alt="BlurDrawable"></p><p>最后，面向Github编程的我，经过各种坑，终于抄到了一个项目<br><a target="_blank" rel="noopener" href="https://github.com/500px/500px-android-blur">500px-android-blur</a>，这个项目貌似是一位<s>肉翻的</s>国人写的，代码质量很高，英文写的也很正统。经过阅读参考代码后，我把自定义view中的相关处理port到了Drawable中，这个就是今天的主题<a target="_blank" rel="noopener" href="https://github.com/miao1007/AnimeWallpaper/blob/34eb1e39787913122ef17f65a6f890d1f601843a/app/src/main/java/com/github/miao1007/animewallpaper/ui/widget/BlurDrawable.java">BlurDrawable</a>，本文就此分享一下使用与源码。</p><h2>使用</h2><p>首先要有两个view，一个盖在另一个上面，比如说最常见的<code>NavigationBar</code>与<code>RecyclerView</code>，它们放在一个FrameLayout中，然后进行如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BlurDrawable drawable = new BlurDrawable(mRvFragCard);</span><br><span class="line">//模糊半径，越大图片越平均</span><br><span class="line">drawable.setBlurRadius(12);</span><br><span class="line">//图片抽样率，这里把图片缩放小了8倍</span><br><span class="line">drawable.setDownsampleFactor(8);</span><br><span class="line">//模糊后再覆盖的一层颜色</span><br><span class="line">drawable.setOverlayColor(Color.argb(128, 0xff, 0xff, 0xff));</span><br><span class="line">//顶部View与底部View的相对坐标差，由于这里都是(0,0)起步</span><br><span class="line">//所以相对位置偏移为0</span><br><span class="line">drawable.setDrawOffset(0,0);</span><br><span class="line">mNavigationBar.setBackgroundDrawable(drawable);</span><br></pre></td></tr></table></figure><p>如果你的需求只是静态模糊，那么所有东西就已经写完了，如果需要在滚动时进行实时计算，按照下面写的在滚动时通知重绘即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mRvFragCard.addOnScrollListener(<span class="keyword">new</span> <span class="title class_">RecyclerView</span>.OnScrollListener() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onScrolled</span><span class="params">(RecyclerView recyclerView, <span class="type">int</span> dx, <span class="type">int</span> dy)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onScrolled(recyclerView, dx, dy);</span><br><span class="line">    <span class="comment">//可能需要这个，当然这里由于位置比较巧，就没有用</span></span><br><span class="line">    <span class="comment">//drawable.setDrawOffset(0,0);</span></span><br><span class="line">    <span class="comment">//通知重绘</span></span><br><span class="line">    ViewCompat.postInvalidateOnAnimation(mNavigationBar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里还有个小技巧，如果按照默认布局的话，启动时RecyclerView的第一个item会嵌入在NavigationBar中无法点击，所以需要预留一些padding空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v7.widget.RecyclerView</span><br><span class="line">  ......</span><br><span class="line">  android:paddingTop=<span class="string">&quot;48dp&quot;</span></span><br><span class="line">  android:clipToPadding=<span class="string">&quot;false&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>这样使用效果就如上面gif一样了，gif压缩了部分细节，建议下载完整示例程序查看</p><p>最后，当不需要时，释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onDestroy();</span><br><span class="line">  <span class="keyword">if</span> (drawable != <span class="literal">null</span>) &#123;</span><br><span class="line">    drawable.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>兼容性与效率</h2><p>基于自带的<code>RenderScript</code>进行渲染，厂商与谷歌都进行了专业的优化，所以兼容性与效率当然是棒棒哒，然而在国内…</p><h6>1. 兼容性正常的机器：</h6><ul><li>API17及以上: 将自动开启Blur，经过<a target="_blank" rel="noopener" href="http://developer.android.com/intl/zh-cn/tools/performance/profile-gpu-rendering/index.html">玄学曲线</a>进行测试，构造耗时4ms，滚动时fps在8ms左右（在高通615/1080P/2G下进行测试的，615的尿性大家都知道，也就是说目前千元机均毫无压力）；</li><li>API17以下: 它将自动根据<code>OverlayColor</code>当做ColorDrawable进行纯色绘制（iOS关闭blur后也是这样的效果）。如果非要强迫用blur的话，可以使用<code>RenderScript</code>的兼容包，但不推荐。</li></ul><h6>2. 兼容性不正常的机器：</h6><p>根据群里大神的建议，某些国产设备由于ROM偷工减料，可能会出现RenderScript崩溃或者性能不达标的坑。不过跑了下<a target="_blank" rel="noopener" href="http://realauto.testin.cn/s/1ad86i12h">Testin云测</a>，随机100个主流设备并没有出现因为RenderScript崩溃的案例，但是出现了一个山寨机<strong>花屏</strong>的问题。另外根据<a target="_blank" rel="noopener" href="http://www.umindex.com/devices/android_models">友盟指数</a>可以看到，TOP50的设备中，除了酷派的老设备，其它都是比较放心的不会偷工减料的厂商。</p><p>综上，我个人还是建议集成，第一，它只是个单文件，定制强，体积小的不像实力派；第二，可以通过<code>drawable.setEnabled(false)</code>手动控制默认开关；</p><blockquote><p>开发者如果想在兼容性与美观性保持平衡的话，建议在设置中默认关闭，并引导用户开启；或者将API17手动提高到19或者20，以获得更好的兼容性。</p></blockquote><h2>原理分析</h2><p>实时渲染非常类似于DSP，底层是c语言实现的高斯模糊。首先根据<code>DownsampleFactor</code>进行绘制与抽样，获取到被覆盖view的rawBitmap，这样bitmap的信息量减小了几个数量级（比如<code>1920x1080</code>缩小到<code>136x244</code>），接着通过Renderscript进行卷积运算编码后输出，最后将处理好的bitmap用canvas拉伸绘制到表层的view中。注释已经很详细了，这里就不说了。</p><h2>工具下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/miao1007/AnimeWallpaper/blob/master/app%2Fsrc%2Fmain%2Fjava%2Fcom%2Fgithub%2Fmiao1007%2Fanimewallpaper%2Fui%2Fwidget%2FBlurDrawable.java">BlurDrawable</a></p><h2>例子下载</h2><ol><li><a target="_blank" rel="noopener" href="https://github.com/miao1007/AnimeWallpaper">本文的例子</a></li><li><a target="_blank" rel="noopener" href="https://gist.github.com/miao1007/f6a486a746e6087ed8f8">评论中要的使用Toolbar的简单例子</a></li></ol></div><div class="tags"><a class="tag-link" href="/tags/Android/" rel="tag">Android</a><a class="tag-link" href="/tags/Blur/" rel="tag">Blur</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry.</a><span> All contents are not allowed to be redistributed or synthesised without an explicit permission.</span></div></footer></div></body></html>