<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="本文先从Fibonacci递归计算开始，介绍了通过DP消除栈的算法，以及CPS的基本概念与Jenkins底层实现。"><meta name="keyword" content="CPS,DP,FP,Groovy,Jenkins"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>动态规划与JenkinsCPS技术</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://eu.umami.is/script.js" data-website-id="449a84b6-be9e-49de-a4cc-e0fa6fea1df9"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">动态规划与JenkinsCPS技术</div><div class="date no-print">2020-02-15 / modified at 2023-07-30 / 2.7k words / 10 mins</div><div class="content"><blockquote><span>️This article has been <strong>over 2 years</strong> since the last update.</span></blockquote><p>本文先从Fibonacci递归计算开始，介绍了通过DP消除栈的算法，以及CPS的基本概念与Jenkins底层实现。</p><span id="more"></span><p>本文读者要求：掌握CPS/DP/Groovy的基本使用，编译理论的基本方法，部分需了解Jenkins。</p><p>本文目的：介绍DP、CPS的理论，以及CPS在Jenkins的实践。</p><h2>What is DP?</h2><p>DP(dynamic programming，动态规划)是缓存计算结果的方法，通过给参数注入全局缓存/消除栈等方法，降低重复计算成本。</p><p>以求fibonacci为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  in:0 1 2 3 4 5 6</span></span><br><span class="line"><span class="comment">// out:0 1 1 2 3 5 8</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(i - <span class="number">2</span>) + fibonacci(i - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子如果你经过调试，就会发现有很多重复计算（因为它是tree recursion），也很容易产生栈溢出，我们尝试使用DP解决</p><p>方法一：我们可以加一个全局缓存<code>int[] dp</code>，这种方法与使用Redis当缓存没有区别，也很像“科学管理”中的计算尺</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：top down DP，没有消除栈，空间复杂度为O(N)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] dp)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    dp[i] = i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i] = fibonacci(i - <span class="number">2</span>, dp) + fibonacci(i - <span class="number">1</span>, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二，通过for循环求离散点的积分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二：down-top，这种方法通过jump消除了栈，仍然消耗了O(N)的空间复杂度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">  dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    dp[j] = dp[j-<span class="number">1</span>] + dp[j-<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三，是更优写法，这种通过少数几个寄存器就实现了缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法三：递归栈消除+低空间复杂度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    c = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的场景中，方法一是保底，而for循环方法需要有积分的数学背景。</p><h2>迭代与递归的选择/转换</h2><p>无论是OJ题目，还是真实项目，它们都是现实的问题，现实的问题就有方法论去实施，去分解，所以不要惧怕这些问题。</p><ul><li>递归的顶层方法论其实是形而上，通过分解为最小任务，并用多个参数实验获取结果。它可以实现最小的状态转移语意，代码量最少，但是可能出现分解思路困难/堆栈异常/忽视关闭条件。</li><li>for循环等迭代底层都是JUMP命令，它没有栈，但是很多逻辑、全局变量混在一起，后面难以维护</li><li>以上问题均默认不开启编译器尾递归等优</li></ul><p>在真实问题中，我个人先使用递归设计出原型，再通过CPS/DP技术去实现Desugar，优化掉递归调用。</p><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="MINDMAP" height="303px" preserveAspectRatio="none" style="width:843px;height:303px;background:#fff" version="1.1" viewBox="0 0 843 303" width="843px" zoomAndPan="magnify" class="kroki">$2<defs/><g><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="75.9998" x="10" y="132.5938"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="55.9998" x="20" y="155.5889">&#22797;&#26434;&#38382;&#39064;</text><rect fill="#F1F1F1" height="52.5938" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="254.8622" x="135.9998" y="124.4453"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="167.9993" x="145.9998" y="147.4404">&#25286;&#35299;&#20026;&#29366;&#24577;&#36716;&#31227;&#30340;&#36882;&#24402;&#38382;&#39064;</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="234.8622" x="145.9998" y="163.7373">(&#27604;&#22914;factorial(n)=factorial(n-1)*2)</text><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="191.3767" x="440.8619" y="20"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="171.3767" x="450.8619" y="42.9951">edge cases(&#27604;&#22914;null&#22330;&#26223;)</text><path d="M390.8619,150.7422 L400.8619,150.7422 C415.8619,150.7422 415.8619,38.1484 430.8619,38.1484 L440.8619,38.1484" fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="159.4255" x="440.8619" y="160.7422"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="139.4255" x="450.8619" y="183.7373">Desular(&#26632;/&#21442;&#25968;&#20248;&#21270;)</text><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="181.3687" x="650.2874" y="76.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="161.3687" x="660.2874" y="99.292">Curry(&#22810;&#21442;&#25968;&#36716;&#20026;&#21333;&#21442;&#25968;)</text><path d="M600.2874,178.8906 L610.2874,178.8906 C625.2874,178.8906 625.2874,94.4453 640.2874,94.4453 L650.2874,94.4453" fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="173.2205" x="650.2874" y="132.5938"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="153.2205" x="660.2874" y="155.5889">Top-down DP/&#31354;&#38388;&#20248;&#21270;</text><path d="M600.2874,178.8906 L610.2874,178.8906 C625.2874,178.8906 625.2874,150.7422 640.2874,150.7422 L650.2874,150.7422" fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="47.1045" x="650.2874" y="188.8906"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="27.1045" x="660.2874" y="211.8857">CPS</text><path d="M600.2874,178.8906 L610.2874,178.8906 C625.2874,178.8906 625.2874,207.0391 640.2874,207.0391 L650.2874,207.0391" fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="58.0283" x="650.2874" y="245.1875"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="38.0283" x="660.2874" y="268.1826">inline</text><path d="M600.2874,178.8906 L610.2874,178.8906 C625.2874,178.8906 625.2874,263.3359 640.2874,263.3359 L650.2874,263.3359" fill="none" style="stroke:#454645;stroke-width:1"/><path d="M390.8619,150.7422 L400.8619,150.7422 C415.8619,150.7422 415.8619,178.8906 430.8619,178.8906 L440.8619,178.8906" fill="none" style="stroke:#454645;stroke-width:1"/><path d="M85.9998,150.7422 L95.9998,150.7422 C110.9998,150.7422 110.9998,150.7422 125.9998,150.7422 L135.9998,150.7422" fill="none" style="stroke:#454645;stroke-width:1"/></g></svg><p>拆解方法也是有方法论的，它可以通过<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Design_of_experiments">DOE(Design of experiments)</a>找出输入与输出的关系，比如</p><ul><li>通过强制固定一些参数降低动态复杂度，DP一定是确定性的/无状态的，非NP问题</li><li>输出并不一定确切的值。比如计算EditDistance，只用求最终总和即可，而没要求具体的排列组合，这两个难度完全不一致。</li></ul><p>除此之外，还有一些技巧性强的常数复杂度方案甚至经验公式/数学方法，但是这种方法是需要学习与记忆的</p><h2>What is CPS?</h2><p>将阻塞的请求改为异步的Callback形式（或者返回一个Promise/Next的结构体），仅此而已。注意网上有很多文章说通过CPS可以消除栈，但是只说对了一半，在没有编译器优化的情况下，并不能将栈优化为JMP调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consumer也可以用Groovy的Closure实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fibonacciCps</span><span class="params">(<span class="type">int</span> i, Consumer&lt;Integer&gt; call)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    call.accept(i);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fibonacciCps(i - <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer a)</span> &#123;</span><br><span class="line">        fibonacciCps(i - <span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer b)</span> &#123;</span><br><span class="line">            call.accept(a + b);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fibonacciCps(<span class="number">6</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer sum)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;sum = &quot;</span> + integer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>平时编码这种写法可读性很差，很难显示区分同步还是异步执行，所以基本上没有利用的机会，一般会“人肉AST优化”到DP的第三种。</p><p>不过这样的好处是</p><ul><li>作为AST的中间态，方便编译器进行栈消除</li><li>实现在JVM上自己的“栈”与“VM”，以及持久化</li><li>实现数据“状态”的持久化（Checkpoint/Restore），比如Jenkins/CRIU</li></ul><h2>Jenkinsfile的CPS实现</h2><p>此部分介绍用户输入的Jenkinsfile脚本在Jenkins底层执行的流程</p><h4>字符串编译为BlockAST</h4><p>原始的脚本虽然写的像字符串，执行底层也是Groovy，但是它<strong>不是Groovy语言</strong></p><ul><li>所有Groovy语言的Token关键词(比如if/常数/变量)将不再是一个简单的JVM字节码，而有各个对应的Block，通过MetaMethodSite实现了&quot;编译&quot;为CPS的Block</li><li>静态工具类调用（比如forEach）/Closure表达式，通过CpsTransformer在编译时/运行时生成CPS转换，除非加入<code>@NoCPS</code>注解。有人可能看过王垠的40行代码，但是王垠的显然更高级。</li><li>定制的Step，通过<code>FunctionCallBlock</code>封装调用，它内部再使用CpsScript引擎去Eval</li></ul><p>在执行侧，Jenkins通过Groovy的Script实现了自己封装了一个Runtime，具体可以看<a href="/tags/Groovy/">Groovy</a>相关文章，避免自己从零写AST，最终输入的Groovy字符串将转为如下结构体</p><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="MINDMAP" height="162px" preserveAspectRatio="none" style="width:1081px;height:162px;background:#fff" version="1.1" viewBox="0 0 1081 162" width="1081px" zoomAndPan="magnify" class="kroki">$2<defs/><g><rect fill="#F1F1F1" height="52.5938" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="202.3961" x="10" y="54.0742"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="118.1455" x="20" y="77.0693">CpsThreadGroup</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="182.3961" x="20" y="93.3662">(&#23558;&#34987;&#25345;&#20037;&#21270;&#20026;program.dat)</text><rect fill="#F1F1F1" height="52.5938" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="119.6748" x="262.3961" y="54.0742"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="99.6748" x="272.3961" y="77.0693">Continuable &amp;</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="89.7354" x="272.3961" y="93.3662">Continuation</text><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="46.0039" x="432.0709" y="20"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="26.0039" x="442.0709" y="42.9951">Env</text><path d="M382.0709,80.3711 L392.0709,80.3711 C407.0709,80.3711 407.0709,38.1484 422.0709,38.1484 L432.0709,38.1484" fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="82.3369" x="432.0709" y="76.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="62.3369" x="442.0709" y="99.292">BlockList</text><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="85.8641" x="564.4078" y="48.1484"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="65.8641" x="574.4078" y="71.1436">&#22522;&#30784;Block</text><path d="M514.4078,94.4453 L524.4078,94.4453 C539.4078,94.4453 539.4078,66.2969 554.4078,66.2969 L564.4078,66.2969" fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="144.3115" x="564.4078" y="104.4453"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="124.3115" x="574.4078" y="127.4404">FunctionCallBlock</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="107.5768" x="761.7194" y="118.292">&#25191;&#34892;steps&#31561;&#21151;&#33021;</text><path d="M708.7194,122.5938 L718.7194,122.5938 C733.7194,122.5938 733.7194,113.4453 748.7194,113.4453 L758.7194,113.4453" fill="none" style="stroke:#454645;stroke-width:1"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="307.5212" x="761.7194" y="136.5889">&#25191;&#34892;Groovy&#24037;&#20855;&#31867;CpsDefaultGroovyMethods</text><path d="M708.7194,122.5938 L718.7194,122.5938 C733.7194,122.5938 733.7194,131.7422 748.7194,131.7422 L758.7194,131.7422" fill="none" style="stroke:#454645;stroke-width:1"/><path d="M514.4078,94.4453 L524.4078,94.4453 C539.4078,94.4453 539.4078,122.5938 554.4078,122.5938 L564.4078,122.5938" fill="none" style="stroke:#454645;stroke-width:1"/><path d="M382.0709,80.3711 L392.0709,80.3711 C407.0709,80.3711 407.0709,94.4453 422.0709,94.4453 L432.0709,94.4453" fill="none" style="stroke:#454645;stroke-width:1"/><path d="M212.3961,80.3711 L222.3961,80.3711 C237.3961,80.3711 237.3961,80.3711 252.3961,80.3711 L262.3961,80.3711" fill="none" style="stroke:#454645;stroke-width:1"/></g></svg><h4>CPS层执行与栈消除</h4><p>在CPS的内部AST，是一个<code>Block</code>单向链表，除了Parallel外，其它Block都是线性遍历的，因此设计上很简洁，这个与<a href="/gitbook/mybatis/">MyBatis</a>的<code>MixedSqlNode</code>/S-Expression是相同的设计思路</p><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" data-diagram-type="STATE" height="91px" preserveAspectRatio="none" style="width:584px;height:91px;background:#fff" version="1.1" viewBox="0 0 584 91" width="584px" zoomAndPan="magnify" class="kroki">$2<defs/><g><g id="Next"><rect fill="#F1F1F1" height="78.2031" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:.5" width="96.916" x="7" y="7"/><line style="stroke:#181818;stroke-width:.5" x1="7" x2="103.916" y1="33.2969" y2="33.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="32.8604" x="39.0278" y="24.9951">Next</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="32.4551" x="12" y="49.4355">Block</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="22.2891" x="12" y="63.4043">Env</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="76.916" x="12" y="77.373">Continuation</text></g><g id="Block"><rect fill="#F1F1F1" height="64.2344" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:.5" width="96.916" x="175" y="13.98"/><line style="stroke:#181818;stroke-width:.5" x1="175" x2="271.916" y1="40.2769" y2="40.2769"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="37.8643" x="204.5259" y="31.9751">Block</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="22.2891" x="180" y="56.4155">Env</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="76.916" x="180" y="70.3843">Continuation</text></g><g id="Next2"><rect fill="#F1F1F1" height="78.2031" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:.5" width="96.916" x="343" y="7"/><line style="stroke:#181818;stroke-width:.5" x1="343" x2="439.916" y1="33.2969" y2="33.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="41.7676" x="370.5742" y="24.9951">Next2</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="32.4551" x="348" y="49.4355">Block</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="22.2891" x="348" y="63.4043">Env</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="76.916" x="348" y="77.373">Continuation</text></g><g id="Block2"><rect fill="#F1F1F1" height="50" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:.5" width="66.7715" x="511.07" y="21.1"/><line style="stroke:#181818;stroke-width:.5" x1="511.07" x2="577.8415" y1="47.3969" y2="47.3969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="46.7715" x="521.07" y="39.0951">Block2</text></g><g class="link" data-entity-1="Next" data-entity-2="Block" data-source-line="5" data-uid="lnk4" id="link_Next_Block"><path d="M104.05,46.1 C126.24,46.1 146.47,46.1 168.68,46.1" fill="none" id="Next-to-Block" style="stroke:#454645;stroke-width:1"/><polygon fill="#454645" points="174.68,46.1,165.68,42.1,169.68,46.1,165.68,50.1,174.68,46.1" style="stroke:#454645;stroke-width:1"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="35.5342" x="121.96" y="39.1669">eval..</text></g><g class="link" data-entity-1="Block" data-entity-2="Next2" data-source-line="8" data-uid="lnk6" id="link_Block_Next2"><path d="M272.05,46.1 C294.24,46.1 314.47,46.1 336.68,46.1" fill="none" id="Block-to-Next2" style="stroke:#454645;stroke-width:1"/><polygon fill="#454645" points="342.68,46.1,333.68,42.1,337.68,46.1,333.68,50.1,342.68,46.1" style="stroke:#454645;stroke-width:1"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="35.5342" x="289.96" y="39.1669">eval..</text></g><g class="link" data-entity-1="Next2" data-entity-2="Block2" data-source-line="12" data-uid="lnk8" id="link_Next2_Block2"><path d="M440.29,46.1 C463.2,46.1 483.94,46.1 504.59,46.1" fill="none" id="Next2-to-Block2" style="stroke:#454645;stroke-width:1"/><polygon fill="#454645" points="510.59,46.1,501.59,42.1,505.59,46.1,501.59,50.1,510.59,46.1" style="stroke:#454645;stroke-width:1"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="35.5342" x="457.99" y="39.1669">eval..</text></g></g></svg><p>内部通过循环一个单向链表进行消除，是不是很像DP优化的第三种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.cloudbees.groovy.cps.Continuable#run0</span></span><br><span class="line"><span class="type">Next</span> <span class="variable">n</span> <span class="operator">=</span> cn.resumeFrom(e,k);</span><br><span class="line"><span class="keyword">while</span>(n.<span class="keyword">yield</span>==<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 我删掉了处理异常的代码行</span></span><br><span class="line">  n = n.step();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>JenkinsCPS的缺点</h4><p>由于它是对Jenkins深度定制的</p><ul><li>执行CPS必须需要Jenkins服务端（注意Agent只是执行原生字节码的，不处理CPS编排），没有成熟的离线解释器，因此执行调度性能限制于Jenkins单点</li><li>基于文件进行状态的持久化比较鸡肋，大部分场景中，master重启都会导致任务失败。毕竟是单点工具，没法比得过flink这种级别的Persisted States</li><li>断点调试很困难，基本上只能靠<code>echo</code>来分析脚本；CPS编程范式导致参数固定</li><li>作为插件生态开发者，那么Groovy/CPS的学习门槛的确有点高，从整个插件只有Kawaguchi一人主刀也可以看出</li></ul><h4>更深的语义定制</h4><p>假如你希望Jenkins能够实现更复杂的编排，或者自己的构建语法，可以尝试基于CPS再实现一层Interceptor，我基于此方案实现了</p><ul><li>YAML interceptor: 配合<a target="_blank" rel="noopener" href="https://plugins.jenkins.io/token-macro/">Macro解析</a>，实现用Java/Groovy实现AzureDevOps的效果，这样就可以将很多cps测试转换为无状态的测试。</li><li>Parallels BFS Tree嵌套并行执行构建</li><li>Log live tail</li></ul><p>这些是有门槛的定制场景，网上找不到开源的方案，全靠知识广度的积累。</p><h2>附录</h2><h4>关于研发效能/DevOps工具的前景</h4><p>DevOps平台一般由业务部门出预算，属于成本部门，比如“质量与效率工程部”，“研发效能部”，“基础研发平台”，“流程与IT”等名称，裁员很容易是第一批。当然也有可能发展起来后也兼任对外售卖。</p><ul><li><p>国内除了大型公司的工具组有预算买现成的或者做这种改进，其它中小公司选择很有限，举例如下</p><ul><li>阿里：经常看到阿里的人抱怨打了一天包都打不出来</li><li>百度：<ul><li>前百度研发效能团队自主创业“<a target="_blank" rel="noopener" href="https://help.ezone.work/">简单云</a>”，招聘要求那么高，结果北京顶格才4.5万，同样能力还不如在大公司/外企接着苟。</li><li>效率云：方案上还不支持config as code</li></ul></li><li>腾讯的蓝鲸对外宣称腾讯全链路构建，结果腾讯内部的Coding/Orange/TYPD等各立山头。</li><li>华为云：CloudDev，ROMA Factory DevOps，云龙平台等各搞各的，价格吃水线很高。</li></ul></li><li><p>假如工具要实现产品化可销售，由于技术上难度并不高，导致同质化严重，最好还是背靠大树来做，即和硬件/云一起去做，国内注定是强政府与强销售，要么出海和巨头（Gitlab/Github/Azure DevOps）竞争。</p></li><li><p>我个人认为这类工作很有挑战，因为它需要全局考虑，肯定比单独的业务项目有难度。</p><ul><li>机房、机柜、三层交换、云服务的配置</li><li>分布式存储（块存储、对象存储）、VPC、分布式调度器（cgroup与容器）的测试与选型</li><li>权限设计（IAM/ACL）、大数据度量与分析</li></ul></li></ul><h4>参考链接</h4><p><a target="_blank" rel="noopener" href="https://www.kimsereylam.com/racket/lisp/2019/02/14/recursion-with-fibonacci.html">https://www.kimsereylam.com/racket/lisp/2019/02/14/recursion-with-fibonacci.html</a></p><p><a target="_blank" rel="noopener" href="http://arasio.hatenablog.com/entry/2016/10/08/220843">http://arasio.hatenablog.com/entry/2016/10/08/220843</a></p><h4>插件开发技巧（如何利用当前Step/Node信息）</h4><p>由于我不希望定制场景的代码引入到Java层（重启Jenkins成本很高），但是又想获取到实时的Context信息，可以通过如下将业务代码移动到Groovy侧实现热部署</p><p>参考例本体的还原</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getting context of a *step*</span></span><br><span class="line"><span class="meta">@NoCPS</span> <span class="comment">// will not be compiled to CpsClosure, but MethodClosure</span></span><br><span class="line">def <span class="title function_">callback</span><span class="params">(result, Step s, CpsContext c)</span>&#123;</span><br><span class="line">  <span class="comment">// todo: use context, node and other metadata.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in your cps steps</span></span><br><span class="line">node&#123;</span><br><span class="line">  <span class="type">def</span> <span class="variable">result</span> <span class="operator">=</span> sh(<span class="string">&quot;xxxxx&quot;</span>)</span><br><span class="line">  <span class="comment">// implementation in java is required.</span></span><br><span class="line">  <span class="comment">// customStep内部直接调用 callback.call(this, context) 即可触发Groovy</span></span><br><span class="line">  customStep(callback: <span class="built_in">this</span>.&amp;callback.curry(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>Jenkins核心调试断点位置</h4><p>从MQ取到Executor开始执行的位置(之前都是Jenkins的调度过程)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jenkinsci.plugins.workflow.job.WorkflowRun#run</span><br></pre></td></tr></table></figure><p>整个Workflow总断点位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jenkinsci.plugins.workflow.cps.CpsFlowExecution#start</span><br></pre></td></tr></table></figure><p>如果只关注Step相关流程，可以在这里进行分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jenkinsci.plugins.workflow.cps.DSL#invokeMethod</span><br></pre></td></tr></table></figure></div><div class="tags"><a class="tag-link" href="/tags/CPS/" rel="tag">CPS</a><a class="tag-link" href="/tags/DP/" rel="tag">DP</a><a class="tag-link" href="/tags/FP/" rel="tag">FP</a><a class="tag-link" href="/tags/Groovy/" rel="tag">Groovy</a><a class="tag-link" href="/tags/Jenkins/" rel="tag">Jenkins</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry.</a><span> All contents are not allowed to be redistributed or synthesised without an explicit permission.</span></div></footer></div></body></html>