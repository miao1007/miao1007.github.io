<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="本文首先介绍了Zookeeper的应用、接着叙述了zk的端到端流程，最后讲解了Zookeeper中数据结构DataTree的实现方法。"><meta name="keyword" content="CodeReview,MicroService"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Zookeeper-内部树的实现</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://eu.umami.is/script.js" data-website-id="449a84b6-be9e-49de-a4cc-e0fa6fea1df9"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">Zookeeper-内部树的实现</div><div class="date no-print">2016-09-26 / modified at 2022-04-04 / 1.7k words / 6 mins</div><div class="content"><blockquote><span>️This article has been <strong>over 3 years</strong> since the last update.</span></blockquote><p>本文首先介绍了Zookeeper的应用、接着叙述了zk的端到端流程，最后讲解了Zookeeper中数据结构DataTree的实现方法。</p><span id="more"></span><p>本文读者：对分布式应用框架Zookeeper有兴趣了解的开发者。</p><p>本文环境：</p><ul><li>Zookeeper版本：3.5.2</li><li>运行模式：Standalone，无鉴权</li><li>工具：Clion/Ant/Intellij Idea</li></ul><p>下载完源码后，在当前目录下运行<code>ant -p build.xml</code>，它将列举所有的任务。执行你想要的命令，比如<code>ant eclipse</code>，它将自动生成<code>.project</code>等文件，这时你就可以用Idea等工具导入项目了。</p><blockquote><p>Ant下载速度非常慢，你可能需要<strong>cow</strong>作为ant的前置代理工具</p></blockquote><h2>1. Zookeeper的介绍</h2><p><a target="_blank" rel="noopener" href="https://zookeeper.apache.org/releases.html">Zookeeper</a>(以下简称zk)是一款分布式协同工作集中管理的服务。看起来有点拗口，也难以理解，其实你可以把它当成Windows上的注册表就简单了——Zookeeper的名词本身就有这个含义：让动物园里的各种动物景然有序。如果你曾经在Windows优化大师的时代折腾过注册表，那么你对zk的理解将更加容易。</p><blockquote><p>Windows 的“配置”，全都记录在一个中央数据库（注册表）里面，这样程序的配置得到大大的简化。虽然在 Win95 的年代，注册表貌似老是惹麻烦，但现在基本上没有什么问题了。相反，Unix 的配置，全都记录在各种稀奇古怪的配置文件里面，分布在系统的各个地方。你搞不清楚哪个配置文件记录了你想要的信息。每个配置文件连语法都不一样！这就是为什么用 Unix 的公司总是需要一个“系统管理员”，因为软件工程师们才懒得记这些麻烦的东西。——王垠《<a target="_blank" rel="noopener" href="http://yinwang.org/blog-cn/2013/03/07/linux-windows-mac">谈 Linux，Windows 和 Mac</a>》</p></blockquote><p>举个例子，下面是zk维护的数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">／</span><br><span class="line">----／ChildPath</span><br><span class="line">--------/Node1</span><br><span class="line">--------/Node2</span><br><span class="line">------------/Node3</span><br><span class="line">----／ChildPath2</span><br><span class="line">--------/ChildPath3</span><br><span class="line">------------/Node3</span><br></pre></td></tr></table></figure><p>说了这么多，那么zk有什么用呢？</p><ul><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Name_service">Naming service</a>：通过基于树的命名服务，支持发布、订阅，并能够与Spring集成实现微服务。具体点就是可以将接口与实现类注册发布，约定好传输语法(HTTP、私有Socket、反射调用等)与抽象语法（比如SDL、SOAP、或者自己编写的DSL），就可以实现跨进程路由与通信，比如分布式计算、分布式数据库等。</li><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Configuration_management">Configuration management</a>：用来集成配置(properties)属性，这样可以实现代码与配置分离，避免硬编码或者读取文件。</li><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Message_Queue">Message Queue</a>：实现了消息队列，比如<a target="_blank" rel="noopener" href="http://kafka.apache.org/">Apache Kafka</a>就通过利用zk的通知功能进行主动消费，<a target="_blank" rel="noopener" href="https://www.infoq.com/articles/apache-kafka">这里</a>有更详细的介绍。</li></ul><p>因为本文<strong>只分析单机版</strong>，主要分析内部数据结构，关于zk高级特性比如集群选举之类的晚点再开文章写。</p><h2>2. Zookeeper的端到端流程</h2><h5>2.1. 客户端流程:</h5><ol><li><p>接收用户来自Terminal的标准输入请求，比如“ls /”，并跳转到相应的处理函数中</p></li><li><p>创建Socket报文，将命令序列化，包括Header与Body</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//serialize &quot;xid&quot; &quot;type&quot;</span></span><br><span class="line"><span class="comment">//xid: 事件</span></span><br><span class="line">rc = serialize_RequestHeader(oa, <span class="string">&quot;header&quot;</span>, &amp;h);</span><br><span class="line"><span class="comment">//serialize &quot;path&quot; &quot;watch&quot;</span></span><br><span class="line">rc = rc &lt; <span class="number">0</span> ? rc : serialize_GetChildrenRequest(oa, <span class="string">&quot;req&quot;</span>, &amp;req);</span><br></pre></td></tr></table></figure></li><li><p>将请求发入队列，这里使用了poll的机制去轮询寻找<code>POLLOUT</code>，也就是<code>可写入</code>的socket</p></li><li><p>通过系统调用send发送到服务端</p></li></ol><p>以上分析的基于C的ClientAPI，当然还有Java版、Node版的API，都是一个套路，这里就不分析了。</p><h5>2.2. 服务端流程：</h5><p>当用户启动<code>./zkServer.sh start</code>时，实际启动的是下面的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.zookeeper.server.quorum.QuorumPeerMain /usr/local/etc/zookeeper/zoo.cfg</span><br></pre></td></tr></table></figure><p>最终调用栈调用的是<code>NIOServerCnxnFactory</code>的<code>Ruunable</code>接口，即run方法，它将在2181端口通过Select系统调用轮询并处理Socket请求。</p><p>当客户端发送<code>ls /</code>等常规请求后，将调用这里的函数进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  	<span class="comment">//处理数据报文</span></span><br><span class="line">    zkServer.processPacket(<span class="built_in">this</span>, incomingBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Zookeeper将会把请求进入队列<code>LinkedBlockingQueue</code>中，即先进先出，最终先后在<code>PrepRequestProcessor</code>与<code>FinalRequestProcessor</code>中对数据进行实际的业务处理。</p><blockquote><p>▶︎ 在zk中，通过Apache Jute (Hadoop Record Compiler) 作为通信类（比如ls,create等）的元数据，它定义内部序列化与反序列化的实现，并能够通过元数据编译器生成Java对象。这里就不详细说了。如果你对它有兴趣，可以用它来做一个Wireshark的zookeeper协议解码插件。</p></blockquote><blockquote><p>▶︎ 你可以在<code>FinalRequestProcessor</code>的<code>switch (request.type)</code>位置打断点，进而了解它的操作流程</p></blockquote><h2>3. Zookeeper内部数据结构的维护</h2><p>Zookeeper中通过<code>ZKDatabase</code>实现数据管理，它在内存中维护着一个<code>DataTree</code>，内部通过Hash对Tree进行索引。看清楚了这里是Hash而<strong>不是</strong>当初数据结构书中那样通过链表层层嵌套指针来实现树。</p><p>下图展现了Zookeeper日常存储的方法，图左为key，图右为value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;/&quot; =&gt; Node1</span><br><span class="line">&quot;/zookeeper&quot; =&gt; Node2</span><br><span class="line">&quot;/zookeeper/child&quot; =&gt; Node3</span><br><span class="line">&quot;/zookeeper/child2&quot; =&gt; Node4</span><br></pre></td></tr></table></figure><p>当你在cli端调用 <code>get /zookeeper/child</code>时，它将会在后台通过key-value的形式，即查询map.get(&quot;/zookeeper/child&quot;)并返回<code>DataNode</code>数据</p><p>具体的结构如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTree</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This hashtable provides a fast lookup to the datanodes. The tree is the</span></span><br><span class="line"><span class="comment">     * source of truth and is where all the locking occurs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, DataNode&gt; nodes =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, DataNode&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ConcurrentHashMap的put操作中没有对class或者method加锁，而是只对桶(BLOCK)加了锁，粒度非常低，进而提高并发性能。这个在JDK8改动很大，是个难点。</p></blockquote><p><code>DataNode</code>作为Map的Value，是保存数据的节点，如下图这样构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataNode</span> <span class="keyword">implements</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    DataNode parent;</span><br><span class="line">  	<span class="comment">//当你调用`create /zookeeper/test testdata`时，这里的</span></span><br><span class="line">    <span class="comment">//data[]就保留你的&quot;testdata&quot;字符串</span></span><br><span class="line">    <span class="type">byte</span> data[];</span><br><span class="line">    Long acl;</span><br><span class="line">    <span class="keyword">public</span> StatPersisted stat;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; children = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，用户在cli端进行<code>get $&#123;path&#125;</code>, <code>create $&#123;pata&#125; $data</code>之类的操作时，实际上就是在<strong>远程操作一个HashMap</strong>，Zookeeper内部并没有像想象中使用红黑树等高大上的结构，而是使用最简单的Hash表来实现。</p><p>通过Hash表进行索引自然有它的好处，程序的get/set时间复杂度降低到了常数级别，但是它牺牲了空间——你可以看出，上图的树根<code>/zookeeper</code>字符串在每个节点中都有冗余。</p><h2>4. TODO</h2><p>晚点将继续写：</p><ul><li>zookeeper的watcher机制</li><li>zookeeper的多机场景下的选举与缓存一致的实现</li><li>ConcurrentHashMap的内部put/get实现</li></ul><h2>5. REFFERENCE</h2><ol><li><a target="_blank" rel="noopener" href="http://www.tutorialspoint.com/zookeeper/zookeeper_cli.htm">http://www.tutorialspoint.com/zookeeper/zookeeper_cli.htm</a></li><li><a target="_blank" rel="noopener" href="http://www.amazon.cn/gp/search?ie=UTF8&amp;camp=536&amp;creative=3200&amp;index=books&amp;keywords=ZooKeeper:%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%87%E7%A8%8B%E5%8D%8F%E5%90%8C%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3&amp;linkCode=ur2&amp;tag=kkd8-23">《ZooKeeper:分布式过程协同技术详解》</a></li></ol></div><div class="tags"><a class="tag-link" href="/tags/CodeReview/" rel="tag">CodeReview</a><a class="tag-link" href="/tags/MicroService/" rel="tag">MicroService</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry.</a><span> All contents are not allowed to be redistributed or synthesised without an explicit permission.</span></div></footer></div></body></html>