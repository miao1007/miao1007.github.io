<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="其实这本书早就买了，本来是作为字典查知识点的，现在又读了一遍。使用Groovy已经有了接近一年的时间，再读一遍。本文就是一些总结。"><meta name="keyword" content="Book,FP,Groovy"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>《Groovy程序设计》读书笔记</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">《Groovy程序设计》读书笔记</div><div class="date">2017-02-20 / modified at 2022-04-04</div><div class="content"><blockquote><span>️This article has been <strong>over 1 years</strong> since the last update.</span></blockquote><p>其实这本书早就买了，本来是作为字典查知识点的，现在又读了一遍。使用Groovy已经有了接近一年的时间，再读一遍。本文就是一些总结。</p><span id="more"></span><h2>1. Groovy学习路线</h2><p>Groovy在网上还是比较冷，如果读者不喜欢Groovy，项目没有使用或者对DSL没有兴趣的话，可以去试一下kotlin</p><h4>1.1. 学习流程</h4><ul><li>直接找一本书开始看，比如本文的书</li><li>看了一半，使用GroovyConsole工具去实验</li><li>使用Groovy代替Java去写部分代码</li><li>最终重构Java代码，它将有强烈的Groovy风格</li></ul><h4>1.2. 学习工具建议</h4><ul><li>使用Idea作为开发工具，它可以实现类型推导，并且反编译看Groovyc生成的Java也非常方便</li><li>特别推荐使用调试时的<code>Code Fragment</code></li><li>加入<code>CompileStatic</code>注解，实现了Groovy静态化，方便对比编译结果</li></ul><h2>2. Groovy部分知识点</h2><p>由于学的语言比较多，因此只说下Groovy的重点特性</p><h3>2.1. 操作符重载</h3><p>默认的各种重载通过<code>DefaultGroovyMethods</code>实现，这个C++，Scala等语言也是支持的。工具类代码难度不高，可读性也没问题，类似于Guava。</p><h4>2.1.1. boolean值重载: asBoolean()</h4><p>测试代码如下</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> a = []</span><br><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line">    println <span class="string">&quot;not null&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println <span class="string">&#x27;null&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现它的调用栈是如下的，也就是说，在Groovy中，if要求返回值必须为boolean，所有数据最终都会调用<code>asBoolean()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.codehaus.groovy.runtime.DefaultGroovyMethods.asBoolean(DefaultGroovyMethods.java:10390)</span><br><span class="line">org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToBoolean(DefaultTypeTransformation.java:185)</span><br><span class="line">org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.booleanUnbox(DefaultTypeTransformation.java:74)</span><br><span class="line">test.run(test.groovy:2)</span><br></pre></td></tr></table></figure><p>因此在Groovy中，不需要写<code>if(s== null || s.isEmpty())</code>这样的代码，而是直接用<code>if(s)</code>即可</p><blockquote><p>这里有个坑，比如if(0)就返回了false，而很多时候<code>0</code>是有意义的，导致费用等业务出现逻辑错误。</p></blockquote><h4>2.1.2. <code>+</code>重载: plus()</h4><p>这个API过于灵巧了，比如List相加的时候。我个人建议用<code>plus</code>代替<code>+</code>，因为时间久了这些语法糖可能会忘记</p><blockquote><p>你可以借助IDE的类型推导，按住Ctrl点击代码的加号，就可以进入相应的源码中</p></blockquote><h4>2.1.3. 其它操作符重载</h4><p>这些用的不多，自己点进去看吧</p><ul><li>forIn重载: next()</li><li><code>&lt;&lt;</code>重载: leftShift()</li><li>a[‘b’]属性获取: a.getAt(‘b’)</li></ul><h3>2.2. 集合类</h3><p>Groovy的集合类API几乎没有任何门槛，比如each, find, collect 等，这种API一次学习，各个平台都可以使用。实现类同样在<code>DefaultGroovyMethods</code>中，这些API必须精通至少一个平台</p><blockquote><p>这类代码都推荐看，类似还有Java8的Stream, Google的Guava, 都是惰性求值。有了此类代码的思路，以后遇到新语言直接看DOC即可。</p></blockquote><h3>2.3. 使用Groovy设计DSL</h3><p>DSL是领域专属语言，使用Groovy开发DSL有如下优点</p><ul><li>相对应Java，性能差距并不是非常大，同样享受到了JVM红利，并且也支持静态编译。</li><li>相对应XML等外部DSL，信息量比标记语言更大（想想ant与<a target="_blank" rel="noopener" href="http://docs.groovy-lang.org/latest/html/documentation/ant-builder.html">gradle</a>的区别），而且它的methodInvoking机制非常方便定制</li><li>相比于自己折腾一个新语言，它不用实现复杂的Parser与断点/IDE，避免了内部派系之争</li></ul><p>举个例子，有的老项目采用了ant脚本进行打包，调试费力不说，跨平台换个jar包也一堆问题，这时我们可以用Groovy+Jenkens去代替它</p><p>比如配置一个maven任务，可以是下面这样的，源码见<a target="_blank" rel="noopener" href="https://github.com/jenkinsci/job-dsl-plugin/blob/master/job-dsl-core/src/main/docs/examples/javaposse/jobdsl/dsl/DslFactory/mavenJob.groovy">这里</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mavenJob(<span class="string">&#x27;example&#x27;</span>) &#123;</span><br><span class="line">    logRotator(<span class="number">-1</span>, <span class="number">10</span>)</span><br><span class="line">    jdk(<span class="string">&#x27;Java 7&#x27;</span>)</span><br><span class="line">    scm &#123;</span><br><span class="line">        github(<span class="string">&#x27;jenkinsci/jenkins&#x27;</span>, <span class="string">&#x27;master&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    triggers &#123;</span><br><span class="line">        githubPush()</span><br><span class="line">    &#125;</span><br><span class="line">    goals(<span class="string">&#x27;clean verify&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你熟悉Jenkins，那么上面的代码几乎可以秒懂，甚至一个Groovy外行也可以修改定制。</p><blockquote><p>单行代码中的信息量表达能力越高，它越仅适用于某些特定业务——它背后的解释器专为这些语法进行定制。</p></blockquote><h4>2.3.1. Closure、Lambda and Functional Programming</h4><p>闭包是短小的、轻量的匿名函数，在动态语言中使用非常广泛。它最开始从函数式编程的Lambda表达式中派生，指定了一个函数的参数与映射，并加入了语法糖。在实际开发中，闭包一般用于</p><ul><li>封装业务无关的样板代码（比如资源清理，网络连接、简化循环），值得注意的是，闭包多作为参数传入函数，而工具类是作为主动方去调用的。使用Groovy的Category可以无侵入使用Java之前的工具类</li><li>创建内部DSL，比如Groovy的XmlMarkup</li></ul><h4>2.3.2. 闭包与函数的区别</h4><ol><li>函数入参可以把闭包代码段作为入参传入</li><li>闭包是匿名函数。函数用于解决特定领域问题，闭包着重于解决通用领域问题</li><li>函数与闭包内部都尽量避免与外界接触，最好是“无状态”的，比如Java的匿名内部类就强制外部变量为<code>final</code></li></ol><h2>REFFERENCE</h2><ol><li><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/58529ca715a3">集合类工具Guava与惰性求值</a></li><li><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/40050ded099c">函数式编程RxJava操作实例</a></li><li><a target="_blank" rel="noopener" href="https://github.com/shekhargulati/java8-the-missing-tutorial">https://github.com/shekhargulati/java8-the-missing-tutorial</a></li><li>《Java8函数式编程》</li></ol></div><div class="tags"><a class="tag-link" href="/tags/Book/" rel="tag">Book</a><a class="tag-link" href="/tags/FP/" rel="tag">FP</a><a class="tag-link" href="/tags/Groovy/" rel="tag">Groovy</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>