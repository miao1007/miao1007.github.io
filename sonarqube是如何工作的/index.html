<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="SonarQube是代码检查工具的技术标杆之一，除了用来检查项目，它本身也是开源的，源码(代码结构/技术文档等)也必然是值得一读。"><meta name="keyword" content="DevOps,SonarQube"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>SonarQube是如何工作的</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body class="container"><header id="header"><div class="header"><div class="header-left"><div class="author"><div class="author-name"><a href="/">諺</a></div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">Archives</a></li><li style="font-size:.9rem"><a href="/archives" rel="nofollow">zh</a></li><li style="font-size:.9rem"><a href="#" rel="nofollow">|</a></li><li style="font-size:.9rem"><a href="/en" rel="nofollow">en</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">Epistemology</a></li><li><a href="/books" rel="nofollow">読書</a></li></ul></div></div></header><div class="content-wrapper"><div class="post"><section class="article"><div class="title">SonarQube是如何工作的</div><div class="date">2019-01-16に投稿</div><div class="content"><p>SonarQube是代码检查工具的技术标杆之一，除了用来检查项目，它本身也是开源的，源码(代码结构/技术文档等)也必然是值得一读。</p><span id="more"></span><p>通过阅读源码，我们可以学到</p><ul><li>一款顶尖复杂的软件项目的结构与模块如何划分</li><li>一个复杂前端的React实现</li><li>如何混合使用ES与数据库</li></ul><p>在阅读本文前，众所周知源码分析非常耗费时间，重复一下源码分析方法论</p><ul><li>能够充分使用过此项目，并阅读<a target="_blank" rel="noopener" href="https://docs.sonarqube.org/latest/architecture/architecture-integration/">文档</a>，这一步主要掌握上下文与术语</li><li>分析项目的依赖，并全部过一遍</li><li>找到免编译的路由断点与关键日志位置</li><li>充分使用FindUsage快速Jump</li></ul><h2>预先准备</h2><p>由于编译SonarQube非常繁琐耗时，我建议提前下载好编译好的二进制文件，导入源码后配置Remote断点以实现降低分析耗时(类似以前写的通过GDB断点JVM)</p><h4>下载源码</h4><ul><li>下载SonarQube编译好的二进制文件，并确保已经有数据</li><li>通过Github下载源码，导入IDEA中，并将Head切到与二进制一样的版本</li></ul><h4>配置断点</h4><p>在IDEA中配置Remote断点，并在源码中如下位置打下断点</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.sonar.ce.app.CeServer<span class="comment">#start</span></span><br></pre></td></tr></table></figure><p>在SonarQube中配置<code>sonar.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">sonar.ce.javaOpts</span>=<span class="string">-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5006</span></span><br><span class="line"><span class="meta">sonar.web.javaOpts</span>=<span class="string">-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5007</span></span><br></pre></td></tr></table></figure><p>然后运行SonarQube，如果Ok的话断点就断上了</p><h2>SonarQube组件构成</h2><h4>服务端(ServerSide)</h4><p>在服务端(org.sonar.application.App)启动时，会依此启动如下Process(通过<code>ps aux|grep sonar</code>分析)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.sonar.application.App</span><br><span class="line">	org.elasticsearch.bootstrap.Elasticsearch</span><br><span class="line">	org.sonar.ce.app.CeServer</span><br><span class="line">	org.sonar.server.app.WebServer</span><br></pre></td></tr></table></figure><p>它们的作用分别是</p><ul><li>ElasticSearch: 内嵌的ElasticSearch，版本为5，它内部还没有用推荐的<code>_doc</code>作为type</li><li>Compute Engine(CE): 计算引擎，通过解析计算客户端上传的Zip，显示到前端</li><li>Web: 本质是数据仓库的前台。主要有用React实现的前端与API代理，通过内嵌的Tomcat实现部署</li></ul><p>它们的PID分别如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p_es=`ps aux|grep Elasticsearch|grep java |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line">p_ce=`ps aux|grep CeServer|grep java |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line">p_web=`ps aux|grep WebServer|grep java |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br></pre></td></tr></table></figure><p>通过lsof查看每个服务的监听情况，并在源码中全局搜索</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lsof -i -n -P |grep java|grep LISTEN|grep <span class="variable">$&#123;p_es&#125;</span></span><br><span class="line"><span class="comment"># --&gt; 9001(Elastic默认TCP端口)</span></span><br><span class="line">lsof -i -n -P |grep java|grep LISTEN|grep <span class="variable">$&#123;p_ce&#125;</span></span><br><span class="line"><span class="comment"># --&gt; 54918(没查到，可能是随机端口)</span></span><br><span class="line">lsof -i -n -P |grep java|grep LISTEN|grep <span class="variable">$&#123;p_web&#125;</span></span><br><span class="line"><span class="comment"># --&gt; 9000(HTTP端口), 9092(H2数据库端口)</span></span><br></pre></td></tr></table></figure><h4>客户端(ScannerSide)</h4><ul><li>Analyser: 源码分析器，在客户机上计算，通过HTTP将ZIP发给WebServer</li></ul><h2>组件实现</h2><h4>内嵌H2数据库</h4><p>直接免密码访问如下JDBC即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:h2:tcp://127.0.0.1:9092/sonar</span><br></pre></td></tr></table></figure><p>当然你也可以自己搭建一个本地的pg库。在Java层使用了MyBatis进行查询。</p><h4>ElasticSearch里存的啥</h4><p>在SonarQube中，ElasticSearch的配置文件是程序生成的。由于默认关闭了HTTP端口的，导致难以通过外部工具进行连接，我们可以进行如下Hack实现在启动ElasticSearch前修改配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configure <span class="keyword">in</span> conf/sonar.properties the entry `sonar.search.httpPort=9200`.</span><br></pre></td></tr></table></figure><p>这样启动后，通过<code>elastic head</code>等工具访问<code>http://localhost:9200/</code>就可以知道里面存的啥了。其实里面只存储了一些主键的uuid</p><p>比如下面存储了issues的主键<code>kee</code>对应下面的<code>_id</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span>: <span class="string">&quot;issues&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span>: <span class="string">&quot;auth&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;AXR4KEWgqc90wyxKGvI6&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_score&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_routing&quot;</span>: <span class="string">&quot;auth_AXR4J_kRLlgBvFiws367&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有<code>rules</code>也只是用来存储主键，并没有像想象中缓存了很多error/warings的报错。这里的ELK场景类似于提供了一个类似HBase的唯一RowKey（联合主键），是Stream计算后的缓存，下游DB只用查询<code>in</code>即可，性能更好，这样就算是一堆left join，也都是低计算强度的聚合。</p><blockquote><p>假如你将ELK删除，然后重启可以发现会自动修复，说明本项目中ELK定位只是主键/分页的索引作用，这个Key承载了太多信息。</p></blockquote><h4>WebServer</h4><p>它部署了一个嵌入的Tomcat，通过Java(而不是通过Spring的DSL)手动实现添加webApp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.sonar.server.app.TomcatContexts#addContext</span><br></pre></td></tr></table></figure><p>等Tomcat部署后，将调用<code>PlatformServletContextListener</code>启动Platform(这里并没有使用Spring作为依赖注入，而是使用了<code>picocontainer</code>实现，使用Java编码而没有用注解/XML等DSL进行描述依赖关系)，启动API业务</p><p>最终部署如下业务</p><table><thead><tr><th>部署类型</th><th>ContextPath</th><th>ByWho</th></tr></thead><tbody><tr><td>API业务</td><td>/api</td><td>WebServiceFilter, 类似于Struts</td></tr><tr><td>React静态文件</td><td>默认是<code>/</code>, 详见<code>sonar.web.context</code></td><td>web</td></tr><tr><td>插件Jar仓库静态文件</td><td>/deploy</td><td>data/web/deploy</td></tr></tbody></table><p>所有的API请求均可以通过如下位置进行断点分析到业务中</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.sonar.server.ws.WebServiceEngine#execute</span><br></pre></td></tr></table></figure><p>这样本文的引导作用就达到了，剩下具体业务自行断点分析</p><blockquote><p>我在这里耗费了较多时间，本以为API业务是由Servlet进行处理，没想到居然是通过全手写Filter与Action的方法处理(10年前这种方法很先进)，可以看出SonarQube也是有历史债务的，但是它的代码质量经过长期maintain后仍然清晰。</p><p>注意项目中的<code>StaticResourcesServlet</code>已经事实上废弃，因为已经没有<code>static</code>文件夹了</p></blockquote><h4>CE如何录入计算结果？</h4><p>总流程如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner-(HTTP)-&gt;Web-(MQ)-&gt;CE</span><br></pre></td></tr></table></figure><p>首先在Scanner通过Maven等工具在Jenkins等平台(占用这些平台的计算资源)计算出项目的各种分析报告，然后Scanner调用Web中如下接口</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://localhost:9000/api/ce/submit?projectKey=xxx&amp;projectName=yyy</span></span><br><span class="line">org.sonar.server.ce.ws.SubmitAction#handle</span><br></pre></td></tr></table></figure><p>WebServer将原始RAW文件录入<code>ce_task_input</code>，接着通过消息队列(DB Based)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.sonar.ce.queue.CeQueueImpl#submit(org.sonar.ce.queue.CeTaskSubmit)</span><br></pre></td></tr></table></figure><p>CE侧通过线程池每隔两秒轮询查询任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.sonar.ce.taskprocessor.CeWorkerImpl#call</span><br></pre></td></tr></table></figure><p>最终任务将通过路由到如下位置，执行数据仓库录入等任务</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.sonar.ce.task.step.ComputationStepExecutor#executeStep</span><br></pre></td></tr></table></figure><h2>疑问解答</h2><h4>SonarQube如何实现存储源码？</h4><p>通过访问表<code>file_sources</code>中的<code>BINARY_DATA</code>与protobuf实现存储，它与File通过<code>FILE_UUID</code>进行关联</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.sonar.server.source.ws.LinesAction#handle</span><br></pre></td></tr></table></figure><p>你在前台查询的issues等信息，实际上就是数据库多张表join查出来的，SQL优化的好，就算没缓存也很快。</p><h4>SonarQube与Markdown</h4><p>通过基于正则表达式的规则引擎实现，这个做的比较简单，没有实现AST</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.sonar.channel.ChannelDispatcher#consume</span><br></pre></td></tr></table></figure><h4>SonarQube的React如何实现</h4><p>前台使用了React与JSX实现业务，使用Webpack进行打包，使用<a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/dev-server/">WebPackDevServer</a>作为API代理，前端通过如下启动外壳业务，打包脚本见<code>server/sonar-web/config/webpack.config.js</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动业务(使用NodeJS提供Server)</span></span><br><span class="line">node server/sonar-web/scripts/start.js</span><br><span class="line"><span class="comment"># 打包(后续交给Tomcat处理)</span></span><br><span class="line">node server/sonar-web/scripts/build.js</span><br></pre></td></tr></table></figure><h4>SonarQube如何分析代码AST？</h4><p>这里采用插件实现，比如Java在<a target="_blank" rel="noopener" href="https://github.com/SonarSource/sonar-java">这里</a>可以找到，分析后将转为通用格式发给Web进行处理</p><p>如果项目组需要定制Custom Rule，就可以通过访问<code>onMethodInvocationFound</code>实现自己的规则</p><h2>Appendix</h2><p>学到的其它技巧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal更优雅的启动方法</span></span><br><span class="line">ThreadLocal&lt;Boolean&gt; CACHING_ENABLED = ThreadLocal.withInitial(() -&gt; Boolean.FALSE);</span><br></pre></td></tr></table></figure></div><div class="tags"><a class="tag-link" href="/tags/DevOps/" rel="tag">DevOps</a><a class="tag-link" href="/tags/SonarQube/" rel="tag">SonarQube</a></div></section><ul class="nav"><li>Prev:<a href="/mac%E4%B8%8B%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8wine4%E6%9C%80%E5%85%A8%E6%8C%87%E5%AF%BC/">Mac下安装与使用Wine4最全指导</a></li><li>Next:<a href="/risc-v%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">RISC-V处理器读书笔记</a></li></ul><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the<a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript></div></div></div></div><footer><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer><script>window.onload=function(){var a,e,n,t;a=window,e=document,t="script",n="ga",a.GoogleAnalyticsObject=n,a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=+new Date,n=e.createElement(t),t=e.getElementsByTagName(t)[0],n.async=1,n.src="//www.google-analytics.com/analytics.js",t.parentNode.insertBefore(n,t),ga("create","UA-102296742-1","auto"),ga("send","pageview")}</script></body></html>