<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="控制反转是一种简化开发的方法，可以轻易地获取对象而不用考虑如何构建，实现了高效解藕与测试。在Java后端、Android端、PHP等领域均很常见，比如Server端的Autowired、Android中的getSystemService都是控制反转的例子。"><meta name="keyword" content="CodeReview,Spring"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Spring下的控制反转(IOC)</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">Spring下的控制反转(IOC)</div><div class="date">2016-08-20 / modified at 2022-04-04</div><div class="content"><blockquote><span>️This article has been <strong>over 1 years</strong> since the last update.</span></blockquote><p>控制反转是一种简化开发的方法，可以轻易地获取对象而不用考虑如何构建，实现了高效解藕与测试。在Java后端、Android端、PHP等领域均很常见，比如Server端的<code>Autowired</code>、Android中的getSystemService都是控制反转的例子。</p><span id="more"></span><p>本文基于Spring4.0+进行分析</p><blockquote><p>什么方向的控制被反转了？答案是依赖对象的获得。</p></blockquote><h2>IOC的简介</h2><p>实现控制反转主要有两种方法，一个是依赖注入(DependenceInjection)，另一个是依赖查找(DependenceLookUp)。前者是被动地接受所依耐的其它组件被Ioc容器注入，而后者通过主动调用一个全局的<code>Map&lt;Name, Component&gt;</code>查询实现。通过元数据可以剥离内部细节，降低样板代码。</p><p>至于两者的区别，在StackOverflow上的<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/28039232/what-is-the-difference-between-dependency-injection-and-dependency-look-up">相关解答</a>中，是这样介绍的</p><blockquote><p>The main difference between the two approaches is “who is responsible for retrieving the dependencies”.</p></blockquote><h2>依赖注入的实现</h2><h4>依赖注入的描述方法</h4><p>实现依赖注入，也就意味着注入框架能够理解组件间的构造关系，而这种构造关系一般采用标记语言进行描述，它们被称作元数据(metadata)，更深入的话叫做领域专属语言(DSL)，为了便于理解，下文均称作DSL。Spring支持多种DSL的描述方法</p><ul><li>以XML/YAML为主的外部DSL，它内部描述各种依赖情况</li><li>通过Ruby、Groovy等动态语言为描述的内部DSL</li><li>通过直接对Java进行<code>@Config</code>标记(目前SpringBoot比较流行AutoConfig)</li></ul><p>上面的具体实现各有便利性的优势，均由BeanFactory接口进行规范，当然在大型项目中，为了维护可控与降低门槛，一般采用XML对关系进行描述，基于XML的是DefaultBeanFactory。</p><h4>解释器与动态代理</h4><p>通过对DSL进行处理并输出结果的流程叫做Interceptor(解释器)，而Context就是解释器运行时的上下文，在Spring中，输入是XML的依赖描述，输出是动态代理生成的Bean对象，很多Spring分析的厚书耗费很长时间去分析各种Java细节，但是万变不离其宗: 这种设计模式在很多用于简化开发的开源框架中均存在</p><ul><li>通过XML与OGNL简化SQL操作的MyBatis，具体实现是LanguageDriver</li><li>通过为HTML加入Tag实现简化绑定的AngularJS，具体实现是<code>$Parser</code></li><li>通过注解简化请求的Feign/Retrofit</li><li>通过上下文与HTML实现静态输出的TemplateEngine: 比如JSP/Jeklly</li></ul><p>所以在分析源码时，千万不要陷入实现细节中，比如Spring中的Bean对象就是最核心的AST，而它之前的XML是如何转换解析<strong>并不重要</strong>。</p><p>总体流程如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XML/YAML --(Parser)--&gt; AST(BeanDefinition) --(Eval)--&gt; Map</span><br></pre></td></tr></table></figure><h4>基于XML/Java依赖注入的实现</h4><p>虽然刚刚讲了并不重要，但是照顾初学者，在本文中将以Spring与XML为例，对依赖注入的过程进行分析。</p><p>Spring的主要流程如下图所</p><h4>文本反序列化为AST(BeanDefination)</h4><p>此部分发生在refresh操作前</p><p><strong>XML实现</strong></p><p>比如在XML中定义了一个bean，这个对象是一个Car，它需要使用oil作为构造引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;textEditorConstructorBasedDI&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">class</span>=<span class="string">&quot;com.github.miao1007.Car&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;oil&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一步将XML文本转换为Dom元素，即<code>org.w3c.dom.Document</code>。这个是一个非常大众化的解析XML组件，从XML文本到Dom元素的具体实现也是一个累活，这里就不详细讲了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">springrest.xml(XML文件)</span><br><span class="line">  	|</span><br><span class="line">w3c解析XML</span><br><span class="line">  	|</span><br><span class="line">DOM元素(java对象)</span><br></pre></td></tr></table></figure><p>接着进行<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90">词法分析</a>(通过BeanDefinitionParser实现)与反序列化对象。首先将XML中的字符串转换为Token，此部分同样干的得都是累活，主要是遍历DOM，然后for-switch循环匹配XML中的属性(比如<code>class</code>，<code>Node</code>等)，并最终合并并构造为BeanDefination对象。</p><p><strong>纯Java实现</strong></p><p>代码很短，我可以把它全贴出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBeanTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringBeanTest.class);</span><br><span class="line">    <span class="type">Car</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(Car.class);</span><br><span class="line">    System.out.println(bean.getOil().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">(Oil oil)</span> &#123;</span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">    car.setOil(oil);</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Oil <span class="title function_">getOil</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Oil</span> <span class="variable">oil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Oil</span>();</span><br><span class="line">    oil.setName(<span class="string">&quot;Shell&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> oil;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，就是这么简答，Spring不需要容器也是可以运行的。源码也比较容易阅读，解析注解并转为下面的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BeanDefinition</span>&#123;</span><br><span class="line">  String beanclass;<span class="comment">//com.github.miao1007.Car</span></span><br><span class="line">  ConstructorArgumentValues constructorArgumentValues;</span><br><span class="line">  <span class="comment">// ConstructorArgumentValues在内部维护着`List&lt;ValueHolder&gt;`，它内部维护着Oil的对象引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个大Class放到了beanDefinitionMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, BeanDefinition&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><h4>通过模式匹配解析遍历AST(Refresh)</h4><p>此步骤发生在Refresh阶段，拥有了上下文等信息，现在可以启动了，此时我们分析就脱离了XML等文本细节，而是全部基于BeanDefinition这个AST进行分析。我们主要分析refresh中<code>invokeBeanFactoryPostProcessors</code>与<code>finishBeanFactoryInitialization</code>如何通过<code>DefaultListableBeanFactory</code>首先找到Oil，再找到Car。</p><p>我们接着分析基于JavaConfig的Bean注入</p><p>在<code>invokeBeanFactoryPostProcessors</code>阶段，通过如下方法解析Config注解中的Method，返回了所有的<code>@Bean</code>，注意这里是基于代码写作顺序的，Car是在前面的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurationClassBeanDefinitionReader#loadBeanDefinitions</span><br></pre></td></tr></table></figure><p>上述操作可以看作为一个对Tree的FlatMap的操作，通过一堆for循环实现，保证到下一步前所有的Bean都会被扫描进入</p><p>在<code>finishBeanFactoryInitialization</code>阶段，将按照代码写作顺序依次实例化Bean，通过如下方法实现依赖获取它的依赖<code>Oil</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//resolveDependency(DependencyDescriptor, s, s[], TypeConverter);</span></span><br><span class="line"><span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123;</span><br><span class="line">		addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个深度遍历操作，找到最终无依赖的Bean才进行初始化</p><p>然后Oil通过常规操作反射调用获得Bean</p><h2>SUM</h2><p>总的来说，在IOC的内部并没有其它非常高技巧类的代码，更多的反而是对元数据扫描、解析的纯业务工作，本文也是特例中的特例情况分析，总体上Spring能够做到非常完善的CornerCase处理。</p><p>另外网上教你如何在Spring拧螺丝的面试宝典实际上并没有用，因为面试时还是会问你怎么造火箭的。</p><h2>附录</h2><h4>SpringSchema</h4><p>SpringSchema是Spring提供的XML扩展。通过编写自己定制的XSD与BeanDefinationParser，可以实现更定制化的XML语法，比如阿里的Dubbo就使用了此扩展实现了ZK的事务注册与发布。</p><p>当然上述的 FreeMarker/SpringSchema 对应用开发来说，很难见到。毕竟自己能力与代码量很难达到设计软件架构的水平。</p><h3>如何写一个高扩展的开源框架</h3><p>比较保险的就是解释器 + 模式匹配路由到生成器(比如动态代理) + 拦截器，大部分扩展特性均可以支持</p></div><div class="tags"><a class="tag-link" href="/tags/CodeReview/" rel="tag">CodeReview</a><a class="tag-link" href="/tags/Spring/" rel="tag">Spring</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>