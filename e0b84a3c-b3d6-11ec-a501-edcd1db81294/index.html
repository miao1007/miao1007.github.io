<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="在Java中，各种大厂的集合类工具如下"><meta name="keyword" content="FP"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>集合类工具Guava与惰性求值</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://eu.umami.is/script.js" data-website-id="449a84b6-be9e-49de-a4cc-e0fa6fea1df9"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">集合类工具Guava与惰性求值</div><div class="date no-print">2016-10-15 / modified at 2022-04-04 / 1.8k words / 7 mins</div><div class="content"><blockquote><span>️This article has been <strong>over 3 years</strong> since the last update.</span></blockquote><p>在Java中，各种大厂的集合类工具如下</p><span id="more"></span><ul><li>org.apache.commons.collections4</li><li>RxJava</li><li>Guava</li><li>Java8 stream</li><li>Groovy(我个人更推荐)</li></ul><p>上面所有的函数均支持泛型，由于Java8与RxJava已经用的太熟了，collections4内部设计不太喜欢，所以下文以Guava为例进行讲解</p><blockquote><p>由于SpringBoot等主流项目中均使用18作为Guava版本，因此本文也用了比较老的18版</p></blockquote><p>目录</p><p>[TOC]</p><h2>关于惰性求值</h2><p>在函数式编程中，一般有三种结果输出函数式操作后的结果：</p><ul><li>惰性求值：内部保存着最原始数据与处理函数，List被调用时才会进行执行函数，特点是循环效率最高，但是在进行RPC或者serialization时，结果不可预料，需要<strong>保证元素被遍历</strong>。每次写线上代码时，用惰性求值都感觉是一个定时炸弹。</li><li>修改内部值：内部数据在处理函数被遍历时被修改，特点是空间占用最小，但是某些数据结构下比如ArrayList进行filter操作时，时间复杂度爆高。</li><li>新拷贝：新建一个对象，并通过原始List与函数依次赋值。这个操作最简单安全，一般也在自己的工具类中这样写，但是执行效率较低，空间比较浪费。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行函数式变化时，需要新建一个对象</span></span><br><span class="line">newList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String s: llist)&#123;</span><br><span class="line">    newList.add(<span class="string">&quot;Hello &quot;</span> + s );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前FP中，比如Haskell、Java8、Guava等函数式内部实现均采用了惰性求值。</p><h2>Guava的隐患点</h2><p>Guava作为Google开发的框架，支持简化代码、对RandomAccess进行优化，不过它采取了<strong>惰性求值</strong>。也就是说在经过函数式转换后的List，保留了原始List数据与映射函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Guava中变换后的List</span></span><br><span class="line"><span class="keyword">final</span> List&lt;F&gt; fromList;</span><br><span class="line"><span class="keyword">final</span> Function&lt;? <span class="built_in">super</span> F, ? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; function;</span><br></pre></td></tr></table></figure><p>也就是只有它被读取遍历时，才会进行真正的转换操作。在进行序列化时，可能直接反射搞到原始List，而导致结果仍然是转换前的List，</p><p>因此需要注意：</p><ol><li>序列化时可能结果不可预料，需要函数同样实现序列化接口</li><li>在变换后的List中，除了list的for循环操作，其它操作(比如size,add)或多或少会导致危险或者性能问题。因此在完成函数式操作流程后，建议返回一个不可变的List或者常规的ArrayList，以免节外生枝。</li><li>在Guava中，如果你使用SOAP、JSON、Hibernate、ProtocolBuf或者自己定义的传输语法工具进行通信时，你需要测试你的序列化工具是否能够正确转化，即序列化操作本身<strong>是否对List进行遍历</strong>，比如Gson会使用<a target="_blank" rel="noopener" href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java">CollectionTypeAdapterFactory</a>作为List的遍历类，可以看出内部有forLoop的代码，因此在Gson使用惰性求值是安全的。</li></ol><h2>Guava的函数式操作</h2><h3>map</h3><p>映射操作，这个是最常见的，用于将一种列表转为另一种列表，在大多数语言中使用map作为函数名称，但是Guava中使用的却是transform</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; in = Lists.newArrayList(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>);</span><br><span class="line">List&lt;Integer&gt; out = Lists.transform(in, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> input * <span class="number">2</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然我平时更喜欢用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; s = [<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;333Cs&quot;</span>, <span class="string">&quot;11eerS&quot;</span>]</span><br><span class="line">FluentIterable.from(s).transform(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    String <span class="title function_">apply</span><span class="params">(<span class="meta">@Nullable</span> String o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o.toUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>Functions内有很多现成的工厂，可以翻翻找找用，比如<code>Functions.toString()</code></p></blockquote><h3>zip</h3><p>zip操作不支持，这个比较蛋疼，也就是没法用两个List拼装为一个List了</p><h3>unique</h3><p>unique是去重操作(guava remove duplicate)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; s = [<span class="string">&quot;11&quot;</span>,<span class="string">&quot;2222&quot;</span>,<span class="string">&quot;333&quot;</span>,<span class="string">&quot;11&quot;</span>]</span><br><span class="line">ImmutableSet.copyOf(s).asList()</span><br></pre></td></tr></table></figure><p>如果是多个List混在一起再去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; s = [<span class="string">&quot;11&quot;</span>,<span class="string">&quot;2222&quot;</span>,<span class="string">&quot;333&quot;</span>,<span class="string">&quot;11&quot;</span>]</span><br><span class="line">List&lt;String&gt; s2 = [<span class="string">&quot;333&quot;</span>,<span class="string">&quot;2222&quot;</span>,<span class="string">&quot;333&quot;</span>,<span class="string">&quot;14441&quot;</span>]</span><br><span class="line">ImmutableSet.builder().addAll(s).addAll(s2).build().asList()</span><br></pre></td></tr></table></figure><h3>filter</h3><p>过滤操作同样<strong>均是</strong>惰性求值，API与Java8类似，使用此函数可以避免在主业务中编写for;break;contine等代码，以简化代码还原的流程。</p><blockquote><p>注意，此函数调用后的List性能极其差，除了for循环操作，其它size、add等操作都是O(N)时间，因此一定要万分小心</p></blockquote><h4>过滤出符合条件的List</h4><p>并没有<code>Lists.filter</code>的操作，原因如下</p><blockquote><p>The biggest concern here is that too many operations become expensive, linear-time propositions. If you want to filter a list and get a <em>list</em> back, and not just a <code>Collection</code> or an <code>Iterable</code>, you can use <code>ImmutableList.copyOf(Iterables.filter(list, predicate))</code>, which “states up front” what it’s doing and how expensive it is.</p></blockquote><p>所以日常代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collections2.filter(in, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(Integer input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> input&gt;<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterables.filter(in, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(Integer input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> input&gt;<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>它们返回的对象都是一个危险的惰性集合。</p><blockquote><p>Predicates内有很多现成的工厂，可以翻翻找找用，比如<code>Predicates.notNull()</code></p></blockquote><p>当然还有更推荐使用的<code>FluentIterable.filter</code>，我就不重复写了</p><h4>一票否决式过滤</h4><p>要求集合所有元素满足特定条件，有一个条件不满足就一票否决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isAllAdult</span> <span class="operator">=</span> Iterables.all(list, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(Integer input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> input &gt;= <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4>一票通过式过滤</h4><p>有一个条件满足，就返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isExist</span> <span class="operator">=</span> <span class="keyword">return</span> Iterables.any(list, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(Integer input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> input&gt; <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4>找出第一个符合条件的元素</h4><p>从List中找到第一个符合条件的元素T，并返回<code>Optional&lt;T&gt;</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; adult = Iterables.tryFind(in, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(Integer input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> input&gt; <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//找到就返回Integer，没有就返回0</span></span><br><span class="line"><span class="keyword">return</span> adult.or(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>还有另一种带默认值的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">adult</span> <span class="operator">=</span> Iterables.find(in, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(Integer input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> input&gt; <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3>如何安全地生成新拷贝对象</h3><p>刚刚已经说过了，惰性求值过度优化可能导致奇葩结果。为了安全地传递给下家，可能需要将惰性求值转换为新值。</p><p>第一种方法(最推荐)，如果想偷懒的话，直接创建一个一定执行遍历操作的对象，将返回一个不可变的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FluentIterable.from(in)</span><br><span class="line">        .transform(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Integer input)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.toHexString(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).toList();</span><br></pre></td></tr></table></figure><p>或者下面这样的，但是更丑，结果比较保险，是常见的数组List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImmutableList.copyOf(...)</span><br><span class="line">Lists.newArrayList(...)</span><br></pre></td></tr></table></figure><p>对比Java8的惰性求值，还是Java8更简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; o = in.stream().map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, String&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toHexString(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).collect(Collectors.&lt;String&gt;toList());</span><br></pre></td></tr></table></figure><p>目前我已经很少使用Guava，主要是换成了Stream与Groovy，可以参考<a target="_blank" rel="noopener" href="https://miao1007.gitbooks.io/the-way-to-be-a-true-programmer/content/datastruct/streamapiyu-bi-shi-ti.html">这里</a></p><h2>Refference</h2><ol><li><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/8458663/guava-why-is-there-no-lists-filter-function">http://stackoverflow.com/questions/8458663/guava-why-is-there-no-lists-filter-function</a></li><li><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/10834577/guava-iterables-filter-vs-collections2-filter-any-big-difference">http://stackoverflow.com/questions/10834577/guava-iterables-filter-vs-collections2-filter-any-big-difference</a></li><li><a target="_blank" rel="noopener" href="https://github.com/google/guava/issues/505">https://github.com/google/guava/issues/505</a></li><li><a target="_blank" rel="noopener" href="http://www.yinwang.org/blog-cn/2013/04/01/lazy-evaluation">http://www.yinwang.org/blog-cn/2013/04/01/lazy-evaluation</a></li></ol></div><div class="tags"><a class="tag-link" href="/tags/FP/" rel="tag">FP</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry.</a><span> All contents are not allowed to be redistributed or synthesised without an explicit permission.</span></div></footer></div></body></html>