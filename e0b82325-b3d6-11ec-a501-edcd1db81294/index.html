<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="JMX在实际开发中很多人都用过，鼠标点一下就可以执行Java代码。本文适用于已经会在JConsole等工具中调用JMX，但希望进一步了解JMX的人。"><meta name="keyword" content="JMX"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>JMX的一些简要知识点</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://eu.umami.is/script.js" data-website-id="449a84b6-be9e-49de-a4cc-e0fa6fea1df9"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">JMX的一些简要知识点</div><div class="date no-print">2017-06-11 / modified at 2022-04-04 / 1.4k words / 5 mins</div><div class="content"><blockquote><span>️This article has been <strong>over 3 years</strong> since the last update.</span></blockquote><p>JMX在实际开发中很多人都用过，鼠标点一下就可以执行Java代码。本文适用于已经会在JConsole等工具中调用JMX，但希望进一步了解JMX的人。</p><span id="more"></span><h2>什么是JMX，有什么用？</h2><p>JMX是 Java 管理扩展（Java Management Extensions, JSR 160）的缩写，实际上就是一个<strong>基于TCP的远程eval后门</strong>，是sun闭源的实现，在日常开发中，一般用于</p><ul><li>热部署: 比如Log4j(更新Log等级), Script(比如Java内置js实现浅层定制等), Hibernate对象(数据库字段)等。这里可以搞出很多黑科技，提高开发效率</li><li>监控统计: 查看DCS缓存命中率，Zk健康，MQ流控，DDS热点等中间件的状态。</li><li>远程操作: 远程清空缓存，dump数据等，这个一般用得很少。</li></ul><h2>从鼠标点击到Bean被调用的端到端流程分析</h2><p>下面以zkServer为例，Zookeeper提供了很多JMX调试接口，在Jconsole都是可以直接点击的。</p><p>为了方便折腾Zk，我们首先下载zk的源码工程，然后用IDEA导入后，配置如下Debug的参数，然后点击启动即可</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Main</span> <span class="string">class: org.apache.zookeeper.server.quorum.QuorumPeerMain</span></span><br><span class="line"><span class="attr">Program</span> <span class="string">arguments: ./zookeeper-3.4.9/conf/zoo_sample.cfg</span></span><br></pre></td></tr></table></figure><p>接着在<code>ZooKeeperServerBean</code>中的<code>resetStatistics</code>打上断点。然后打开Jconsole，找到此Bean，点击此方法运行。</p><p><img src="http://upload-images.jianshu.io/upload_images/98641-bbc437fec3a7beac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JXM Debug"></p><p>没有意外地话，断点应该被Trigger上了，这里我们就可以通过调用栈进行简要分析了。</p><p>通过对调用栈分析，我们可以发现</p><ul><li>JVM专门开了一个RMI(Java Method Invocation)的线程进行监听，并自己通过TCP搞了一套协议(也就是说可以用WireShark抓包)，通过对TCP的InputStream进行查看，可以发现JMX实现了自己的应用层抽象语法。</li><li>通过一个大for/switch实现了路由匹配，并通过一个Map找到Method进行invoke调用:<code>javax.management.remote.rmi.RMIConnection.invoke()</code></li><li>最终路由到实际Bean，并执行Java代码。</li></ul><p>可以看出，JMX主要是在做传输协议，更像是在做【通信】，这部分具体分析工作量非常大，本文就不分析了。</p><h2>如何开发自己第一个JMX？</h2><p>我个人不太喜欢从零开始创建一个工程，而是喜欢先定制，再移植出公共模块(详见我之前写的团队技能培训相关Tag)。同样以Zookeeper为例，我们可以按照如下方法进行折腾：</p><ul><li>写一个扩展ZooKeeperServerBean的class，并注册到zk上</li><li>尝试添加属性与方法到刚刚写的class上</li><li>删除extend的类，尝试自己实现MBean接口造轮子</li></ul><p>这样步骤有一个好处就是，你最开始学JMX就接触到的是行业水平最高的实践，比如<code>MBeanRegistry</code>的单例化，<code>ObjectName</code>的生成方法，JConsole对应Class的直观映射，都是很好的封装。</p><p>经过折腾，例子如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口必须是 MXBean 的后缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CalcMXBean</span> &#123;</span><br><span class="line">    Integer <span class="title function_">eval</span><span class="params">(String script)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalcBean</span> <span class="keyword">implements</span> <span class="title class_">CalcMXBean</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CalcBean</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">eval</span><span class="params">(String script)</span> &#123;</span><br><span class="line">      	<span class="comment">// 此处仅供演示使用，有安全风险与性能问题</span></span><br><span class="line">        <span class="type">ScriptEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptEngineManager</span>().getEngineByName(<span class="string">&quot;javascript&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">eval</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eval = ((Integer) engine.eval(script));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            eval = <span class="number">0</span>;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再进行注册就搞定了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下代码放到 org.apache.zookeeper.server.ZooKeeperServer#registerJMX</span></span><br><span class="line"><span class="comment">//jmx在客户端就是通过objectName进行method调用的</span></span><br><span class="line"><span class="type">ObjectName</span> <span class="variable">objName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectName</span>(<span class="string">&quot;com.test.calctest:name=calcBean&quot;</span>)</span><br><span class="line">ManagementFactory.getPlatformMBeanServer().registerMBean(calcBean,objName);</span><br></pre></td></tr></table></figure><p>这样我们就成功地设计了一个简陋的JMX计算器，由于它可以eval任何js脚本，因此再加一些黑科技就相当于是一个后门了(生产环境绝不能这样搞)。</p><h2>总结</h2><p>JMX并不是什么非常专业高深的技术，因为它在各种框架中早被高度封装，它主要代码量体现在闭源的【通信】代码上。因此作为开发，只需要合理地暴露接口即可</p><ul><li>只要写一个 <code>/.*MXBean/</code>的接口与其实现类，并配置好ObjectName，就可以注册到JMX中，然后通过JConsole或者<code>MBeanServerConnection</code>进行invoke</li><li>JMX与REST服务类似，只是一个桩，代码实现应该是调用Spring或者微服务，而不是全部写到MXBean中</li><li>本文没有讲get/set属性，这个可以下来试一下，本文实验入门成功后就可以直接看<a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/tech/best-practices-jsp-136021.html">文档</a>了</li></ul><h2>开发JMX业务需要注意什么？</h2><p>JMX提供了直接调用Java代码的能力，因此非常方便开发定位，同时也有极大的安全风险</p><ul><li>业务要满足<strong>安全</strong>要求: 比如不能接收String去eval，不能跳过鉴权去操作业务，最好<strong>不要返回任何业务信息</strong>，而只返回一个统计。这类代码可以私下调试用，但是不能上代码库，更不能说去配置一个开关在生产环境上屏蔽后门。也就是说，最终发布的<strong>二进制不能有</strong>任何有安全风险的JMX调用。</li><li>在Product环境中要关闭JMX: 这个一般在setEnv.sh等类似文件中均可以配置，如果开发有调试需求，可以配置鉴权的Key，并<strong>只监听</strong>Localhost，避免在公网暴露。</li><li>当前的TCP实现是sun的闭源实现，如果对安全性要求极高的企业级应用，需要自己实现定制私有协议的JMX(jmx.default.class.loader)。</li></ul></div><div class="tags"><a class="tag-link" href="/tags/JMX/" rel="tag">JMX</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry.</a><span> All contents are not allowed to be redistributed or synthesised without an explicit permission.</span></div></footer></div></body></html>