<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="本文将分析第一代AngularJS的主流程，结合笔者最近改造与培训的实践，将快速帮助Java后端开发掌握原理，写出前端界面，早点下班回家。"><meta name="keyword" content="AngularJS,DSL"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>AngularJS双向绑定的实现</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">AngularJS双向绑定的实现</div><div class="date">2017-12-10 / modified at 2022-04-04</div><div class="content"><blockquote><span>️This article has been <strong>over 1 years</strong> since the last update.</span></blockquote><p>本文将分析第一代AngularJS的主流程，结合笔者最近改造与培训的实践，将快速帮助<strong>Java后端</strong>开发掌握原理，写出前端界面，早点下班回家。</p><span id="more"></span><blockquote><p>本文写作之时，AngularJS已经快有10年了，并进入了LTS阶段，但是AngularJS的生态圈使它依然适用于老旧项目渐进改造以及逻辑复杂的企业级项目开发。如果你希望开发对SEO友好，更加“新”的框架的话，可以尝试Vue，React等。</p></blockquote><h4>本文需要的知识基础</h4><p>在阅读本文前，你需要了解</p><ul><li>AngularJS的基本用法，比如<code>ng-click</code>, <code>filter</code>等</li><li>Angular内部采用了函数式与依赖注入，返回的基本上都是<strong>柯里(Curry)化</strong>后的函数，也就是很多匿名闭包，你一定要明白断点执行的不一定是从上到下的，因此需要掌握一定的调试技巧。</li><li>JS全部为引用传递，除了<code>copy</code>或者<code>extend</code>外，直接使用<code>=</code>赋值可能会出现多绑一的问题</li><li>浏览器的js解释器是单线程(DOMThread)，但是浏览器内部的Socket/Timer是native实现，比如WebKit可以实现WorkerGroup多线程加载</li><li>有Android的ListView开发经验的读者懂得更快</li></ul><p>为了简化板面与照顾使用JQuery的读者，本文预制如下函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">$</span>(<span class="params">dom</span>)&#123;<span class="comment">//本文不借助JQuery，但是代码因此会长一些</span></span><br><span class="line">    <span class="keyword">return</span> angular.<span class="title function_">element</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(dom));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSrv</span>(<span class="params">name, element</span>) &#123;<span class="comment">//获取被依赖注入的服务</span></span><br><span class="line">    element = element || <span class="string">&#x27;*[ng-app]&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> $(element).<span class="title function_">injector</span>().<span class="title function_">get</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>本文需要的工具</h4><ul><li>任意一个加载AngularJS的Chrome网页，比如<a target="_blank" rel="noopener" href="https://docs.angularjs.org/api/ng/directive/ngModel">这里</a>的<code>Binding to a getter/setter</code>例子</li></ul><h2>1. 流程综述</h2><p>Angular本质是通过DSL解释器(详见垠神的<a target="_blank" rel="noopener" href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter">怎样写一个解释器</a>)来扩展html语义的框架。如果你看过类似的文章，你将更好的理解AngularJS中的Scope(作用域)。</p><p>它的主要流程概要如下</p><ol><li>读取<code>$dom</code>中的attr修饰的DSL(<code>directive</code>或<code>&#123;&#125;</code>)生成AST，并编译生成基于javaScript的<code>字节码</code>函数</li><li>绑定<code>$dom</code>对应的上下文，执行刚刚生成的link函数，产生新的数据</li><li>(通过手动apply或者各种Listener)将刚刚的数据更新到界面</li></ol><h4>1.1. 启动分析</h4><p>在引入的angular.js末端将自动通过<code>jqLite</code>配置onLoad监听器进行启动</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">jqLite</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">//当`document.complete`事件触发`angularInit`</span></span><br><span class="line">  <span class="title function_">angularInit</span>(<span class="variable language_">window</span>.<span class="property">document</span>, bootstrap);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此部分类似于WebView中的<code>onPageFinished</code>接口，保证函数在进行DOM操作前已经下载完成，以免后续编译DOM出现多线程异常。</p><p>被自动触发的<code>angularInit</code>其实是一个<code>[ng-app]</code>的Select扫描，即<code>$('[ng-app]')</code></p><p>扫描后将调用的是如下的apply操作，为了方便最简流程理解，我屏蔽了依赖注入，并改为注入后的变量名称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$rootScope.$apply(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">//3. 执行Digest，调用watcher的回掉</span></span><br><span class="line">  <span class="keyword">var</span> element = $(<span class="string">&#x27;[ng-app]&#x27;</span>)</span><br><span class="line">  element.<span class="title function_">data</span>(<span class="string">&#x27;$injector&#x27;</span>, injector);</span><br><span class="line">  <span class="comment">//1. 解析DSL，生成基于js的“字节码”</span></span><br><span class="line">  <span class="comment">//注意$compile(element)返回的是一个Func，而不是一个Obj，这里返回的func是同一个Function</span></span><br><span class="line">  <span class="comment">//如果你用publicLinkFn.toString()进行Diff对比可以发现，返回的是一样的</span></span><br><span class="line">  <span class="keyword">var</span> publicLinkFn = $compile(element);</span><br><span class="line">  <span class="comment">//2. 执行link函数，更新数据(但是还没有更新界面)</span></span><br><span class="line">  <span class="keyword">var</span> linkedDom = <span class="title function_">publicLinkFn</span>($rootScope);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4>1.2. Apply的含义</h4><p>Apply指<code>生成数据</code>并<code>更新界面</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">$apply</span>(<span class="params">expr</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;<span class="comment">//执行上文写的匿名函数，即1，2</span></span><br><span class="line">    <span class="keyword">return</span> $eval(expr);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    $exceptionHandler(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;<span class="comment">//3. 更新数据到界面，类似于Android中ListView的*notifyDataSetChanged*接口</span></span><br><span class="line">    $root.$digest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数中的1，2，3依次对应概要中的1，2，3。如果你想自己分析源码，按照上面思路即可。当然本文也将带你接着分析。</p><h2>2. 实现细节</h2><h3>2.1. 编译DSL(compile)</h3><p>compileNodes是一个树的遍历操作，编译DOM内部涉及到如下操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JQueryDOM -&gt; Attrs -&gt; Lexer -&gt; Parser -&gt; linkFn</span><br></pre></td></tr></table></figure><p>这部分主要是用于读取Directive与DSL表达式，并生成模式匹配后的函数。</p><p>通过阅读源码，可以发现在<code>collectDirectives</code>中将提取所有的attr，含括号表达式与自定义tag，具体断点位置位于collectDirectives</p><h3>2.2. 执行DSL(eval)</h3><h4><code>$Parser</code>与<code>$eval</code></h4><p>作为入门Angular文章，本文不分析内部的Token与AST。先去了解大致流程，再分析编译细节是更好的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parserFn = <span class="title function_">getSrv</span>(<span class="string">&#x27;$parse&#x27;</span>);<span class="comment">//在console中获取parser</span></span><br></pre></td></tr></table></figure><p>接下来我们就可以在console中直接调用了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">parserFn</span>(<span class="string">&quot;1+1*2-(4*5)&quot;</span>)</span><br><span class="line"><span class="comment">//-&gt;ƒ(s,l,a,i)&#123;return ifDefined(plus(1,(1)*(2)),0)-ifDefined((4)*(5),0);&#125;</span></span><br><span class="line"><span class="title function_">parserFn</span>(<span class="string">&quot;&#123;age:18,name:&#x27;haruhi&#x27;&#125;&quot;</span>)</span><br><span class="line"><span class="comment">//-&gt;ƒ(s,l,a,i)&#123;return &#123;&#x27;age&#x27;:18,&#x27;name&#x27;:&#x27;haruhi&#x27;&#125;;&#125;</span></span><br></pre></td></tr></table></figure><p>举个更难的例子，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">parserFn</span>(<span class="string">&quot;&#123;age:18,name:&#x27;haruhi&#x27;&#125;|json&quot;</span>)</span><br></pre></td></tr></table></figure><p>其实返回的是过滤器调用，也就是说管道操作符<code>|</code>语法通过Parser解释为了一个filter</p><p>当Parser操作完成后，就可以执行<code>$eval</code>了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前Scope</span></span><br><span class="line"><span class="keyword">var</span> scope = <span class="title function_">getSrv</span>(<span class="string">&#x27;$rootScope&#x27;</span>)</span><br><span class="line"><span class="comment">//Scope本身除了作为MV*的中间层，同时也是解释器的上下文</span></span><br><span class="line">scope.<span class="property">a</span> = &#123;<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">name</span>:<span class="string">&#x27;haruhi&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// -&gt; &#123;age: 18, name: &quot;haruhi&quot;&#125;</span></span><br><span class="line">scope.$eval(<span class="string">&#x27;a.name&#x27;</span>)</span><br><span class="line"><span class="comment">// -&gt; &quot;haruhi&quot;</span></span><br></pre></td></tr></table></figure><p>总的来说，就是实现了一个DSL解释器，这里的<code>scope.$eval</code>操作在后期Direactive中使用非常广泛</p><blockquote><p>我在之前的DSL文章中写过: 相同信息量下，DSL的长度越短，潜规则信息就越多，因此也就有一个陡峭的学习曲线，调试成本越高。在上面的例子中也可以发现，通过分析生成后的函数可以掌握<code>filter</code>等执行细节，这就是从<strong>只会用开源组件语义</strong>到<strong>定制自己组件</strong>的瓶颈区。</p></blockquote><p>对这部分比较纠结的读者，可以在<code>addInterceptor</code>中打上断点，跑完一个简单的断点后，AngularJS的基本流程也就大致清楚了。</p><h4>2.2.1. Scope分析</h4><p>Scope在解释器中被称为作用域或者环境，在AngularJS中特指<code>lexical scoping</code>，也就是离函数越近定义的变量优先级越高，此部分通过js的prototype链实现。</p><p>它在最底层通过<code>$.data(element,&quot;$scope&quot;)</code>这样的Map结构实现DIV与作用域映射的，关于<code>JQLite.data</code>的具体实现，类似于下文的一个全局Map，具体网上有很多分析文章</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache[$(div)[<span class="string">&#x27;jQuery112408303826831449197&#x27;</span>]]</span><br></pre></td></tr></table></figure><p>作用域也是一个对于前端比较难的技术点，很多时候碰到“无法点击”就不知道如何调试了。当然如果你自己不想手动折腾的话，可以尝试安装Chrome扩展，有很多工具F12可以自动计算出DOM绑定的Scope。</p><h3>2.3. 更新界面(Digest)</h3><p>以上文在线Plnkr例子为例</p><p>方法一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = $(<span class="string">&#x27;[ng-controller=&quot;ExampleController&quot;]&#x27;</span>).<span class="title function_">scope</span>();</span><br><span class="line">scope.$apply(<span class="string">&#x27;user.name(&quot;1926~∞ Excited&quot;)&#x27;</span>)</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scope.$eval(<span class="string">&#x27;user.name(&quot;1926~∞&quot;)&#x27;</span>)</span><br><span class="line"><span class="comment">//=&gt;&quot;1926~∞&quot;</span></span><br><span class="line">scope.$digest()<span class="comment">//执行后，界面自动完成刷新</span></span><br></pre></td></tr></table></figure><p>这两种其实是一样的，只不过</p><ul><li><code>$apply</code>在内部通过封装<code>try/finally</code>把<code>$digest</code>放到了最后。</li><li><code>$apply</code>更新的作用域是<code>$rootScope</code>，是深度遍历</li></ul><p>在AngularJS中，<code>$digest</code>是重要的更新UI函数，我们对它进行分析(本部分不分析url变化场景)</p><blockquote><p>Digest有点类似Android中Handler队列放入Runnable，但是它并不是你想象的有一个PIPE队列在后台轮询，只有手动调用或者监听(比如按键/鼠标)才会触发Digest</p></blockquote><p>细节如下</p><ul><li>对<code>asyncQueue</code>进行forEach反射调用fn，它对应的是<code>evalAsync</code>，这里主要是实现了Promise</li><li>对<code>$$watchers</code>进行遍历调用<code>watch.fn</code>更新(最常见的是<code>expressionInputWatch</code>)，如果last与最新值不相等，将更新为新的值，此处为线型复杂度。</li></ul><h4>Promise的实现</h4><p>在AngularJS中，我们有<code>$q</code>来实现链式异步编程，但是如果你打断点分析时发现，比如在<code>$http</code>中</p><ul><li>数据并不是马上返回，而是将信息发送到了<code>asyncQueue</code>队列中</li><li>等到网络响应数据后，通过resolve操作变更状态为Completed</li><li>通过各种渠道触发Digest后，通过<code>setTimeout</code>实现调用成功的Callback函数链</li></ul><p>在AngularJS的Promise有些不足，<code>$Q</code>是不支持Java中CountDownLatch那样await等待的，同时比较依赖Digest触发事件，如果你在Callback中执行耗时任务，那么可能性能就比较差了</p><h2>3. 实例分析</h2><h3>3.1. 括号Watcher例子</h3><p>比如我在业务中写了如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它在js内部执行如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DSL</span></span><br><span class="line">	|collectDirectives</span><br><span class="line"><span class="title class_">Direactive</span></span><br><span class="line">	|compileNodes</span><br><span class="line">textInterpolateCompileFn</span><br><span class="line">	|scope.<span class="title function_">publicLinkFn</span>()</span><br><span class="line">textInterpolateLinkFn</span><br><span class="line">	|<span class="title function_">watch</span>()</span><br><span class="line">interpolateFn</span><br><span class="line">	|digest</span><br><span class="line">更新nodeValue值</span><br></pre></td></tr></table></figure><p>这里的流程均为异步，比较难以分析，主要原因是为了分拆生命周期做了过多的柯里化，导致断点到处飘(不过我见过更烂的RxJava)。</p><h4>3.1.1. Compile</h4><p>在执行compile阶段，主要有两个事件: 先<code>collectDirectives</code>执行收集，接着遍历Node执行<code>compileNodes</code></p><ul><li>收集阶段(collectDirectives)</li></ul><p>首先在<code>addTextInterpolateDirective</code>中打上断点，在解析括号并生成<code>interpolateFn</code>后，可以发现在编译阶段返回了一个Direactive</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">priority</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">compile</span>: <span class="keyword">function</span> <span class="title function_">textInterpolateCompileFn</span>(<span class="params">templateNode</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">textInterpolateLinkFn</span>(<span class="params">scope, node</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            scope.$watch(interpolateFn, <span class="keyword">function</span> <span class="title function_">interpolateFnWatchAction</span>(<span class="params">value</span>) &#123;</span><br><span class="line">                node[<span class="number">0</span>].<span class="property">nodeValue</span> = value;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译Node阶段(compileNodes)</li></ul><p>执行Direactive的compile，并返回了<code>textInterpolateLinkFn</code>函数，注意这里是函数还没有执行</p><h4>3.1.2. Link</h4><p>在执行link阶段，<code>textInterpolateLinkFn</code>将被调用，并注册一个watcher，注意这里的watcher又是个套路，它这里使用了Delegate模式，实际上文的<code>$watch</code>代码可以简写为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scope.$watch(<span class="keyword">function</span> <span class="title function_">expressionInputWatch</span>(<span class="params">scope</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行parser生成的函数，等价于eval(&#x27;name&#x27;)</span></span><br><span class="line">    <span class="keyword">var</span> newInputValue = <span class="title function_">inputExpressions</span>(scope);</span><br><span class="line">    <span class="comment">// 类似于Java的equals</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">expressionInputDirtyCheck</span>(newInputValue, oldInputValueOf, inputExpressions.<span class="property">isPure</span>)) 	&#123;</span><br><span class="line">        lastResult = <span class="title function_">parsedExpression</span>(scope, <span class="literal">undefined</span>, <span class="literal">undefined</span>, [newInputValue]);</span><br><span class="line">        oldInputValueOf = newInputValue &amp;&amp; <span class="title function_">getValueOf</span>(newInputValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastResult;</span><br><span class="line">&#125;, <span class="keyword">function</span> <span class="title function_">interpolateFnWatchAction</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  	<span class="comment">//此处可以打上断点，如果你不懂Digest</span></span><br><span class="line">    node[<span class="number">0</span>].<span class="property">nodeValue</span> = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4>3.1.3. Digest</h4><p>在digest阶段，wacher的<code>expressionInputWatchd</code>对比将被调用，并执行<code>eval('name')</code>，然后调用 watcher.fn，执行<code>interpolateFnWatchAction</code>最终更新<code>nodeValue</code></p><p>通过上面的流程，从括号到更新界面的流程就完成了，不清楚的话，搜索函数名，打上断点。</p><h3>3.2. ngBind例子</h3><p>比如我在业务中写了一段代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">ng-bind</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在遍历DOM编译阶段(compileNodes)，调用ngBindDirective中的<code>ngBindCompile</code>，返回了一个<code>ngBindLink</code>的函数</p><p>在执行link阶段，调用<code>ngBindLink</code>函数，新增了如下的watcher到<code>$$watcher</code>队列中，相对于上面的括号，套路少了很多</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scope.$watch(<span class="string">&#x27;name&#x27;</span>, <span class="keyword">function</span> <span class="title function_">ngBindWatchAction</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  element.<span class="property">textContent</span> = <span class="title function_">stringify</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 上文实际上是添加了如下的watcher</span></span><br><span class="line">watcher = &#123;</span><br><span class="line">  <span class="comment">//为element.textContent = stringify(value);位于ngBind中，用于更新DOM</span></span><br><span class="line">  <span class="attr">fn</span>: listener,</span><br><span class="line">  <span class="attr">last</span>: initWatchVal, <span class="comment">//空函数func()&#123;&#125;</span></span><br><span class="line">  <span class="attr">get</span>: get, <span class="comment">//编译&#x27;name&#x27;后的函数</span></span><br><span class="line">  <span class="attr">exp</span>: prettyPrintExpression || watchExp, <span class="comment">//&#x27;name&#x27;</span></span><br><span class="line">  <span class="attr">eq</span>: !!objectEquality <span class="comment">//空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点开<code>get</code>生成的函数机智的打上断点，然后接着跑代码，反查发现在Digest中通过<code>watcher.fn</code>调用来更新DOM</p><h2>4. 历史遗留项目改造</h2><p>在使用AngularJS前，笔者<s>被忽悠进来才发现</s>面对的是一个大坑项目，发现项目中遇到如下问题</p><ul><li>页面全部采用<code>$Dom</code>进行操作，代码很难看，效率低</li><li>缺乏公共组件</li><li>手动js拼装XML</li></ul><p>这些都可以用AngularJS来搞定，具体改造如下</p><h4>4.1. Angular重新编译</h4><p>某些遗留界面(比如Modal/Table)采用Ajax动态加载模版引擎(比如JSP)生成的HTML，这时由于加载后的并不在Angular的MQ中，需要重新编译。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">recompile</span>(<span class="params">element, response</span>) &#123;</span><br><span class="line">  element.<span class="title function_">html</span>(response);</span><br><span class="line">  <span class="comment">// shared scope with parent</span></span><br><span class="line">  <span class="keyword">var</span> inj = angular.<span class="title function_">element</span>(<span class="string">&#x27;[ng-app=&quot;myApp&quot;]&#x27;</span>).<span class="title function_">injector</span>();</span><br><span class="line">  inj.<span class="title function_">invoke</span>([<span class="string">&#x27;$compile&#x27;</span>, <span class="keyword">function</span>(<span class="params">$compile</span>) &#123;</span><br><span class="line">    <span class="comment">//new code for angularJS integrate</span></span><br><span class="line">    <span class="keyword">var</span> s = element.<span class="title function_">scope</span>();</span><br><span class="line">    s.$apply(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> linkFn = $compile(response);</span><br><span class="line">      <span class="title function_">linkFn</span>(s);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一定要先调用<code>element.html</code>，否则旧的onclick事件将被多次绑定。当然这里<strong>依然有遗留问题</strong>，它之前绑定的scope等data将会永远泄漏，event将会被重复listen，不过好在项目中基本上非单页应用，这点内存损失相对于开发效率提升就可以忽略了。</p><h4>4.2. JSON序列化</h4><p>由于Angular为了性能(比如track by)给对象自动加人了<code>$Hash</code>等乱七八糟的东西，这样在进行SpringMVC后台请求时可能报错400。此时你需要使用<code>angular.toJson</code>来代替native的json实现</p><h4>4.3. Injection</h4><p>依赖注入需要占用较多的篇幅，本文暂不研究，最重要的是通过<code>func.toString</code>native代码反射获取函数参数，然后依据正则表达式从map中调用<code>$get</code>取到的。</p><h4>4.4. 封装DOM组件</h4><p>在以往开发中，一般通过<code>$.fn.XX.init</code>来启动JQuery的插件，而且可能源码也被修改过，因此与其在网上找一个开源包不如自己用Angular再封装一道</p><ul><li>对于长度/宽带等监听 -&gt; 使用watch+callback代替直接判断</li><li>对于UI组件(比如zTree, Validator) -&gt; 在 <code>compile</code>中拼装模版，返回的link函数中拼装初始化函数</li></ul><h2>5. 总结</h2><p>AngularJS上手难度有点高，属于<strong>开始爬坡快，但是马上遇到瓶颈的类型</strong>。对于后端开发人员，虽然AngularJS相对于React，Vue等最新js技术是老大哥了，最后再总结一下优点吧</p><ul><li>通过DSL扩展语法实现客户端模版引擎，对使用JSP的人群迁移习惯友好，后期甚至可以定制解释器的语法</li><li>生态完善，如同JQuery一样，所有报错都可以搜索到，所有组件都可以Copy与Paste</li><li>经过培训与维护Best Practice，可以复用改造已有的JQueryUI/DatePicker等基于DOM的组件</li><li>AngularJS基本上是最难的前端框架了（对后端反而简单），掌握后再学剩下的Vue与React也更有信心。</li></ul><h2>参考</h2><ul><li><a target="_blank" rel="noopener" href="http://imweb.io/topic/55c05482193684376cd08b53">http://imweb.io/topic/55c05482193684376cd08b53</a></li></ul></div><div class="tags"><a class="tag-link" href="/tags/AngularJS/" rel="tag">AngularJS</a><a class="tag-link" href="/tags/DSL/" rel="tag">DSL</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>