<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="话说菊花厂真的对开源不是很上心，很多时候都仅仅是受限于GPL而开源。不过今天介绍的项目不同，此项目由2012架构部专家亲自编写，并已经在内部商用，质量很好，值得一读。"><meta name="keyword" content="CodeReview,MicroService"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>华为微服务框架ServiceComb的简要介绍</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body class="container"><header id="header"><div class="header"><div class="header-left"><div class="author"><div class="author-name"><a href="/">諺</a></div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">Archives</a></li><li style="font-size:.9rem"><a href="/archives" rel="nofollow">zh</a></li><li style="font-size:.9rem"><a href="#" rel="nofollow">|</a></li><li style="font-size:.9rem"><a href="/en" rel="nofollow">en</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">Epistemology</a></li><li><a href="/books" rel="nofollow">読書</a></li></ul></div></div></header><div class="content-wrapper"><div class="post"><section class="article"><div class="title">华为微服务框架ServiceComb的简要介绍</div><div class="date">2017-07-15に投稿</div><div class="content"><p>话说菊花厂真的对开源不是很上心，很多时候都仅仅是受限于GPL而开源。不过今天介绍的项目不同，此项目由2012架构部专家亲自编写，并已经在内部商用，质量很好，值得一读。</p><span id="more"></span><blockquote><p>更新: 到2018年10月，ServiceComb正式升级为Apache项目</p></blockquote><p>目前我所接触的微服务框架</p><ul><li>阿里的Dubbo: 基于SpringScheme+zk实现，是比较重的框架（一堆XML配置），是国内中小企业事实上的SOA标准，阿里内部新版未开源。自己没环境折腾，只大致看了下源码。Dubbo的问题主要是说停更就停更，以后难以下船。</li><li>HW的BDF框架: 原理基本同上，内部使用，闭源项目不展开介绍。我个人认为这个更加先进一些，因为它还支持FAAS函数调用，甚至支持掉电ThreadLocal调用。</li><li>HW的ServiceComb框架: HWCloud在2017年6月发布开源的一款微服务框架），基于Go/YAML进行配置，部署特别快，源码量也小，可以轻松地在一台机子上分析与断点。缺点是过新了，外界缺少考验。</li><li>SpringCloud: 基于Netflix全家桶的框架(我正在写<a href="https://miao1007.github.io/gitbook/eureka/">系列文章</a>)，优点是比较适合中小型团队，以后方便招聘。缺点是老项目不好更新，只有命名服务，没有RPC与鉴权实现。</li></ul><p>今天主要来介绍一下HW分布式框架的ServiceComb的注册发布实现，文章还是老套路(编译、Log与断点)</p><ul><li>分享一下当前微服务的一些热点信息</li><li>对ServiceComb搭建演示进行简要介绍</li><li>对生产者与消费者的调用流程进行源码分析(编译、Log与断点)</li></ul><p>关键词: <code>SOA</code>, <code>MicroService</code>, <code>ServiceDiscovery</code>, <code>NamingService</code>, <code>Golang</code></p><h2>1. 为什么要微服务化？</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99">微服务</a>看起来似乎还是很先进，很学术的概念，实际上在当前已经有<a target="_blank" rel="noopener" href="https://www.nginx.com/resources/library/app-dev-survey/">70%</a>的组织使用了微服务。它将单体应用分解为多个，并分别部署到独立的容器上，通过RPC(比如MQ、HTTP或者私有TCP实现)开放接口。这样做有如下作用</p><ul><li>降低开发耦合度，减小部门墙: 所有业务通信全部通过文档/DSL进行规范，白纸黑字大家都认可，接口还可抓包定位谁的责任。</li><li>小组内定制能力加强: 通过将单体分解为小组件，小组内部可以自己选择工具、语言、DevOps实践，提高自由度。</li><li>改造已有的系统，通过微服务将所有子业务进行整合。</li></ul><p>当然，微服务也有一些坑</p><ul><li>架构依赖专家单点水平: 如果搞出一个全局的、互相依赖的服务，那么整个架构就是一团麻绳(特别是公共模块，万一设计不完善，后期要加倍还)。</li><li>定位部署较复杂: 由于业务横向部署到集群组网中，生产环境的日志，断点，错误信息很难找出来。</li></ul><p>我个人的观点还是和以前文章一样：随着PAAS等全面云化的发展，后端的技术方向要么是精通各种基础中间件架构，要么能解决领域问题(CRM, ERP, NPI等，它们业务学习曲线高，需要年限)，否则后期统统34岁会被干掉。</p><blockquote><p>微服务还可以引申出更多的知识，可以参考两本书《SpringBoot揭秘》与《大型网站技术架构》</p></blockquote><h4>本文需要准备的工具</h4><ul><li>Intellij: 用于分析断点ServiceComb的Java侧代码</li><li>Gogland: 用于分析断点ServiceComb的Go语言写的注册发现服务</li><li>WireShark: 用于抓取注册发现时在本地环境(localhost)间的HTTP报文</li><li><a target="_blank" rel="noopener" href="https://www.getpostman.com/">POSTMAN</a>: 用于测试与MockRESTful接口</li><li>ServiceComb的Java/Go源码: 用于分析代码</li><li>etcd: 用Go语言写的zk，在本文作为数据库，默认端口是2379与2380</li></ul><h2>2. ServiceComb框架简析</h2><p><a target="_blank" rel="noopener" href="http://servicecomb.io/">ServiceComb</a>是HW云使用Go/Java语言开发的一款开源的PAAS中间件，作者在SyBase、TW等公司都是资深专家，后来被HW给挖过去了，具体介绍胶片可以看<a target="_blank" rel="noopener" href="http://servicecomb.io/slides/">这里</a>。大致看了一下<a target="_blank" rel="noopener" href="https://github.com/ServiceComb/service-center">源码</a>，虽然目前Star不多，但是代码质量还是可以的，推荐学习。</p><h3>2.1. 打通主流程</h3><p>具体详见<a target="_blank" rel="noopener" href="http://servicecomb.io/docs/quick-start-guide/">这里</a> ，如果你不想折腾Go编译的话，可以下载Windows现成的包，然后配置虚拟机端口</p><blockquote><p>在分析Java代码时，建议开启Java EE: bean Validation Support插件</p></blockquote><p>配置etcd</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认etcd启动命令</span></span><br><span class="line">etcd --name my-etcd-1 --data-dir ./etcd-data --listen-client-urls http://127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --listen-peer-urls http://127.0.0.1:2380 --initial-advertise-peer-urls http://127.0.0.1:2380</span><br></pre></td></tr></table></figure><p>配置注册中心</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ServiceComb/service-center.git <span class="variable">$GOPATH</span>/src/github.com/servicecomb/service-center</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/servicecomb/service-center</span><br><span class="line">go get github.com/FiloSottile/gvt</span><br><span class="line"><span class="comment"># 此处不需要重复调用，也不要Ctrl-C，一次下载后就不用折腾了</span></span><br><span class="line">gvt restore</span><br><span class="line">go build -o service-center</span><br><span class="line"><span class="comment"># 测试执行，注意</span></span><br><span class="line"><span class="comment"># httpaddr,httpport为本地监听端口(默认127.0.0.1:9980)</span></span><br><span class="line"><span class="comment"># manager_cluster 为 etcd 缓存地址(listen-client-urls,默认127.0.0.1:2379)</span></span><br><span class="line">cp -r ./etc/conf .</span><br><span class="line">./service-center</span><br></pre></td></tr></table></figure><p>使用IDEA导入项目后，分别运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io/servicecomb/demo/pojo/server/PojoServer.java</span><br><span class="line">io/servicecomb/demo/pojo/client/PojoClient.java</span><br></pre></td></tr></table></figure><p>不出意外的话，现在已经端到端成功拉通了服务，那么就可以通过日志，断点进行进一步分析了。</p><h3>2.2. 消费者侧的动态代理</h3><p>我们从消费者侧开始分析，发现调用的是注解过的接口，老套路了，和Retrofit框架差不多。</p><p>有关动态代理，以前文章已经讲过了，动态代理的本质就是通过DSL生成InvocationHandler的一个Parser。</p><p>通过打断点得知，在启动时</p><ul><li>在Spring的AbstractAutowireCapableBeanFactory中，调用了CseBeanPostProcessor的postProcessBeforeInitialization方法</li><li>扫描了所有class，并过滤出有<code>@RpcReference</code>注解的Field</li><li>通过<code>@RpcReference</code>注解构造Invoker对象，内部实现了基于Socket/HTTP的RPC调用</li><li>通过<code>Proxy.newProxyInstance(consumerIntf.getClassLoader(), [consumerIntf], invoker)</code>实例化接口</li></ul><blockquote><p>上述过程与SpringCloud的Feign基本思路也是一样的</p></blockquote><p>在被调用时</p><ul><li>调用<code>Invoker</code>的<code>invoke</code>方法，并路由到Invocation并进行链式调用</li></ul><p>分析就写这么多吧，涉及到Spring扫描Class，元数据(注解)解析，动态代理等技术，说白了就是一个注解的Parser，基本上是在干累活。</p><blockquote><p>yaml文件是通过Swagger描述的微服务DSL，它将在启动时被反序列化为<code>Microservice</code>对象</p></blockquote><h3>2.3. Invoker链式调用</h3><p>此处架构是本框架的精华，使用了Reactor设计，如果你没有定制过RxJava/Akka/Stream的操作符，或者没有【闭包也可以作为参数】前提的话，这部分代码是有一定分析难度的。</p><p>本部分代码如此少，以至于我可以把它贴出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个定制了 CountDownLatch 的 Executor</span></span><br><span class="line"><span class="comment">// 当计数为0时，主线程才由park变为run</span></span><br><span class="line">SyncResponseExecutor respExecutor = <span class="keyword">new</span> SyncResponseExecutor();</span><br><span class="line">invocation.setResponseExecutor(respExecutor);</span><br><span class="line"><span class="comment">// 调用栈 next-&gt;handle-&gt;next-&gt;handle...</span></span><br><span class="line">invocation.next(resp -&gt; &#123;</span><br><span class="line">  respExecutor.setResponse(resp);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 占位符: 当CountDownLatch计数为0时</span></span><br><span class="line"><span class="comment">// 主线程开始执行Runnable(来自TransportClient)</span></span><br><span class="line"><span class="keyword">return</span> respExecutor.waitResponse();</span><br></pre></td></tr></table></figure><p>其中在第一步，初始化调用getHandlerChain构造完成了<code>List&lt;HandlerChain&gt;</code>，一共有4个</p><ul><li>ShutdownHookHandler</li><li>ConsumerBizkeeperHandler</li><li>LoadbalanceHandler</li><li>TransportClientHandler</li></ul><p>我们首先在它们的handle方法中打上断点，并在handle的next的λ表达式中也加入断点，并时刻注意线程是否变化。如果你不习惯λ表达式的话，可以通过IDE把它换成匿名Class</p><blockquote><p>Java的Closure是通过接口模拟出来的，λ表达式简写特性我也非常不推荐，因为对于新接触代码的人来说就是噩梦，举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">invocation.next(resp -&gt; &#123;</span><br><span class="line">  	<span class="comment">// 此处丢失了重要的信息，handle方法名没了</span></span><br><span class="line">  	respExecutor.setResponse(resp);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把它还原，它其实是一个拥有handle方法的匿名Class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invocation.next(<span class="keyword">new</span> AsyncResponse() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Response resp)</span> </span>&#123;</span><br><span class="line">        respExecutor.setResponse(resp);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过重新改写为匿名Class，在后面调用rsp.handle(xx)时就不会一脸懵逼为何断点来回跳转了，此处代码风格比较类似Groovy中Closure.apply()方法，但是还是要强调Java的闭包<strong>只是</strong>模拟出来的</p></blockquote><h4>主线程请求调用链</h4><p>这部分只要跟着断点走，next, handle,next,handle,next,handle,next,handle 看着代码，就可以一路下一步断点出来，最终通过VertX发送了Socket</p><h4>NIO事件循环回掉</h4><p>主线程使用VertX发送Socket后，会在NioEventLoop线程(基于Netty的Select调用)中onReply，通过CountDownLatch机制唤醒主线程，处理应答</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">tcpClientPool.send(tcpClient, clientPackage, ar -&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 此时是在NioEventLoop网络线程中onReply，需要转换线程</span><br><span class="line">    &#x2F;&#x2F; 执行了 SyncResponseExecutor 的 run 方法，将 CountDownLatch 计数变为0时</span><br><span class="line">    invocation.getResponseExecutor().execute(() -&gt; &#123;</span><br><span class="line">    	&#x2F;&#x2F; 主线程wakeup后，才会调用下面的代码</span><br><span class="line">        if (ar.failed()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 只会是本地异常</span><br><span class="line">            asyncResp.consumerFail(ar.cause());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 处理应答</span><br><span class="line">        try &#123;</span><br><span class="line">            Response response &#x3D;</span><br><span class="line">                HighwayCodec.decodeResponse(invocation,</span><br><span class="line">                        operationProtobuf,</span><br><span class="line">                        ar.result(),</span><br><span class="line">                        tcpClient.getProtobufFeature());</span><br><span class="line">            &#x2F;&#x2F; 调用next中的闭包</span><br><span class="line">            asyncResp.complete(response);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            asyncResp.consumerFail(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4>主线程反向消费handle闭包</h4><p>主线程由于CountDownLatch计数为0，由park状态重新启动，开始执行decode操作，并反向消费next中的闭包，类似于andThen操作。如果你看过Akka的书籍，就可以发现这里本质上就是定制了各种消息处理器</p><ul><li>TransportClientHandler(send)</li><li>LoadbalanceHandler</li><li>ConsumerBizkeeperHandler</li><li>ShutdownHookHandler</li></ul><blockquote><p>此部分断点非常难打，读者需要明白一点，基于消息的多线程与闭包混在一起时，一定要广撒网打断点</p><p>本项目中的链式回掉类似于栈的结构，而RxJava中的回掉类似于管道，本部分代码我觉得还有逻辑优化的空间，第一次看代码很难搞明白</p></blockquote><h3>2.4. RPC通信传输</h3><p>此部分基于HTTP/私有Socket协议(HighWay)进行实现，HTTP基于JSON，比较简单。下面以自研Highway协议为例</p><ul><li>传输语法: Protobuf(开源组件，二进制编码比文本更快，比如SonarQube也用了这个方案)</li><li>抽象语法: 对OutputStream进行定制(HighwayCodec)，定制了报文的Header，Body与Length</li><li>Socket框架: Vert.x，并封装了连接池ClientPoolManager，线程池</li></ul><blockquote><p>有意向替换HTTP为私有Socket的开发者，可以尝试一下这种方案</p></blockquote><p>连接池部分设计了一个<code>Map&lt;ThreadId,[CLIENT_POOL]&gt;</code>，实现了线程一对多，有点类似于RxJava中的ComputationScheduler</p><p>本部分的连接池是一个亮点，本文再写就超字数了，后续将详细分析</p><h3>2.5. Provider的路由与消费</h3><ul><li>路由: 在NioEventLoop网络线程中通过<code>Map&lt;URL,Handler&gt;</code>进行路由</li><li>消费: 在新的线程池上进行链式调用invocation，最终通过ProducerOperationHandler进行Method.invoke反射调用</li></ul><h3>3. 基于etcd的ServiceDiscovery</h3><h4>etcd的简介</h4><p>etcd是CoreOS开发的基于Go语言的分布式配置框架，etc就是linux中的<code>/etc</code>路径，一般用于放配置，而<code>d</code>是分布式的意思，它们俩加起来就是<code>分布式配置</code>。如果你用过Redis与Zookeeper，那么你看一遍etcd的文档就基本会折腾这个框架了</p><ul><li>etcd在本项目中用于维护一个树，你可以把它看成一个远程的注册表，并支持<strong>监听目录</strong>变化</li><li>etcd支持HTTP/GRPC通信，比ZK/Redis的纯Socket稍微友好一点</li><li>性能比zk更加优秀，单文件(30M左右)，免JVM，部署方便</li><li>不要把它当作Redis来用，它不支持复杂的数据结构，而且使用场景是多写少读。</li></ul><h2>4. 总结</h2><ul><li>PAAS云化是趋势，处在传统软件的码农要跟上时代</li><li>ServiceComb用YAML(Swagger)与Java注解这种DSL代替了繁琐的XML，微服务的配置与开发变得更加简单了，以后将有更多的这类DSL，难怪很多人自嘲为XML工程师:)</li><li>Go语言在平台中间件软件中很有潜力，定位也很明确(Better C，虽然我个人觉得Go语法过于Shell风格了)</li></ul><p>总的来说，ServiceComb开源的代码质量超过了预期，我希望能够继续开发推广，而不是为了完成KPI而开发，给开发者打个A！</p><h2>TODO</h2><ol><li>Go语言侧的分析</li><li>etcd的实现</li><li>Netty与vertx的分析(Socket开发)</li></ol><h2>5. 扩展阅读</h2><p>一些其它的开源框架(go/java)，国内折腾的不多，有兴趣可以看下源码</p><ul><li>一个分布式监控框架, <a target="_blank" rel="noopener" href="http://riemann.io/">http://riemann.io/</a></li><li>一个分布式鉴权框架, <a target="_blank" rel="noopener" href="https://github.com/jepsen-io/jepsen">https://github.com/jepsen-io/jepsen</a></li><li>一个啥都能干的框架, <a target="_blank" rel="noopener" href="http://vertx.io">http://vertx.io</a></li><li>官方公众号: servicecomb</li><li>胶片: <a target="_blank" rel="noopener" href="http://servicecomb.io/slides/">http://servicecomb.io/slides/</a></li></ul></div><div class="tags"><a class="tag-link" href="/tags/CodeReview/" rel="tag">CodeReview</a><a class="tag-link" href="/tags/MicroService/" rel="tag">MicroService</a></div></section><ul class="nav"><li>Prev:<a href="/%E5%A6%82%E4%BD%95%E4%B8%BB%E5%8A%A8%E8%87%AA%E5%AD%A6%E4%B8%8E%E6%8F%90%E9%97%AE/">如何主动自学与提问</a></li><li>Next:<a href="/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8Egroovy%E7%9A%84%E8%AE%B0%E5%BF%86%E5%8C%96/">动态规划与Groovy的记忆化</a></li></ul><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the<a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript></div></div></div></div><footer><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer><script>window.onload=function(){var a,e,n,t;a=window,e=document,t="script",n="ga",a.GoogleAnalyticsObject=n,a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=+new Date,n=e.createElement(t),t=e.getElementsByTagName(t)[0],n.async=1,n.src="//www.google-analytics.com/analytics.js",t.parentNode.insertBefore(n,t),ga("create","UA-102296742-1","auto"),ga("send","pageview")}</script></body></html>