<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="Recently I’m working on a project with the IO streams, here are some details."><meta name="keyword" content="Okio"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Profiling IO performance on different buffer size</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://eu.umami.is/script.js" data-website-id="449a84b6-be9e-49de-a4cc-e0fa6fea1df9"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">Profiling IO performance on different buffer size</div><div class="date no-print">2022-12-12 / modified at 2023-08-08 / 577 words / 3 mins</div><div class="content"><blockquote><span>️This article has been <strong>over 2 years</strong> since the last update.</span></blockquote><p>Recently I’m working on a project with the IO streams, here are some details.</p><span id="more"></span><h2>How does stream get transferred?</h2><p>Basicly, streams can be copied via a method called <code>transferTo</code>, creating an 8k memory chunk where bytes get accumulated and emit at once.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transferTo or IOUtils.copyLarge or BufferedInputStream are roughly the same</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Objects.requireNonNull(out, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">transferred</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// might slow down CPU speed and use too much memories</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[DEFAULT_BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> read;</span><br><span class="line">    <span class="comment">// memcpy is called bwtween kernel space to user space twice</span></span><br><span class="line">    <span class="keyword">while</span> ((read = <span class="built_in">this</span>.read(buffer, <span class="number">0</span>, DEFAULT_BUFFER_SIZE)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, read);</span><br><span class="line">        transferred += read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transferred;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// flush() is required for OutputStream after transmission</span></span><br></pre></td></tr></table></figure><p>In most cases, using as few as 8k chunk is enough while handling a <strong>continuous</strong> data stream, including calling an API with JSON, downloading a blob, and forwarding a socket. For example, JFrog Artifactory, a production-proven binaray storage solution, use FileUtils.copyInputStreamToFile internally.</p><h2>Should I use a buffer for performance?</h2><p>We might add a redundant buffer via BufferedInputStream for “performance” in transmission. But it is often a misused buffer that leads to insufficient performance. Here is an example.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> Files.newInputStream(Paths.get(<span class="string">&quot;/512MB.dmg&quot;</span>)));</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis, <span class="number">8192</span>+<span class="number">1</span>);</span><br><span class="line">bis.transferTo(OutputStream.nullOutputStream());</span><br></pre></td></tr></table></figure><p>The unaligned chunk will hit the <code>feek</code> and <code>fstat</code> system call in each loop, making a performance loss in transmission. Even if the buffer size is fixed to a multiple of 8k, the insufficiency can’t be fixed duo to the overhead of <code>memcpy</code> call in a loop.</p><p>Next, let’s profile some popular open source frameworks with the following code.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only okio example here</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> Files.newInputStream(Paths.get(<span class="string">&quot;/512MB.dmg&quot;</span>)));</span><br><span class="line"><span class="type">BufferedSource</span> <span class="variable">source</span> <span class="operator">=</span> Okio.buffer(Okio.source(fis);</span><br><span class="line"><span class="type">BufferedSink</span> <span class="variable">sink</span> <span class="operator">=</span> Okio.buffer(Okio.blackhole());</span><br><span class="line">sink.writeAll(source);</span><br></pre></td></tr></table></figure><p>Here is the result. The following percentage in the lists indicates how long does ChannelInputStream take in an execution.</p><ul><li>No buffer, 96%</li><li>BufferedInputStream, 8k buffer, 94.6% (actually no cache is used)</li><li>BufferedInputStream, 8k + 1 buffer, 59.38% (wastes on fseek, fstat, memcpy)</li><li>BufferedInputStream, 16k and more buffer, 85.86% (wastes on memcpy)</li><li>Okio, 8k buffer, 84% (wastes on segment maintenance)</li></ul><p>As seen above, no buffer is the best for simple and continuous transmission.</p><blockquote><p>It is relatively imperative to profilie use cases before introducing a framework.</p></blockquote><p>Search on StackOverflow, the only use case for BufferedInputStream is writing codec and parser while reading byte by byte. But if someone has the skill to write a parser, I believe he can also complete a more complicated buffering mechanism ranther than a simple array.</p><p>Here are some real use cases in famous projects</p><ul><li>Okhttp, a popular HTTP written in Java, uses Okio internally.</li><li>Grasscutter, a game server, uses KcpChannel and io.netty.buffer internally.</li><li>opentelemetry-java, a java metric client, uses Protobuf and manages flushing and buffering by itself.</li><li>Apache mina, a java SSH implementation, implements pointers and arrays by itself.</li></ul><h2>Appendix</h2><h4>Timeout</h4><p>Timeout can be implemented by</p><ul><li>checking with <code>throwIfReached</code> in each while loop in Okio</li><li>Guava’s SimpleTimerTask through Future.get()</li><li>Synchronized code fragment with object.wait().</li></ul><h4>Zero-Copy</h4><ul><li>If you want to reduce memcpy and context switch overhead, some low-level skills such as Java NIO or MMAP will be required.</li><li>If you need zero-copy at the CPU level, RoCE Ethernet cards over RDMA will be required for network offloads.</li></ul></div><div class="tags"><a class="tag-link" href="/tags/Okio/" rel="tag">Okio</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry.</a><span> All contents are not allowed to be redistributed or synthesised without an explicit permission.</span></div></footer></div></body></html>