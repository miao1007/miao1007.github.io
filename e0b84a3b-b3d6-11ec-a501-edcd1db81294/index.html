<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="解释器（Parser），顾名思义，就是对数据处理的实现。是一个能够输入一个命令或者描述后，内部进行运算，并输出数据的工具。"><meta name="keyword" content="AST"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>如何写一个Parser</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://eu.umami.is/script.js" data-website-id="449a84b6-be9e-49de-a4cc-e0fa6fea1df9"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">如何写一个Parser</div><div class="date no-print">2016-07-23 / modified at 2022-04-04 / 2.3k words / 10 mins</div><div class="content"><blockquote><span>️This article has been <strong>over 3 years</strong> since the last update.</span></blockquote><p>解释器（Parser），顾名思义，就是对数据处理的实现。是一个能够输入一个命令或者描述后，内部进行运算，并输出数据的工具。</p><span id="more"></span><p>举个例子，计算器、网页、py、c甚至CPU都是解释器，它们在不同层面上对数据进行处理，高级的有动态语言的shell交互，底层的有CPU的机器码，都是对一行行命令码的解释。</p><p>通过对解释器进行了解，首先直观上能够抽象化很多算法类问题的输入处理，同时由于解释器内部使用了多种数据结构，提高自己的实战能力。</p><p>看了垠神的《怎样写一个Parser》，写的太棒了，用的也是计算器的例子，可惜垠神用的是<code>Scheme</code>语言。自己一直想动手用Java实现，终于抽出2天时间，参考多本书籍，最终本文代码能够实现<code>&quot;3*2-8*(3-(4*2))&quot;</code>这类的计算式。</p><p>阅读前最好了解一点编译原理</p><hr><p>目录</p><ol><li>将文本转为Token枚举(String-&gt;Enum)</li><li>将中缀表达式转为后缀表达式</li><li>AST实现</li><li>遍历计算</li></ol><h2>将文本转为Token</h2><p>这一步相当于词法分析，即对字符串中的每一个值进行提取与映射，目前可以用yacc等工具进行自动化处理，当然为了了解原理，下文为手工代码。</p><p>由于这里的Token非常少，所以用枚举进行了定义。为了简化开发，我们在这里不考虑空格，浮点等数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TokenType</span> &#123;</span><br><span class="line"></span><br><span class="line">	ADD(<span class="string">&#x27;+&#x27;</span>), SUB(<span class="string">&#x27;-&#x27;</span>), MUL(<span class="string">&#x27;*&#x27;</span>), DIV(<span class="string">&#x27;/&#x27;</span>), </span><br><span class="line">	LEFT(<span class="string">&#x27;(&#x27;</span>), RIGHT(<span class="string">&#x27;)&#x27;</span>), NUM(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> name;</span><br><span class="line">	</span><br><span class="line">	TokenType(<span class="type">char</span> tokenName) &#123;</span><br><span class="line">	  <span class="built_in">this</span>.name = tokenName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">	TokenType type;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是字符串处理了，我们首先过滤了一些奇葩的输入，接着逐个子节地处理Token</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Token&gt; <span class="title function_">getToken</span><span class="params">(String a)</span> &#123;</span><br><span class="line">  <span class="comment">//简单处理一下匹配</span></span><br><span class="line">  <span class="comment">//不支持Regex平衡组</span></span><br><span class="line">  <span class="keyword">if</span> (!a.matches(<span class="string">&quot;^[\(\d]?[\d\+\-\*\/\(\)]*[\)\d]?$&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;can&#x27;t parse the token&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> List&lt;Token&gt; tokens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Token&gt;();</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  Token token;</span><br><span class="line"></span><br><span class="line">  <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">  TokenType type;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class="line">    c = a.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (isDigital(c)) &#123;</span><br><span class="line">      sb.append(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((type = getOperatorToken(c)) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sb.length() != <span class="number">0</span>) &#123;</span><br><span class="line">        token = <span class="keyword">new</span> <span class="title class_">Token</span>(TokenType.NUM, Integer.valueOf(sb.toString()));</span><br><span class="line">        tokens.add(token);</span><br><span class="line">        sb.setLength(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      token = <span class="keyword">new</span> <span class="title class_">Token</span>(type, <span class="number">0</span>);</span><br><span class="line">      tokens.add(token);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//never</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;bad character: &quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//末尾的</span></span><br><span class="line">  <span class="keyword">if</span> (sb.length() != <span class="number">0</span>) &#123;</span><br><span class="line">    token = <span class="keyword">new</span> <span class="title class_">Token</span>(TokenType.NUM, Integer.valueOf(sb.toString()));</span><br><span class="line">    tokens.add(token);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们接下来就不用各种奇葩的黑科技与字符串打交道了，而转移到更高层的抽象中。</p><p>这段代码的执行效果是这样的：</p><p>运行前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;334+3*2+2/(2*4)&quot;</span></span><br></pre></td></tr></table></figure><p>运行后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">334</span>, ADD, <span class="number">3</span>, MUL, <span class="number">2</span>, ADD, <span class="number">2</span>, DIV, LEFT, <span class="number">2</span>, MUL, <span class="number">4</span>, RIGHT]</span><br></pre></td></tr></table></figure><p>在Racket中，可以用Lex进行实现</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 引入工具库与前缀</span></span><br><span class="line">(<span class="name">require</span> parser-tools/lex)</span><br><span class="line">(<span class="name">require</span> (<span class="name">prefix-in</span> : parser-tools/lex-sre))</span><br><span class="line"><span class="comment">; +-x/的正则表达式</span></span><br><span class="line">(<span class="name">define-lex-abbrevs</span> (<span class="name">op</span> (<span class="symbol">:or</span> #\+ #\- #\* #\/)))</span><br><span class="line">; [a-z]|[A-Z]的正则表达式</span><br><span class="line">(define-lex-abbrevs (word (:or (char-range # #\z) (char-range #\A #\Z))))</span><br><span class="line">; \d 的正则表达式</span><br><span class="line">(define-lex-abbrevs (digest (char-range # #\9)))</span><br><span class="line">; \d+\.?\d*</span><br><span class="line">(<span class="name">define-lex-abbrevs</span> (<span class="name">float</span> (:: (<span class="symbol">:+</span> digest) (:? #\.) (<span class="symbol">:*</span> digest))))</span><br><span class="line">(<span class="name">define</span> calc-lexer</span><br><span class="line">  (<span class="name">lexer</span></span><br><span class="line">   [(<span class="symbol">:+</span> word)</span><br><span class="line">    (<span class="name">cons</span> (<span class="name">string-&gt;symbol</span> lexeme)</span><br><span class="line">          (<span class="name">calc-lexer</span> input-port))]</span><br><span class="line">   [#\( </span><br><span class="line">    (<span class="name">cons</span> &#x27;L</span><br><span class="line">          (<span class="name">calc-lexer</span> input-port))]</span><br><span class="line">   [#\)</span><br><span class="line">    (<span class="name">cons</span> &#x27;R </span><br><span class="line">          (<span class="name">calc-lexer</span> input-port))]</span><br><span class="line">   [float</span><br><span class="line">    <span class="comment">; =&gt;</span></span><br><span class="line">    (<span class="name">cons</span> (<span class="name">string-&gt;number</span> lexeme)</span><br><span class="line">          (<span class="name">calc-lexer</span> input-port))]</span><br><span class="line">   [op</span><br><span class="line">    (<span class="name">cons</span> (<span class="name">string-&gt;symbol</span> lexeme)</span><br><span class="line">          (<span class="name">calc-lexer</span> input-port))]</span><br><span class="line">   [whitespace </span><br><span class="line">    (<span class="name">calc-lexer</span> input-port)]</span><br><span class="line">   [(<span class="name">eof</span>)</span><br><span class="line">    &#x27;()]))</span><br><span class="line">(<span class="name">calc-lexer</span> (<span class="name">open-input-string</span> <span class="string">&quot;-3*(88 + 12333.44444)-(4*5)&quot;</span>))</span><br></pre></td></tr></table></figure><h2>将中缀表达式转为后缀表达式</h2><p>此部分为语法分析的前部分，将对有括号的表达式进行处理，生成逆波兰表达式，即后缀表达式。各位可以把此步骤看成一个用栈实现的排序。</p><blockquote><p>逆波兰表示法（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式方式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。</p></blockquote><p>主要思路是这样的：我们首先需要知道，运算优先级<code>[\(\)] &gt; [\*\/] &gt; [\+\-]</code>，那么如何区分优先级呢？通过创建一个维护操作符的栈来实现。如下代码，当for循环中的token进入栈时，如果优先级比栈顶高，就直接入栈；如果优先级比栈顶低或者相等，就把栈顶元素赶出来，直到找到比栈中元素优先级更低的为止。</p><p>关于左右括号，其实不用太在意，它们与加减乘除不相互影响。for循环中，遇到左括号直接进栈，遇到右括号时在栈中找左括号，并取出中间的元素。</p><p>下面实际上就是在做模式匹配，实在不明白的，可以在switch打断点调试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Reverse Polish notation，RPN，或逆波兰记法</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Token&gt; <span class="title function_">rnpList</span><span class="params">(List&lt;Token&gt; orign)</span> &#123;</span><br><span class="line">  <span class="comment">//输出结果</span></span><br><span class="line">  List&lt;Token&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Token&gt;();</span><br><span class="line">  <span class="comment">//操作数的栈,用于处理优先</span></span><br><span class="line">  Stack&lt;Token&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Token&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Token token : orign) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (token.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> NUM:</span><br><span class="line">        output.add(token);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> ADD:</span><br><span class="line">      <span class="keyword">case</span> SUB:</span><br><span class="line">        <span class="comment">//如果有高的或者同级的(+,-,*,/,),就把他们赶走,自己住进去</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; (!stack.peek().getType().equals(TokenType.LEFT)</span><br><span class="line">            &amp;&amp; !stack.peek().getType().equals(TokenType.RIGHT))) &#123;</span><br><span class="line">          output.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(token);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> MUL:</span><br><span class="line">      <span class="keyword">case</span> DIV:</span><br><span class="line">        <span class="comment">//如果有高的(*,/),就把他们赶走,自己住进去</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; ((stack.peek().getType().equals(TokenType.MUL) || stack.peek()</span><br><span class="line">            .getType()</span><br><span class="line">            .equals(TokenType.DIV)))) &#123;</span><br><span class="line">          output.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(token);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">//处理左右括号</span></span><br><span class="line">      <span class="keyword">case</span> LEFT:</span><br><span class="line">        <span class="comment">//左括号优先级最高,直接入栈</span></span><br><span class="line">        stack.push(token);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> RIGHT:</span><br><span class="line">        <span class="comment">//找到左括号为止,全部出栈,不含括号</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; !stack.peek().getType().equals(TokenType.LEFT)) &#123;</span><br><span class="line">          output.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉左括号</span></span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">          stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    output.add(stack.pop());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这一步，我们去掉了括号，并变成了极容易被计算机计算的表达式。</p><p>运行前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[334, ADD, 3, MUL, 2, ADD, 2, DIV, LEFT, 2, MUL, 4, RIGHT]</span><br></pre></td></tr></table></figure><p>运行后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[334, 3, 2, MUL, ADD, 2, 2, 4, MUL, DIV, ADD]</span><br></pre></td></tr></table></figure><h2>AST实现</h2><p>构造抽象语法树(AST)，用于描述计算的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AST</span> &#123;</span><br><span class="line">	Token operator;</span><br><span class="line">	Token left;</span><br><span class="line">	Token right;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AST</span><span class="params">(Token operator, Token left, Token right)</span> &#123;</span><br><span class="line">	  <span class="built_in">this</span>.operator = operator;</span><br><span class="line">	  <span class="built_in">this</span>.left = left;</span><br><span class="line">	  <span class="built_in">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span> &#123;</span><br><span class="line">	  <span class="keyword">switch</span> (operator.getType()) &#123;</span><br><span class="line">	    <span class="keyword">case</span> ADD:</span><br><span class="line">	      <span class="keyword">return</span> left.val + right.val;</span><br><span class="line">	    <span class="keyword">case</span> SUB:</span><br><span class="line">	      <span class="keyword">return</span> left.val - right.val;</span><br><span class="line">	    <span class="keyword">case</span> MUL:</span><br><span class="line">	      <span class="keyword">return</span> left.val * right.val;</span><br><span class="line">	    <span class="keyword">case</span> DIV:</span><br><span class="line">	      <span class="keyword">return</span> left.val / right.val;</span><br><span class="line">	    <span class="keyword">default</span>:</span><br><span class="line">	      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;can&#x27;t execute: &quot;</span> + operator);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>遍历计算</h2><p>这一步最简单，后缀计算，任何一本数据结构的书，在讲栈结构时都有这个教程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private int calc(List&lt;Token&gt; rnp) &#123;</span><br><span class="line">  Stack&lt;Token&gt; cache = new Stack&lt;Token&gt;();</span><br><span class="line">  for (Token token : rnp) &#123;</span><br><span class="line">    switch (token.getType()) &#123;</span><br><span class="line">      case NUM:</span><br><span class="line">        cache.push(token);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        Token b = cache.pop();</span><br><span class="line">        Token a = cache.pop();</span><br><span class="line">        AST ast = new AST(token, a, b);</span><br><span class="line">        Token token1 = new Token(TokenType.NUM,ast.calc());</span><br><span class="line">        System.out.println(&quot;token = &quot; + token1 + &quot;,&quot; + a + &quot;,&quot; + b + &quot;,&quot; + token);</span><br><span class="line">        cache.push(token1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cache.pop().val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>效果</h2><p>调用效果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input = <span class="string">&quot;3+4*5+(444+2)-3*(3/5)&quot;</span></span><br><span class="line">token = [<span class="number">3</span>, ADD, <span class="number">4</span>, MUL, <span class="number">5</span>, ADD, LEFT, <span class="number">444</span>, ADD, <span class="number">2</span>, RIGHT, SUB, <span class="number">3</span>, MUL, LEFT, <span class="number">3</span>, DIV, <span class="number">5</span>, RIGHT]</span><br><span class="line">output = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, MUL, ADD, <span class="number">444</span>, <span class="number">2</span>, ADD, ADD, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, DIV, MUL, SUB]</span><br><span class="line">token = <span class="number">4</span>,<span class="number">5</span>,<span class="type">MUL</span></span><br><span class="line"><span class="variable">token</span> <span class="operator">=</span> <span class="number">3</span>,<span class="number">20</span>,<span class="type">ADD</span></span><br><span class="line"><span class="variable">token</span> <span class="operator">=</span> <span class="number">444</span>,<span class="number">2</span>,<span class="type">ADD</span></span><br><span class="line"><span class="variable">token</span> <span class="operator">=</span> <span class="number">23</span>,<span class="number">446</span>,<span class="type">ADD</span></span><br><span class="line"><span class="variable">token</span> <span class="operator">=</span> <span class="number">3</span>,<span class="number">5</span>,<span class="type">DIV</span></span><br><span class="line"><span class="variable">token</span> <span class="operator">=</span> <span class="number">3</span>,<span class="number">0</span>,<span class="type">MUL</span></span><br><span class="line"><span class="variable">token</span> <span class="operator">=</span> <span class="number">469</span>,<span class="number">0</span>,SUB</span><br><span class="line">test.calc(a); = <span class="number">469</span></span><br></pre></td></tr></table></figure><h4>用Lisp实现</h4><p>扩展用，有兴趣可以看下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#lang racket</span><br><span class="line"><span class="comment">; 定义一个名为 eval-ast,入参为exp的函数</span></span><br><span class="line">(<span class="name">define</span> eval-ast</span><br><span class="line">  (λ (<span class="name">exp</span>)</span><br><span class="line">    (<span class="name">match</span> exp</span><br><span class="line">      [(? number? leaf) leaf] <span class="comment">;说明已经是叶子</span></span><br><span class="line">      [`(,op,l,r)        <span class="comment">;对S表达式进行遍历</span></span><br><span class="line">       (<span class="name">let</span> ([v1 (<span class="name">eval-ast</span> l)]</span><br><span class="line">             [v2 (<span class="name">eval-ast</span> r)])</span><br><span class="line">         (<span class="name">match</span> op</span><br><span class="line">           [`+ (<span class="name">+</span> v1 v2)]</span><br><span class="line">           [`- (<span class="name">-</span> v1 v2)]</span><br><span class="line">           [`* (* v1 v2)]</span><br><span class="line">           [`/ (<span class="name">/</span> v1 v2)]))])))</span><br><span class="line"><span class="comment">; 执行计算</span></span><br><span class="line">(<span class="name">eval-ast</span> `(+ <span class="number">1</span> (+ (* <span class="number">2</span> <span class="number">5</span>) (/ <span class="number">2</span> <span class="number">4</span>))))</span><br><span class="line"><span class="comment">;; =&gt; 11.5</span></span><br></pre></td></tr></table></figure><p>相比Java中用String/枚举与<code>t.left == null</code>的实现，这里代码没有一行废话; 同时由于支持类型推导，避免了Java中各种int转换与小数点的问题</p><h2>总结</h2><ol><li>尽量不要与String打交道，代码不但非常丑，以后也不好维护（类似于VO与DO的关系）</li><li>如果不喜欢递归这类函数调用，尽量用栈，思路将非常清晰。</li><li>将条件最小化，千万不要跨一大步实现小数点、空格等额外因素。</li></ol><h2>附录</h2><p>打印BinaryTree，二叉树的深度遍历，方便进行直观理解</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; racket draw Binary Tree</span></span><br><span class="line">#lang racket</span><br><span class="line"><span class="comment">; 导入绘图工具类</span></span><br><span class="line">(<span class="name">require</span> pict pict/tree-layout)</span><br><span class="line"><span class="comment">; 判断Token是否是单个元素</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">atom</span>? x) (<span class="name">not</span> (<span class="name">or</span> (<span class="name">pair</span>? x) (<span class="name">null</span>? x))))</span><br><span class="line"><span class="comment">; 定义一个名为gen-ast,入参为exp的函数</span></span><br><span class="line">(<span class="name">define</span> gen-ast</span><br><span class="line">  (λ (<span class="name">exp</span>)</span><br><span class="line">    (<span class="name">match</span> exp</span><br><span class="line">      [(? atom? leaf)   <span class="comment">;如果为叶子</span></span><br><span class="line">       (<span class="name">tree-layout</span> #<span class="symbol">:pict</span> (<span class="name">text</span> (~v leaf)))] </span><br><span class="line">      [`(,op,l,r)        <span class="comment">;对S表达式进行遍历</span></span><br><span class="line">       (<span class="name">let</span> ([v1 (<span class="name">gen-ast</span> l)]</span><br><span class="line">             [v2 (<span class="name">gen-ast</span> r)])</span><br><span class="line">         (<span class="name">tree-layout</span> #<span class="symbol">:pict</span> (<span class="name">text</span> (~v op)) v1 v2))])))</span><br><span class="line"><span class="comment">; 将生成的 tree-layout 赋值到 tree 变量</span></span><br><span class="line">(<span class="name">define</span> tree (<span class="name">gen-ast</span> `(+ <span class="number">1</span> (+ (* <span class="number">2</span> <span class="number">5</span>) (/ <span class="number">2</span> <span class="number">4</span>)))))</span><br><span class="line"><span class="comment">; 执行绘图</span></span><br><span class="line">(<span class="name">naive-layered</span> tree)</span><br></pre></td></tr></table></figure><p>生成的结果是这样的</p><p><img src="http://upload-images.jianshu.io/upload_images/98641-4efd190b1cd29d84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ast.png"></p><h2>参考</h2><ol><li><a target="_blank" rel="noopener" href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter">http://www.yinwang.org/blog-cn/2012/08/01/interpreter</a></li><li><a target="_blank" rel="noopener" href="http://blog.csdn.net/sgbfblog/article/details/8001651">http://blog.csdn.net/sgbfblog/article/details/8001651</a></li><li>《自制编程语言（图灵设计丛书）》</li><li>《学习正则表达式（图灵设计丛书）》</li></ol></div><div class="tags"><a class="tag-link" href="/tags/AST/" rel="tag">AST</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry.</a><span> All contents are not allowed to be redistributed or synthesised without an explicit permission.</span></div></footer></div></body></html>