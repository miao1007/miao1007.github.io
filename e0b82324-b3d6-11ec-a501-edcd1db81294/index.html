<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="很多版本管理工具都基于ACL Path实现了管理权限，本文加以综述介绍。"><meta name="keyword" content="Artifactory,Authz,DevOps,Subversion"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>SVN/JFrog/NFS的ACL权限模型介绍</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://eu.umami.is/script.js" data-website-id="449a84b6-be9e-49de-a4cc-e0fa6fea1df9"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">SVN/JFrog/NFS的ACL权限模型介绍</div><div class="date no-print">2022-03-06 / modified at 2022-05-27 / 2.2k words / 8 mins</div><div class="content"><blockquote><span>️This article has been <strong>over 3 years</strong> since the last update.</span></blockquote><p>很多版本管理工具都基于ACL Path实现了管理权限，本文加以综述介绍。</p><span id="more"></span><h2>分析方法论</h2><p>在权限设计讨论中，难度最高的就是关系和颗粒度</p><ul><li>继承与优先级关系：即 inheritance 和 priority 的问题 ，比如精确匹配优先 most specific path always matches first，还是最短优先（比如正则表达式）</li><li>颗粒度：基于路径的读写即可。</li></ul><p>本文对主流的SVN/Artifactory/NAS三种ACL模型进行分析。</p><h2>背景技术介绍</h2><h4>什么是WebDAV</h4><p>WebDAV可以被简单地被理解为基于HTTP的网盘，可以将一个HTTP Endpoint挂载到本地机器上读写。在日常生活中，常见的比如坚果云、日历等同步服务，在IT领域，有Artifactory/Subversion/S3等兼容服务，常见的Nginx、Apache、Caddy、Traefik、SVNKit服务均支持WebDAV插件。</p><p>同时，它与传统的NFS也有差距，本质是对象存储，比如不支持chmod，性能肯定不如Block储存。</p><h4>WebDAV的权限模型</h4><p>在<a target="_blank" rel="noopener" href="http://www.webdav.org/acl/">RFC规范</a>中，它是一种基于HTTP XML的定义。是基于<code>目录-用户-RW操作</code>的ACL实现，没有RBAC（角色）的概念。</p><ul><li>在最主流实现的Apache（mod_dav）中，采用了XML来定义URL目录资源和用户。</li><li>在Artifactory中，采用了基于JSON的PermissionTarget纯Java实现。</li><li>在SVN中，采用了authz的文件实现，这个文件需要同时被Apache的<a target="_blank" rel="noopener" href="https://httpd.apache.org/docs/2.4/configuring.html">httpd.conf</a>读取到；SVN仓库本身的authz是可以非必要不操作的。</li></ul><h2>SVN的鉴权方式</h2><p>虽然SVN是一种很老的工具，但是传统领域中仍然有庞大的存量用户。本文对SVN的权限模型进行介绍。SVN支持Socket协议和HTTP(S)协议（基于WebDAV），但是由于安全与兼容性，管理员更加偏好使用HTTP实现。本文只介绍HTTP的实现，即svn不开启socket，而通过apache代理静态源码文件的方案（即SVN侧没有任何守护进程）。</p><h4>SVN权限权限拦截器的实现思路</h4><ul><li>基于Apache mod_dav_svn，写一堆XML，但是需要同步authz文件，和文件系统绑死了，同时它是C语言项目，天天爆出漏洞，可想而知源码中有大量的祖传加固代码。</li><li>定制开发，可以参考SVNKit/scm-manager的DAVServlet，自己开发filter，测试的难度高，但是高度定制，可以纯Java实现。</li><li>定制开发，也可以参考其它云原生的middleware，或者策略引擎（比如OPA），进行网络层的ACL</li></ul><h4>SVN的Authn</h4><p>这里即证明你是你，一般在Apache侧采用集成LDAP实现，直接Basic auth即可。</p><h4>SVN的Authz文件格式介绍</h4><p>这个文件本质上和AWS的JSON权限配置是一样的，唯一不同是历史非常悠久。它的语法类似toml</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[groups]</span></span><br><span class="line">&lt;groupname&gt; = &lt;user&gt;<span class="section">[,&lt;user&gt;...]</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">[&lt;path in repository&gt;]</span></span><br><span class="line">@&lt;group&gt; = <span class="section">[rw|r]</span></span><br><span class="line">&lt;user&gt; = <span class="section">[rw|r]</span></span><br><span class="line">* = <span class="section">[rw|r]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[&lt;repository name&gt;:&lt;path in repository&gt;]</span></span><br><span class="line">@&lt;group&gt; = <span class="section">[rw|r]</span></span><br><span class="line">&lt;user&gt; = <span class="section">[rw|r]</span></span><br><span class="line">* = <span class="section">[rw|r]</span></span><br></pre></td></tr></table></figure><p>这个配置文件设计的非常糟糕，体现在</p><ul><li>群组groups与路径path共用一个语义</li><li>蕴含的exclude语义没有体现，即<code>* =</code>表示禁止任何人访问；优先级也没有体现</li><li>非常难测试，搭建依赖非常繁琐</li></ul><p>它的源码位置位于 libsvn_repos/authz.c 的 svn_repos_authz_check_access，但是足足有1800的C代码，测试用例4500行，基本上是一个迷你的规则引擎了，所以分析源码不是上策。</p><h2>Artifactory的权限模型</h2><p><a target="_blank" rel="noopener" href="https://www.jfrog.com/confluence/display/JFROG/Artifactory+Comparison+Matrix">Artifactory</a>是DevOp业界知名二进制仓库托管平台，它内部有一套简洁的ACL模型（可以扩展为RBAC），以下为OSS版的研究。个人认为这个项目的Authn和Authz非常完善，比SpringSecurity等框架有更好的实践。</p><h4>Artifactory的Authn</h4><p>AuthN即证明你是你。通过如下方法，采用编码方案（而非AOP/注解）在filter或者controller中实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 来自Spring security框架</span><br><span class="line">org.springframework.security.core.context.SecurityContext#setAuthentication</span><br></pre></td></tr></table></figure><p>关键类：</p><ul><li>Authentication： 证明你是你，并录入缓存中。</li><li>SecurityContext：缓存，可以是ThreadLocal或者redis等，本场景中是ThreadLocal。</li></ul><p>这里处理了LDAP/BasicAuth/Token等各种接入方案，但是它没有接入集中式的Session方案，相反从当前开源代码中猜测，收费版可能是转发Header/Token/License的方案实现的。</p><h4>Artifactory的Authz</h4><ul><li><p>全局与仓库：基于SpringSecurity的<code>@RolesAllowed</code>注解的模型，判断当前用户是管理员还是普通用户，一个简单的boolean存储，这个<code>is_admin</code>是直接扔到用户表中的，因此它不是重点。</p></li><li><p>仓库内：基于Ant-style pattern实现的权限规则引擎，一般落地时以仓库key+include为主键。</p></li><li><p>同样pathkey下，exclude的优先级更高</p></li></ul><p>假如有如下仓库文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/aaa</span><br><span class="line">----/bbb</span><br><span class="line">--------/ccc</span><br><span class="line">--------test.csv</span><br><span class="line">----/ddd</span><br></pre></td></tr></table></figure><p>我希望让某个用户只能读写某个路径，那么可以配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># includes</span><br><span class="line">aaa/bbb/*</span><br><span class="line"># grand user: abc with rw</span><br></pre></td></tr></table></figure><p>这样用户就只能请求到符合要求的url</p><p>当需要判断权限时，比如当用户下载某个目录下的文件时，将调用如下服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.artifactory.api.security.AuthorizationService#canRead(org.artifactory.repo.RepoPath)</span><br></pre></td></tr></table></figure><p>最核心的代码在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.artifactory.security.SecurityServiceImpl#permissionCheckOnAcl</span><br></pre></td></tr></table></figure><p>它是一个主要为两个for循环的方法，伪代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean check(Repo repo, String dir)&#123;</span><br><span class="line">  return repo.targets.anyMatch(target-&gt;&#123;</span><br><span class="line">     return !target.excludes.allMatch(dir) &amp;&amp; target.includes.anyMatch(dir)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它通过牺牲空间避免了树的深度遍历，缺点就是target干涉太强了，导致excludes基本上就是废材。假如一个仓库有2个PermissionTarget，一个同意通过，一个被否决，最终eval的结果仍然是通过，导致exclude不生效。</p><h2>三者测试对比</h2><p>我们拿它与常见的工具进行对比</p><p>Artifactory场景（全局默认为禁止访问）</p><table><thead><tr><th>child dir</th><th>parent dir</th><th>实现方案</th><th>子目录最终支持效果</th></tr></thead><tbody><tr><td>ro</td><td>rw</td><td>需要子节点配置exclude</td><td>ro（只能做到叶子目录级别，否则需要递归）</td></tr><tr><td>rw</td><td>ro</td><td>不涉及覆盖</td><td>rw</td></tr><tr><td>ro</td><td>default</td><td>不涉及覆盖</td><td>ro</td></tr><tr><td>rw</td><td>default</td><td>不涉及覆盖</td><td>rw</td></tr></tbody></table><p>SVN场景（全局默认为禁止访问）</p><table><thead><tr><th>child dir</th><th>parent dir</th><th>实现方案</th><th>子目录最终支持效果</th></tr></thead><tbody><tr><td>ro</td><td>rw</td><td>子节点覆盖父配置</td><td>ro</td></tr><tr><td>rw</td><td>ro</td><td>子节点覆盖父配置</td><td>rw</td></tr><tr><td>ro</td><td>default</td><td>不涉及覆盖</td><td>ro</td></tr><tr><td>rw</td><td>default</td><td>不涉及覆盖</td><td>rw</td></tr></tbody></table><p>NAS场景（全局默认为禁止访问 ）</p><table><thead><tr><th>child dir</th><th>parent dir</th><th>实现方案</th><th>子目录最终支持效果</th></tr></thead><tbody><tr><td>ro</td><td>rw</td><td>子目录chmod 500</td><td>ro</td></tr><tr><td>rw</td><td>ro</td><td>子目录chmod 700</td><td>rw</td></tr><tr><td>ro</td><td>default</td><td>不涉及覆盖</td><td>ro</td></tr><tr><td>rw</td><td>default</td><td>不涉及覆盖</td><td>rw</td></tr></tbody></table><p>综上，策略排序算法如下</p><table><thead><tr><th>child dir</th><th>parent dir</th><th>SVN</th><th>Artifactory</th><th>NFS</th></tr></thead><tbody><tr><td>ro</td><td>rw</td><td>ro</td><td>ro(limited)</td><td>ro(500)</td></tr><tr><td>rw</td><td>ro</td><td>rw</td><td>rw</td><td>rw(700)</td></tr><tr><td>ro</td><td>default</td><td>ro</td><td>ro</td><td>deny</td></tr><tr><td>rw</td><td>default</td><td>rw</td><td>rw</td><td>deny</td></tr></tbody></table><p>结论如下</p><ul><li>SVN：路径先从长到短排序，找到第一个通过为止，类似回溯法的后续遍历。</li><li>Artifactory：两层for循环，第一层AnyMatch；第二层excludes一票否决，再任意匹配includes，是贪心方案。</li><li>NFS：访问子目录必须支持父目录，也是贪心方案</li></ul><h4>Node的元数据管理的系统设计</h4><p>在最终落地时，需要用Postgres等数据去存储path的key-value数据（比如tag标记），主要有两个方案</p><ul><li>通过hstore/json存储数据，但是产生了供应商锁定</li><li>通过node_prop的外键存储方案，更新与索引比较麻烦，比如Artifactory就设计了4个索引</li></ul><p>经过对比，大容量（200M+）项目比如sonarqube/Artifactory的表结构均采用了传统外键的方案，而且这类项目均是高读写比的类型，建议采用传统方案。</p><h2>附录</h2><h4>Artifactory的替代方案</h4><p>假如你的场景仅仅是当作存储盘，而不会高度定制元数据，那么分布式存储是更好的方案。比如Lustre或者MinIO等，它们本身也有基础的ACL、挂载和replicate能力。但是NFS协议的Authn是基于客户端的UID实现，比较弱</p><h4>Artifactory的挂载能力</h4><p>Artifactory提供基础的WebDAV挂载能力，但是它需要单一凭证，无法实现类似NFS的按用户的LDAP AutoFS挂载能力。协议本身不支持文件属性，无法进行chmod。</p><h4>Artifactory的Masterkey方案</h4><p>它采用AES对称加密，初始安装时，masterKey与数据库口令等均通过配置文件明文保存，启动后此文件会被自动加密。如果需要更安全，可以移除masterKey，但是重启时需要修改配置文件并重新录入masterKey。目前看起来不支持定期CredentialRotation的功能，因此需要reset后重新加密，将涉及到停机。</p><h4>关于SpringSecurity</h4><p>研究了多款知名框架后，真正按照它默认注解模型的项目几乎没有，而全部是高度自定义+手写的方案，可以使用其中的SecureContext等模型，但是它的注解的确与configure的确反人类。</p></div><div class="tags"><a class="tag-link" href="/tags/Artifactory/" rel="tag">Artifactory</a><a class="tag-link" href="/tags/Authz/" rel="tag">Authz</a><a class="tag-link" href="/tags/DevOps/" rel="tag">DevOps</a><a class="tag-link" href="/tags/Subversion/" rel="tag">Subversion</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry.</a><span> All contents are not allowed to be redistributed or synthesised without an explicit permission.</span></div></footer></div></body></html>