<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="Namespace主要是通过CLONE_FLAG实现资源隔离。其实无论是Docker还是其它容器，它底层的隔离实现是内核早就有的功能。在内核中，通过ns_proxy实现。"><meta name="keyword" content="Docker,HPC,Namespace,Nomad,PaaS"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Linux隔离与调度「Namespace」</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">Linux隔离与调度「Namespace」</div><div class="date">2020-03-17 / modified at 2022-04-04</div><div class="content"><blockquote><span>️This article has been <strong>over 1 years</strong> since the last update.</span></blockquote><p>Namespace主要是通过<code>CLONE_FLAG</code>实现资源隔离。其实无论是Docker还是其它容器，它底层的隔离实现是内核早就有的功能。在内核中，通过<code>ns_proxy</code>实现。</p><span id="more"></span><p>Namespaces is a form of lightweight process virtualization, and it provides resource isolation.</p><p>如下是其结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ns的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span>&#123;</span></span><br><span class="line">  <span class="type">atomic_t</span> count;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line">  <span class="comment">// 后续还有 ipc, mnt,pid,user,net</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Docker等实现的runc的底层中，结构体调用如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runc/libcontainer/container_linux.go:496</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NamespaceTypes</span><span class="params">()</span></span> []NamespaceType &#123;</span><br><span class="line">	<span class="keyword">return</span> []NamespaceType&#123;</span><br><span class="line">		NEWUSER, <span class="comment">// Keep user NS always first, don&#x27;t move it.</span></span><br><span class="line">		NEWIPC,</span><br><span class="line">		NEWUTS,</span><br><span class="line">		NEWNET,</span><br><span class="line">		NEWPID,</span><br><span class="line">		NEWNS,</span><br><span class="line">		NEWCGROUP,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Namespace <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type NamespaceType <span class="string">`json:&quot;type&quot;`</span></span><br><span class="line">	Path <span class="type">string</span>        <span class="string">`json:&quot;path&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想了解NS的内部实现，那么需要分析内部相关数据结构，本文主要只介绍使用场景。</p><p>本文是通过临床实验来验证出结论，这个证明过程是不科学严谨的，仅供参考。</p><h2>进程(Processs)的基本介绍</h2><h4>什么是进程？</h4><p>进程是内核调度与隔离的最小单位，它是工作负载的结构体<code>task_struct</code>，在内核中被维护在PID表中。</p><h4>什么是 ProcFS?</h4><p><code>/proc</code>是一种虚拟文件系统(VFS)，支持用户态通过标准文件I/O通信方式实现对内核态进程（与其它系统信息）的函数调用（Translating a file read to an internal kernel method）。它只是一种IO通信形式，它与Web请求JSP渲染返回HTML并没有本质的区别。它在Linux中被更高级命令封装: top, ps, free, pmap。我个人认为这种“万物皆文本”并不是一个好设计，导致物理文件的mount/chroot全部需要配套定制补丁。</p><blockquote><p>参考链接: <a target="_blank" rel="noopener" href="https://ops.tips/blog/what-is-slash-proc/">https://ops.tips/blog/what-is-slash-proc/</a> 此文章的作者在<a target="_blank" rel="noopener" href="https://concourse-ci.org/">concourse-ci</a>工作</p></blockquote><h4>NS相关系统调用</h4><p>详情可以参考这里：<a target="_blank" rel="noopener" href="https://lwn.net/Articles/531381/">https://lwn.net/Articles/531381/</a></p><ul><li>setns: enter a ns</li><li>clone: fork and leave</li><li>unshare: Leaving a namespace</li></ul><h2>Mount命名空间隔离</h2><p>首先，我们先回忆下C的mount调用方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"><span class="comment">// eg: 挂载物理硬盘</span></span><br><span class="line"><span class="comment">// mount(&quot;/dev/sdaxx&quot;,&quot;/mnt/d/&quot;,&quot;ext3&quot;,&quot;flag&quot;,NULL)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *source, <span class="type">const</span> <span class="type">char</span> *target,</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="type">char</span> *filesystemtype, <span class="type">unsigned</span> <span class="type">long</span> mountflags,</span></span><br><span class="line"><span class="params">          <span class="type">const</span> <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><p>接下来是mount命名空间隔离的实现，我们以unshare为例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用debug模式分析</span></span><br><span class="line">strace -f -s 100 -o 2.<span class="built_in">log</span> unshare --mount bash</span><br><span class="line"><span class="comment"># 创建一个临时文件，并写入一些信息</span></span><br><span class="line"><span class="built_in">mkdir</span> -p tmp &amp;&amp; mount -t tmpfs tmpfs tmp &amp;&amp; mount -t tmpfs &amp;&amp; <span class="built_in">echo</span> 123 &gt; tmp/log.txt</span><br><span class="line"><span class="comment"># 打开另一个终端 cd tmp，可以发现里面啥也没有</span></span><br></pre></td></tr></table></figure><p>这样就初步实现了“私密空间”的隔离，其它应用甚至root也没法看到里面存储的东西，很多密钥通过此方案作为安全措施之一。</p><p>内部调用如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与父进程分离NS</span></span><br><span class="line">25208 unshare(CLONE_NEWNS)              = 0</span><br><span class="line"><span class="comment"># 递归调用将根目录设置为私有的，其中none这个是固定参数，不要理解为umount了</span></span><br><span class="line"><span class="comment"># recursively/rɪˈkɝsɪv/ change the propagation /ˌprɑpǝˈɡеʃǝn/ type to private</span></span><br><span class="line">25208 mount(<span class="string">&quot;none&quot;</span>, <span class="string">&quot;/&quot;</span>, NULL, MS_REC|MS_PRIVATE, NULL) = 0</span><br><span class="line"><span class="comment"># 其它操作</span></span><br></pre></td></tr></table></figure><h4>Runc的的加载容器镜像的实现</h4><p>在容器项目中，一般是先下载镜像，再单独挂载。我们以启动runc容器为例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /mycontainer</span><br><span class="line"><span class="built_in">cd</span> /mycontainer</span><br><span class="line"><span class="built_in">mkdir</span> rootfs</span><br><span class="line">docker <span class="built_in">export</span> $(docker create busybox) | tar -C rootfs -xvf -</span><br><span class="line">runc spec</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">strace -e trace=mount,unshare,<span class="built_in">clone</span>,<span class="built_in">chroot</span>,pivot_root -f -s 100 -o 1.<span class="built_in">log</span> runc run my</span><br></pre></td></tr></table></figure><p>内部调用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与父进程分离NS</span></span><br><span class="line">26276 unshare(CLONE_NEWNS|CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWPID|CLONE_NEWNET) = 0</span><br><span class="line"><span class="comment"># 子进程开始工作</span></span><br><span class="line"><span class="comment"># 已经抛弃chroot了</span></span><br><span class="line">26278 pivot_root(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;.&quot;</span>)              = 0</span><br><span class="line"><span class="comment"># 递归挂载根目录为当前目录</span></span><br><span class="line">26278 mount(<span class="string">&quot;&quot;</span>, <span class="string">&quot;.&quot;</span>, 0xc00015acc2, MS_REC|MS_SLAVE, NULL) = 0</span><br><span class="line">26278 mount(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/&quot;</span>, 0xc00015ad50, MS_RDONLY|MS_REMOUNT|MS_BIND|MS_REC, NULL) = 0</span><br><span class="line"><span class="comment"># 挂载已经unshare的proc，下文再接着讲</span></span><br><span class="line">26278 mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/mycontainer/rootfs/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, 0, NULL) = 0</span><br><span class="line"><span class="comment"># 后续启动子进程</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上述的“私密空间”，虽然普通用户看不到，但是root仍然可以用<code>nsenter</code>进入</p><h4>关于AutoFS的特殊场景</h4><p>我在某个场景中，需要挂载存储NFS服务，该场景下使用了AutoFS（自动新建与移除挂载点）实现自动挂载，如果开启了NS的隔离，将发现所有任务的 <code>/proc/self/mount</code>下没有自动挂载，而且报错“Too many levels of symbolic links.”，原因如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init-- Autofs</span><br><span class="line">        |</span><br><span class="line">        |- ContainerHost -(CLONE_NEWNS)-&gt; Container -&gt; can NOT access NFS</span><br><span class="line">        |</span><br><span class="line">        |- NormalProcess -(CLONE_FS)-&gt; can acess NFS resources</span><br></pre></td></tr></table></figure><p>普通程序fork出的子进程由于使用<code>CLONE_FS</code>共享FS挂载，当应用请求某个路径时，内核将拦截请求并挂载NFS资源，实现自动挂载。</p><p>而容器类的子进程只能获取到快照，无法实时更新Namespace，导致AutoFS挂载失败。</p><p>解决方法：关闭<code>CLONE_NEWNS</code>或者将AutoFS（nsenter）加入同一个NS即可（相当暴力了）。</p><h4>关于Docker与NFS</h4><p>在硬件存储NFS的LDAP安全配置中，root用户大部分默认被看作nobody，所以在Docker内部可能无权限挂载NFS盘，建议先在本地挂载。值得注意的是，NFS（块存储）一般来说是很昂贵的，主要是高性能场景（比如DB/Git）才使用的，如果只是附件直接用S3/WebDAV就ok了，甚至使用用户态的fuse挂载也可以。</p><h4>Docker执行挂载/解压的安全问题（SUID owned by root）</h4><ul><li>setuid: 有一种 chmod+s or chmod 4755 来配置setuid的<a target="_blank" rel="noopener" href="https://tomcope.com/tutorial/2020/02/20/docker-setuid-setguid.html">方案</a>，只需要容器挂载一个临时盘甚至直接改/etc，并用root配置setuid，在外部就可以作为root跑了。详见<a target="_blank" rel="noopener" href="https://book.hacktricks.xyz/linux-unix/privilege-escalation/docker-breakout#mount-writable-folder">POC</a> or <a target="_blank" rel="noopener" href="https://github.com/hashicorp/nomad/issues/6176">另外问题</a>。这个比较冷门（通常被加固过了），但是部分调度器软件仍然有大量使用而且暴露了API，它甚至创建比较干净的thread tree，而不需要再次fork。</li><li>setcap: 实现了分割root用户的特权，但是注意看起来是普通用户的镜像实际上拿到了root</li></ul><h2>PID隔离</h2><p>通过<code>CLONE_NEWPID</code>与<code>CLONE_NEWNS</code>实现了PID隔离，并防止访问上级的<code>/proc</code></p><p>其中</p><ul><li><code>CLONE_NEWPID</code>: 导致从1开始重新生成PID，可以通过<code>/proc/self/ns/pid</code>查看</li><li><code>CLONE_NEWNS</code>: which causes the caller’s mount namespace to obtain a private copy of the namespace that it was previously sharing with other processes, so that future mounts and unmounts by the caller are invisible to other processes (except child processes that the caller subsequently creates) and vice versa.</li></ul><p>实例如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strace -f -s 100 -o 2.<span class="built_in">log</span> unshare --fork --pid --mount-proc sh</span><br><span class="line"><span class="comment"># 接着进入我们启动的sh，可以通过ps查看当前只有一个进程了（显示为1）</span></span><br></pre></td></tr></table></figure><p>内部系统调用如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置clone参数</span></span><br><span class="line">25089 unshare(CLONE_NEWNS|CLONE_NEWPID) = 0</span><br><span class="line">25089 <span class="built_in">clone</span>(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fcbc7efea10) = 25090</span><br><span class="line"><span class="comment"># 子进程被启动</span></span><br><span class="line"><span class="comment"># 将/递归设置为私有</span></span><br><span class="line">25090 mount(<span class="string">&quot;none&quot;</span>, <span class="string">&quot;/&quot;</span>, NULL, MS_REC|MS_PRIVATE, NULL &lt;unfinished ...&gt;</span><br><span class="line">25089 wait4(25090,  &lt;unfinished ...&gt;</span><br><span class="line">25090 &lt;... mount resumed&gt; )             = 0</span><br><span class="line"><span class="comment"># 先私有后重新挂载，我认为下面的第一行是用不上的，因为上面已经递归配置过了</span></span><br><span class="line">25090 mount(<span class="string">&quot;none&quot;</span>, <span class="string">&quot;/proc&quot;</span>, NULL, MS_REC|MS_PRIVATE, NULL) = 0</span><br><span class="line">25090 mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, MS_NOSUID|MS_NODEV|MS_NOEXEC, NULL) = 0</span><br><span class="line"><span class="comment"># 后续就是启动Shell了</span></span><br></pre></td></tr></table></figure><h2>用户隔离</h2><p>用户命名空间<code>CLONE_NEWUSER</code>：主要实现了UID/GID隔离，维护了进程与文件的打开数的统计/Mapping</p><h4>当前Docker等容器的限制</h4><p>在默认情况下，CentOS是没有打开用户Mapping配置的，这时unshare是无法使用的，而在docker/runc侧，直接硬编码setuid/gid就把这个事情给搞定了，这个是不算隔离映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task_struct&#123;</span><br><span class="line">  <span class="comment">// 进程保存的用户信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你在容器外用<code>ps -u</code>查询可以发现运行账户就是真实的root用户，里面的root虽然被namespace限制，但是有各种<a target="_blank" rel="noopener" href="https://www.slideshare.net/insideHPC/singularity-the-inner-workings-of-securely-running-user-containers-on-hpc-systems-90927603">安全问题</a>，它被<a target="_blank" rel="noopener" href="https://book.hacktricks.xyz/linux-unix/privilege-escalation/docker-breakout">提权</a>后是可以成为真root的。同时这种方案在使用挂载时引发了一系列的读写权限问题。</p><h4>TTY安全问题</h4><p>主流容器在（比如Postgres）进行动态配置一般采用<a target="_blank" rel="noopener" href="https://github.com/ncopa/su-exec">su-exec</a>/gosu等项目，这种是不带fork的直接执行execvp，可以避免tty泄漏与root权限过大的问题。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换用户执行命令</span></span><br><span class="line"><span class="comment"># 内部只有setuid/setgid/execvp、而没有fork调用</span></span><br><span class="line">./su-exec uid:gid pstree -up</span><br><span class="line"><span class="comment"># 需要加载bashrc的场景</span></span><br><span class="line">./su-exec uid:gid bash -ic <span class="string">&#x27;pstree -up&#x27;</span></span><br></pre></td></tr></table></figure><p>千万不要去折腾su，sudo等命令，它会给你耗死在文档细节中的，还不如几个系统调用使用的明确。</p><h4>如何实现“fake root”(井の中のroot)？</h4><p>这个也是比较新的功能，详见<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man7/user_namespaces.7.html">man文档</a>，需要升级到CentOS7以上，它通过LD_PRELOAD加载<code>libfakeroot-sysv.so</code>覆盖了常见系统调用，我们以<a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/#rootless-containers">rootless runc</a>为例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useradd <span class="built_in">test</span></span><br><span class="line">su <span class="built_in">test</span></span><br><span class="line"><span class="built_in">id</span></span><br><span class="line"><span class="comment"># =&gt; 1001, 1001 普通用户</span></span><br><span class="line">runc spec --rootless</span><br><span class="line">strace -f -s 100 -o 2.<span class="built_in">log</span> runc --root ~/runc run mycontainerid</span><br><span class="line"><span class="comment"># 命名不是root却启动了一个假的root</span></span><br></pre></td></tr></table></figure><p>内部调用如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建子进程</span></span><br><span class="line">14118 <span class="built_in">clone</span>( &lt;unfinished ...&gt;</span><br><span class="line"><span class="comment"># 子进程不共享USER NS</span></span><br><span class="line">14120 unshare(CLONE_NEWUSER)            = 0</span><br><span class="line"><span class="comment"># 父进程配置Mapping</span></span><br><span class="line"><span class="comment"># permanently disable setgroups(2) in a user namespace </span></span><br><span class="line">14118 open(<span class="string">&quot;/proc/14120/setgroups&quot;</span>, O_RDWR) = 7</span><br><span class="line">14118 write(7, <span class="string">&quot;deny&quot;</span>, 4)               = 4</span><br><span class="line"><span class="comment"># map root to parent &quot;test&quot; uid</span></span><br><span class="line">14118 open(<span class="string">&quot;/proc/14120/uid_map&quot;</span>, O_RDWR) = 7</span><br><span class="line">14118 write(7, <span class="string">&quot;0 1001 1\n\0&quot;</span>, 10)      = 10</span><br><span class="line"><span class="comment"># map root to parent &quot;test&quot; gid</span></span><br><span class="line">14118 open(<span class="string">&quot;/proc/14120/gid_map&quot;</span>, O_RDWR) = 7</span><br><span class="line">14118 write(7, <span class="string">&quot;0 1001 1\n\0&quot;</span>, 10)      = 10</span><br><span class="line">14120 setresuid(0, 0, 0 &lt;unfinished ...&gt;</span><br><span class="line">...</span><br><span class="line">14120 unshare(CLONE_NEWNS|CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWPID) = 0</span><br></pre></td></tr></table></figure><p>在外部用真正的root可以看到如下Mapping</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/14120/uid_map </span><br><span class="line"><span class="comment"># 0       1001          1</span></span><br><span class="line"><span class="built_in">cat</span> /proc/14120/gid_map </span><br><span class="line"><span class="comment"># 0       1001          1</span></span><br></pre></td></tr></table></figure><p>上述方法需要比较新的内核，CentOS需要7.7以上才稳定。</p><p>同时也要注意，在Singularity容器的<a target="_blank" rel="noopener" href="https://sylabs.io/guides/3.6/admin-guide/installation.html#fakeroot-sub-uid-gid-mapping">介绍</a>中，Most network filesystems (NFS/Lustre/GPFS etc.) <em>do not</em> support this uid/gid mapping in a user namespace.</p><h2>网络隔离</h2><p>网络隔离方案一般不会是单机版方案，主流方案是启动一个虚拟网卡/进程来实现层三（比如Openstack的Neutron）或者层四交换。</p><p>更多这里就不介绍了，可以参考 <a target="_blank" rel="noopener" href="https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model/">https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model/</a></p><h2>总结</h2><ul><li>理解难度从高到低依次如下：proc，namespace，cgroup。procfs的遗留设计带来了很多额外的负担</li><li>尽可能通过strace分析，而不是陷入源码/Shell中，碰上Shell就把你时间耗没了</li><li>使用docker（root daemon）基本上到处都是漏洞，全部看作root来管理吧，可以考虑使用<ul><li>在计算等场景，使用加固后的OS比如EulerOS，加固过的Singularity</li><li>禁用挂载/FS/allow_caps/namespace等权限后的docker，参考<a target="_blank" rel="noopener" href="https://websec.readthedocs.io/zh/latest/misc/docker.html">这里</a></li><li>供应链上的docker trust sign</li></ul></li></ul><p>我更推荐看runc规格文档或者Redhat使用手册，而不是把时间耗在“docker等价于几条shell命令，shell命令的C源码实现”等事情中。</p></div><div class="tags"><a class="tag-link" href="/tags/Docker/" rel="tag">Docker</a><a class="tag-link" href="/tags/HPC/" rel="tag">HPC</a><a class="tag-link" href="/tags/Namespace/" rel="tag">Namespace</a><a class="tag-link" href="/tags/Nomad/" rel="tag">Nomad</a><a class="tag-link" href="/tags/PaaS/" rel="tag">PaaS</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>