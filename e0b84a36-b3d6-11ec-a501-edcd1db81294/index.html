<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="本文先从Fibonacci递归计算开始，介绍了通过DP消除栈的算法，以及CPS的基本概念与Jenkins底层实现。"><meta name="keyword" content="CPS,DP,FP,Groovy,Jenkins"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>动态规划与JenkinsCPS技术</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">动态规划与JenkinsCPS技术</div><div class="date">2020-02-15 / modified at 2022-08-29</div><div class="content"><p>本文先从Fibonacci递归计算开始，介绍了通过DP消除栈的算法，以及CPS的基本概念与Jenkins底层实现。</p><span id="more"></span><p>本文读者要求：掌握CPS/DP/Groovy的基本使用，编译理论的基本方法，部分需了解Jenkins。</p><p>本文目的：介绍DP、CPS的理论，以及CPS在Jenkins的实践。</p><h2>What is DP?</h2><p>DP(dynamic programming，动态规划)是缓存计算结果的方法，通过给参数注入全局缓存/消除栈等方法，降低重复计算成本。</p><p>以求fibonacci为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  in:0 1 2 3 4 5 6</span></span><br><span class="line"><span class="comment">// out:0 1 1 2 3 5 8</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(i - <span class="number">2</span>) + fibonacci(i - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子如果你经过调试，就会发现有很多重复计算（因为它是tree recursion），也很容易产生栈溢出，我们尝试使用DP解决</p><p>方法一：我们可以加一个全局缓存<code>int[] dp</code>，这种方法与使用Redis当缓存没有区别，也很像“科学管理”中的计算尺</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：top down DP，没有消除栈，空间复杂度为O(N)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] dp)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    dp[i] = i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i] = fibonacci(i - <span class="number">2</span>, dp) + fibonacci(i - <span class="number">1</span>, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二，通过for循环求离散点的积分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二：down-top，这种方法通过jump消除了栈，仍然消耗了O(N)的空间复杂度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">  dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    dp[j] = dp[j-<span class="number">1</span>] + dp[j-<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三，是更优写法，这种通过少数几个寄存器就实现了缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法三：递归栈消除+低空间复杂度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    c = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的场景中，方法一是保底，而for循环方法需要有积分的数学背景。</p><h2>迭代与递归的选择/转换</h2><p>无论是OJ题目，还是真实项目，它们都是现实的问题，现实的问题就有方法论去实施，去分解，所以不要惧怕这些问题。</p><ul><li>递归的顶层方法论其实是形而上，通过分解为最小任务，并用多个参数实验获取结果。它可以实现最小的状态转移语意，代码量最少，但是可能出现分解思路困难/堆栈异常/忽视关闭条件。</li><li>for循环等迭代底层都是JUMP命令，它没有栈，但是很多逻辑、全局变量混在一起，后面难以维护</li><li>以上问题均默认不开启编译器尾递归等优</li></ul><p>在真实问题中，我个人先使用递归设计出原型，再通过CPS/DP技术去实现Desugar，优化掉递归调用。</p> <?xml version="1.0" encoding="us-ascii" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="303px" preserveAspectRatio="none" style="width:828px;height:303px;background:#fff" version="1.1" viewBox="0 0 828 303" width="828px" zoomAndPan="magnify" class="kroki">$2<defs/><g><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="76" x="10" y="132.5938"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="56" x="20" y="155.5889">&#22797;&#26434;&#38382;&#39064;</text><rect fill="#F1F1F1" height="52.5938" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="244" x="136" y="124.4453"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="168" x="146" y="147.4404">&#25286;&#35299;&#20026;&#29366;&#24577;&#36716;&#31227;&#30340;&#36882;&#24402;&#38382;&#39064;</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="224" x="146" y="163.7373">(&#27604;&#22914;factorial(n)=factorial(n-1)*2)</text><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="191" x="430" y="20"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="171" x="440" y="42.9951">edge cases(&#27604;&#22914;null&#22330;&#26223;)</text><path d="M380,150.7422 L390,150.7422 C405,150.7422 405,38.1484 420,38.1484 L430,38.1484 " fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="158" x="430" y="160.7422"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="138" x="440" y="183.7373">Desular(&#26632;/&#21442;&#25968;&#20248;&#21270;)</text><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="178" x="638" y="76.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="158" x="648" y="99.292">Curry(&#22810;&#21442;&#25968;&#36716;&#20026;&#21333;&#21442;&#25968;)</text><path d="M588,178.8906 L598,178.8906 C613,178.8906 613,94.4453 628,94.4453 L638,94.4453 " fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="175" x="638" y="132.5938"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="155" x="648" y="155.5889">Top-down DP/&#31354;&#38388;&#20248;&#21270;</text><path d="M588,178.8906 L598,178.8906 C613,178.8906 613,150.7422 628,150.7422 L638,150.7422 " fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="48" x="638" y="188.8906"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="28" x="648" y="211.8857">CPS</text><path d="M588,178.8906 L598,178.8906 C613,178.8906 613,207.0391 628,207.0391 L638,207.0391 " fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="56" x="638" y="245.1875"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="36" x="648" y="268.1826">inline</text><path d="M588,178.8906 L598,178.8906 C613,178.8906 613,263.3359 628,263.3359 L638,263.3359 " fill="none" style="stroke:#454645;stroke-width:1"/><path d="M380,150.7422 L390,150.7422 C405,150.7422 405,178.8906 420,178.8906 L430,178.8906 " fill="none" style="stroke:#454645;stroke-width:1"/><path d="M86,150.7422 L96,150.7422 C111,150.7422 111,150.7422 126,150.7422 L136,150.7422 " fill="none" style="stroke:#454645;stroke-width:1"/></g></svg><p>拆解方法也是有方法论的，它可以通过<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Design_of_experiments">DOE(Design of experiments)</a>找出输入与输出的关系，比如</p><ul><li>通过强制固定一些参数降低动态复杂度，DP一定是确定性的/无状态的，非NP问题</li><li>输出并不一定确切的值。比如计算EditDistance，只用求最终总和即可，而没要求具体的排列组合，这两个难度完全不一致。</li></ul><p>除此之外，还有一些技巧性强的常数复杂度方案甚至经验公式/数学方法，但是这种方法是需要学习与记忆的</p><h2>What is CPS?</h2><p>将阻塞的请求改为异步的Callback形式（或者返回一个Promise/Next的结构体），仅此而已。注意网上有很多文章说通过CPS可以消除栈，但是只说对了一半，在没有编译器优化的情况下，并不能将栈优化为JMP调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consumer也可以用Groovy的Closure实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fibonacciCps</span><span class="params">(<span class="type">int</span> i, Consumer&lt;Integer&gt; call)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    call.accept(i);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fibonacciCps(i - <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer a)</span> &#123;</span><br><span class="line">        fibonacciCps(i - <span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer b)</span> &#123;</span><br><span class="line">            call.accept(a + b);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fibonacciCps(<span class="number">6</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer sum)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;sum = &quot;</span> + integer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>平时编码这种写法可读性很差，很难显示区分同步还是异步执行，所以基本上没有利用的机会，一般会“人肉AST优化”到DP的第三种。</p><p>不过这样的好处是</p><ul><li>作为AST的中间态，方便编译器进行栈消除</li><li>实现在JVM上自己的“栈”与“VM”，以及持久化</li><li>实现数据“状态”的持久化（Checkpoint/Restore），比如Jenkins/CRIU</li></ul><h2>Jenkinsfile的CPS实现</h2><p>此部分介绍用户输入的Jenkinsfile脚本在Jenkins底层执行的流程</p><h4>字符串编译为BlockAST</h4><p>原始的脚本虽然写的像字符串，执行底层也是Groovy，但是它<strong>不是Groovy语言</strong></p><ul><li>所有Groovy语言的Token关键词(比如if/常数/变量)将不再是一个简单的JVM字节码，而有各个对应的Block，通过MetaMethodSite实现了&quot;编译&quot;为CPS的Block</li><li>静态工具类调用（比如forEach）/Closure表达式，通过CpsTransformer在编译时/运行时生成CPS转换，除非加入<code>@NoCPS</code>注解。有人可能看过王垠的40行代码，但是王垠的显然更高级。</li><li>定制的Step，通过<code>FunctionCallBlock</code>封装调用，它内部再使用CpsScript引擎去Eval</li></ul><p>在执行侧，Jenkins通过Groovy的Script实现了自己封装了一个Runtime，具体可以看<a href="/tags/Groovy/">Groovy</a>相关文章，避免自己从零写AST，最终输入的Groovy字符串将转为如下结构体</p> <?xml version="1.0" encoding="us-ascii" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="162px" preserveAspectRatio="none" style="width:1068px;height:162px;background:#fff" version="1.1" viewBox="0 0 1068 162" width="1068px" zoomAndPan="magnify" class="kroki">$2<defs/><g><rect fill="#F1F1F1" height="52.5938" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="198" x="10" y="54.0742"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="119" x="20" y="77.0693">CpsThreadGroup</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="178" x="20" y="93.3662">(&#23558;&#34987;&#25345;&#20037;&#21270;&#20026;program.dat)</text><rect fill="#F1F1F1" height="52.5938" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="119" x="258" y="54.0742"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="99" x="268" y="77.0693">Continuable &amp;</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="88" x="268" y="93.3662">Continuation</text><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="45" x="427" y="20"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="25" x="437" y="42.9951">Env</text><path d="M377,80.3711 L387,80.3711 C402,80.3711 402,38.1484 417,38.1484 L427,38.1484 " fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="81" x="427" y="76.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="61" x="437" y="99.292">BlockList</text><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="86" x="558" y="48.1484"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="66" x="568" y="71.1436">&#22522;&#30784;Block</text><path d="M508,94.4453 L518,94.4453 C533,94.4453 533,66.2969 548,66.2969 L558,66.2969 " fill="none" style="stroke:#454645;stroke-width:1"/><rect fill="#F1F1F1" height="36.2969" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:1.5" width="142" x="558" y="104.4453"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="122" x="568" y="127.4404">FunctionCallBlock</text><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="109" x="753" y="118.292">&#25191;&#34892;steps&#31561;&#21151;&#33021;</text><path d="M700,122.5938 L710,122.5938 C725,122.5938 725,113.4453 740,113.4453 L750,113.4453 " fill="none" style="stroke:#454645;stroke-width:1"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="303" x="753" y="136.5889">&#25191;&#34892;Groovy&#24037;&#20855;&#31867;CpsDefaultGroovyMethods</text><path d="M700,122.5938 L710,122.5938 C725,122.5938 725,131.7422 740,131.7422 L750,131.7422 " fill="none" style="stroke:#454645;stroke-width:1"/><path d="M508,94.4453 L518,94.4453 C533,94.4453 533,122.5938 548,122.5938 L558,122.5938 " fill="none" style="stroke:#454645;stroke-width:1"/><path d="M377,80.3711 L387,80.3711 C402,80.3711 402,94.4453 417,94.4453 L427,94.4453 " fill="none" style="stroke:#454645;stroke-width:1"/><path d="M208,80.3711 L218,80.3711 C233,80.3711 233,80.3711 248,80.3711 L258,80.3711 " fill="none" style="stroke:#454645;stroke-width:1"/></g></svg><h4>CPS层执行与栈消除</h4><p>在CPS的内部AST，是一个<code>Block</code>单向链表，除了Parallel外，其它Block都是线性遍历的，因此设计上很简洁，这个与<a href="/gitbook/mybatis/">MyBatis</a>的<code>MixedSqlNode</code>/S-Expression是相同的设计思路</p> <?xml version="1.0" encoding="us-ascii" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="91px" preserveAspectRatio="none" style="width:593px;height:91px;background:#fff" version="1.1" viewBox="0 0 593 91" width="593px" zoomAndPan="magnify" class="kroki">$2<defs/><g><g id="Next"><rect fill="#F1F1F1" height="78.2031" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:.5" width="100" x="7" y="7"/><line style="stroke:#181818;stroke-width:.5" x1="7" x2="107" y1="33.2969" y2="33.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="31" x="41.5" y="24.9951">Next</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="33" x="12" y="49.4355">Block</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="22" x="12" y="63.4043">Env</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="80" x="12" y="77.373">Continuation</text></g><g id="Block"><rect fill="#F1F1F1" height="64.2344" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:.5" width="100" x="178" y="13.98"/><line style="stroke:#181818;stroke-width:.5" x1="178" x2="278" y1="40.2769" y2="40.2769"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="38" x="209" y="31.9751">Block</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="22" x="183" y="56.4155">Env</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="80" x="183" y="70.3843">Continuation</text></g><g id="Next2"><rect fill="#F1F1F1" height="78.2031" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:.5" width="100" x="349" y="7"/><line style="stroke:#181818;stroke-width:.5" x1="349" x2="449" y1="33.2969" y2="33.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="40" x="379" y="24.9951">Next2</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="33" x="354" y="49.4355">Block</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="22" x="354" y="63.4043">Env</text><text fill="#000000" font-family="sans-serif" font-size="12" lengthAdjust="spacing" textLength="80" x="354" y="77.373">Continuation</text></g><g id="Block2"><rect fill="#F1F1F1" height="50" rx="3.5" ry="3.5" style="stroke:#181818;stroke-width:.5" width="67" x="519.5" y="21.1"/><line style="stroke:#181818;stroke-width:.5" x1="519.5" x2="586.5" y1="47.3969" y2="47.3969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="47" x="529.5" y="39.0951">Block2</text></g><g id="link_Next_Block"><path d="M107.38,46.1 C127.64,46.1 151.09,46.1 171.89,46.1 " fill="none" id="Next-to-Block" style="stroke:#454645;stroke-width:1"/><polygon fill="#454645" points="176.68,46.1,167.68,42.1,171.68,46.1,167.68,50.1,176.68,46.1" style="stroke:#454645;stroke-width:1"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="34" x="125.5" y="39.1669">eval..</text></g><g id="link_Block_Next2"><path d="M278.38,46.1 C298.64,46.1 322.09,46.1 342.89,46.1 " fill="none" id="Block-to-Next2" style="stroke:#454645;stroke-width:1"/><polygon fill="#454645" points="347.68,46.1,338.68,42.1,342.68,46.1,338.68,50.1,347.68,46.1" style="stroke:#454645;stroke-width:1"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="34" x="296.5" y="39.1669">eval..</text></g><g id="link_Next2_Block2"><path d="M449.43,46.1 C470.09,46.1 493.68,46.1 513.11,46.1 " fill="none" id="Next2-to-Block2" style="stroke:#454645;stroke-width:1"/><polygon fill="#454645" points="518,46.1,509,42.1,513,46.1,509,50.1,518,46.1" style="stroke:#454645;stroke-width:1"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="34" x="467.25" y="39.1669">eval..</text></g></g></svg><p>内部通过循环一个单向链表进行消除，是不是很像DP优化的第三种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.cloudbees.groovy.cps.Continuable#run0</span></span><br><span class="line"><span class="type">Next</span> <span class="variable">n</span> <span class="operator">=</span> cn.resumeFrom(e,k);</span><br><span class="line"><span class="keyword">while</span>(n.<span class="keyword">yield</span>==<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 我删掉了处理异常的代码行</span></span><br><span class="line">  n = n.step();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>JenkinsCPS的缺点</h4><p>由于它是对Jenkins深度定制的</p><ul><li>执行CPS必须需要Jenkins服务端（注意Agent只是执行原生字节码的，不处理CPS编排），没有成熟的离线解释器，因此执行调度性能限制于Jenkins单点</li><li>基于文件进行状态的持久化比较鸡肋，大部分场景中，master重启都会导致任务失败。当然这个毕竟是单点工具，没法比得过flink这种级别的Persisted States</li><li>断点调试很困难，基本上只能靠<code>echo</code>来分析脚本；CPS编程范式导致参数固定</li><li>作为插件开发者，那么这个Groovy/CPS的学习门槛的确有点高，从整个插件只有Kawaguchi一人主刀也可以看出</li></ul><h4>更深的语义定制</h4><p>假如你希望Jenkins能够实现更复杂的编排，或者自己的构建语法，可以尝试基于CPS再实现一层Interceptor，我基于此方案实现了</p><ul><li>YAML interceptor: 配合<a target="_blank" rel="noopener" href="https://plugins.jenkins.io/token-macro/">Macro解析</a>，实现用Java/Groovy实现AzureDevOps的效果，这样就可以将很多cps测试转换为无状态的测试。</li><li>Parallels BFS Tree嵌套并行执行构建</li><li>Log live tail</li></ul><p>这些是有门槛的定制场景，网上找不到开源的方案，全靠知识广度的积累。</p><h2>附录</h2><h4>关于研发效能/DevOps工具的前景</h4><ul><li><p>国内除了大型公司的工具组（比如我就经常看到阿里的人抱怨打了一天包都打不出来）有预算买现成的或者做这种改进，其它中小公司（所谓的Team）选择很有限，举例如下</p><ul><li>前百度研发效能团队自主创业“<a target="_blank" rel="noopener" href="https://help.ezone.work/">简单云</a>”，招聘要求那么高，结果北京顶格才4.5万，那还不如在大公司/外企接着苟。</li><li>腾讯的蓝鲸对外宣称腾讯全链路构建，结果腾讯内部的Coding/Orange/TYPD等各搞各的。</li></ul></li><li><p>假如工具要实现产品化可销售，由于技术上难度并不高，导致同质化严重，最好还是背靠大树来做，即和硬件/云一起去做，国内注定是强销售，要么出海和巨头竞争。</p></li><li><p>我个人认为这类工作很有挑战，因为它需要全局考虑，肯定比单独的业务项目有难度。</p><ul><li>机房、机柜、三层交换、云服务的配置</li><li>分布式存储（块存储、对象存储）、VPC、分布式调度器（cgroup与容器）的测试与选型</li><li>权限设计（IDaaS）、大数据度量与分析</li></ul></li></ul><h4>参考链接</h4><p><a target="_blank" rel="noopener" href="https://www.kimsereylam.com/racket/lisp/2019/02/14/recursion-with-fibonacci.html">https://www.kimsereylam.com/racket/lisp/2019/02/14/recursion-with-fibonacci.html</a></p><p><a target="_blank" rel="noopener" href="http://arasio.hatenablog.com/entry/2016/10/08/220843">http://arasio.hatenablog.com/entry/2016/10/08/220843</a></p><h4>插件开发技巧（如何利用当前Step/Node信息）</h4><p>由于我不希望定制场景的代码引入到Java层（重启Jenkins成本很高），但是又想获取到实时的Context信息，可以通过如下将业务代码移动到Groovy侧实现热部署</p><p>参考例本体的还原</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getting context of a *step*</span></span><br><span class="line"><span class="meta">@NoCPS</span> <span class="comment">// will not be compiled to CpsClosure, but MethodClosure</span></span><br><span class="line">def <span class="title function_">callback</span><span class="params">(result, Step s, CpsContext c)</span>&#123;</span><br><span class="line">  <span class="comment">// todo: use context, node and other metadata.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in your cps steps</span></span><br><span class="line">node&#123;</span><br><span class="line">  <span class="type">def</span> <span class="variable">result</span> <span class="operator">=</span> sh(<span class="string">&quot;xxxxx&quot;</span>)</span><br><span class="line">  <span class="comment">// implementation in java is required.</span></span><br><span class="line">  <span class="comment">// customStep内部直接调用 callback.call(this, context) 即可触发Groovy</span></span><br><span class="line">  customStep(callback: <span class="built_in">this</span>.&amp;callback.curry(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>Jenkins核心调试断点位置</h4><p>从MQ取到Executor开始执行的位置(之前都是Jenkins的调度过程)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jenkinsci.plugins.workflow.job.WorkflowRun#run</span><br></pre></td></tr></table></figure><p>整个Workflow总断点位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jenkinsci.plugins.workflow.cps.CpsFlowExecution#start</span><br></pre></td></tr></table></figure><p>如果只关注Step相关流程，可以在这里进行分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jenkinsci.plugins.workflow.cps.DSL#invokeMethod</span><br></pre></td></tr></table></figure></div><div class="tags"><a class="tag-link" href="/tags/CPS/" rel="tag">CPS</a><a class="tag-link" href="/tags/DP/" rel="tag">DP</a><a class="tag-link" href="/tags/FP/" rel="tag">FP</a><a class="tag-link" href="/tags/Groovy/" rel="tag">Groovy</a><a class="tag-link" href="/tags/Jenkins/" rel="tag">Jenkins</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>