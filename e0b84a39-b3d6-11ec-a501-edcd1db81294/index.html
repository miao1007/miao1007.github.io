<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="通过几个实际的例子，加深对RxJava的理解"><meta name="keyword" content="FP"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>函数式编程RxJava操作实例</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">函数式编程RxJava操作实例</div><div class="date">2015-09-12 / modified at 2022-04-04</div><div class="content"><blockquote><span>️This article has been <strong>over 1 years</strong> since the last update.</span></blockquote><p>通过几个实际的例子，加深对RxJava的理解</p><span id="more"></span><p>在阅读本文之前，建议阅读RxJava入门与Lambda表达式入门</p><h2>处理字符串</h2><p>用RxJava可以处理很多算法笔试题目，但是它作为第三方的库是不能用的（泪），下面的例子是对字符串的简单操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入一段数字，用空格隔开；然后过滤出小于2的元素；接着进行排序，最后获得了排序后的列表；</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//2 2 0 7 3 2 2 4 9 1 4</span></span><br><span class="line">Observable.from(scanner.nextLine().split(<span class="string">&quot;\s+&quot;</span>)).map(<span class="keyword">new</span> <span class="title class_">Func1</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).filter(<span class="keyword">new</span> <span class="title class_">Func1</span>&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Boolean <span class="title function_">call</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> integer &gt; <span class="number">2</span>;<span class="comment">//然后大于2的元素才能通过，类似于高通滤波器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).toSortedList().subscribe(<span class="keyword">new</span> <span class="title class_">Action1</span>&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(List&lt;Integer&gt; integers)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;integers = &quot;</span> + integers.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果换成Lambda表达式后，代码量与脚本语言持平</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = new Scanner(System.in);//eg.2 2 0 7 3 2 2 4 9 1 4</span><br><span class="line">Observable.from(scanner.nextLine().split(&quot;\s+&quot;))</span><br><span class="line">    .map(Integer::valueOf)</span><br><span class="line">    .filter(integer -&gt; integer &gt; 2)</span><br><span class="line">    .toSortedList()</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>当然如果同时学swift可以写成这样</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swift sample</span></span><br><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="string">&quot;2 2 0 7 3 2 2 4 9 1 4&quot;</span></span><br><span class="line">s.componentsSeparatedByString(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    .map(&#123; (_s) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">        <span class="type">Int</span>(_s)<span class="operator">!</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(&#123;<span class="variable">$0</span><span class="operator">&gt;</span><span class="number">2</span>&#125;)</span><br><span class="line">    .sort()</span><br></pre></td></tr></table></figure><h2>RxJava配合Retrofit2.0使用</h2><p>新的Retrofit2.0简直就是设计模式的教科书典范，同时对Rx的支持也更加友好，本例子为查询ip获取地理信息，并过滤掉失败信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Rxjava配合Retrofit解析json数据，注意这里全是电脑运行的，没有分开线程订阅</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line">client.interceptors().add(<span class="keyword">new</span> <span class="title class_">LoggingInterceptor</span>());<span class="comment">//log for okhttp</span></span><br><span class="line">	</span><br><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder().baseUrl(IPService.END).client(client)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())<span class="comment">//对Response进行adapter转换</span></span><br><span class="line">    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())<span class="comment">//对转换后的数据进行再包装</span></span><br><span class="line">    .build();</span><br><span class="line">    </span><br><span class="line">retrofit.create(IPService.class)<span class="comment">//动态代理生成class</span></span><br><span class="line">    <span class="comment">//直接操作json数据，这里可不是一个好的习惯，真正应该是DTO对象的</span></span><br><span class="line">    .getIPInfo(<span class="string">&quot;58.19.239.11&quot;</span>)</span><br><span class="line">    .filter(jsonObject -&gt; jsonObject.get(<span class="string">&quot;code&quot;</span>).getAsInt()==<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//转换数据类型</span></span><br><span class="line">    .map(jsonObject1 -&gt; jsonObject1.get(<span class="string">&quot;data&quot;</span>))</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    .subscribe(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//retrofit定义的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPService</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">END</span> <span class="operator">=</span> <span class="string">&quot;http://ip.taobao.com&quot;</span>;</span><br><span class="line">	<span class="comment">//建议写成dto对象，博主只是为了演示filter就把这里JsonObject了</span></span><br><span class="line">	<span class="meta">@GET(&quot;/service/getIpInfo.php&quot;)</span> Observable&lt;JsonObject&gt; <span class="title function_">getIPInfo</span><span class="params">(<span class="meta">@Query(&quot;ip&quot;)</span> String ip)</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Retrofit2.0已经把网络部分剥离了，所以需要自己实现Log</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LoggingInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">	</span><br><span class="line">  <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  System.out.println(</span><br><span class="line">      String.format(<span class="string">&quot;Sending request %s on %s%n%s&quot;</span>, request.url(), chain.connection(),</span><br><span class="line">          request.headers()));</span><br><span class="line">	</span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> chain.proceed(request);</span><br><span class="line">	</span><br><span class="line">  <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  System.out.println(</span><br><span class="line">      String.format(<span class="string">&quot;Received response for %s in %.1fms%n%s&quot;</span>, response.request().url(),</span><br><span class="line">          (t2 - t1) / <span class="number">1e6d</span>, response.headers()));</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完整代码在<a target="_blank" rel="noopener" href="https://gist.github.com/miao1007/7f75ccdf8b3026c077d6">Gist</a>托管</p><h2>对遗留代码进行再包装</h2><p>很多软件公司由于人事项目等原因，留下了很多历史代码，而重构代码肯定是费时费力而且不容易测试的，这时候我们可以再次对代码封装一遍，实现程序的健壮运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用RxJava对历史代码进行再包装，使它更加健壮，同时不需要重构或者继承SDK</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Observable.create(<span class="keyword">new</span> <span class="title class_">Observable</span>.OnSubscribe&lt;Map&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Subscriber&lt;? <span class="built_in">super</span> Map&gt; subscriber)</span> &#123;</span><br><span class="line">        fuckSDKSample(<span class="keyword">new</span> <span class="title class_">BadCallback</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(Map&lt;String, String&gt; s)</span> &#123;</span><br><span class="line">            subscriber.onNext(s);</span><br><span class="line">            subscriber.onCompleted();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFail</span><span class="params">()</span> &#123;</span><br><span class="line">            subscriber.onError(<span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;fuck sdk failed&quot;</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)<span class="comment">//重试3次</span></span><br><span class="line">        .retry((integer, throwable) -&gt; integer &lt; <span class="number">3</span> &amp;&amp; throwable <span class="keyword">instanceof</span> IllegalStateException)</span><br><span class="line">            <span class="comment">//过滤掉不满足的值</span></span><br><span class="line">        .filter(map -&gt; map.get(<span class="string">&quot;status&quot;</span>).equals(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">            <span class="comment">//转换并获取到接口中真正有用的东西</span></span><br><span class="line">        .map(map1 -&gt; Integer.valueOf((String) map1.get(<span class="string">&quot;value&quot;</span>)))</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 某个既没有异常回掉，没有注释，返回值模糊不清的大爷代码</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> callback 奇葩回掉</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fuckSDKSample</span><span class="params">(BadCallback callback)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;rand = &quot;</span> + rand);</span><br><span class="line">    <span class="comment">//模拟某些遗留代码的Bug，这里可以自行调整概率</span></span><br><span class="line">    <span class="keyword">if</span> (rand &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      callback.onFail();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//MagicNumber回掉</span></span><br><span class="line">      Map&lt;String, String&gt; stringMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      stringMap.put(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">      stringMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;23333&quot;</span>);</span><br><span class="line">      <span class="comment">//注意这里是非ui线程回调哦</span></span><br><span class="line">      callback.onSuccess(stringMap);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 某个奇葩的回掉接口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">BadCallback</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(Map&lt;String, String&gt; s)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFail</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后，我们实现了</p><ul><li>不破坏原有代码结构</li><li>提高了历史代码异常捕捉能力</li><li>通过重试与过滤，一定程度上提高代码运行成功率（前提是没有事务问题）</li><li>对返回值进行了转换，可以解决MagicNumber的问题</li></ul><h2>过滤</h2><p>过滤器，同电路中的滤波器。</p><p>注意filter只会过滤掉对象，如果全部过滤掉的话，会返回empty对象，直接调用了onComplete，<strong>而不会抛出异常</strong>；而使用single的话会抛出<code>NoSuchElementException</code>的异常。示例如下，在实际使用中，博主更喜欢用single一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">	.filter(integer -&gt; integer &gt; <span class="number">10</span>)</span><br><span class="line">	<span class="comment">//现在一个都过滤没了，返回的是一个empty对象，直接执行onComplete</span></span><br><span class="line">	.subscribe(System.out::println);</span><br><span class="line">	</span><br><span class="line">Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">	.single(integer -&gt; integer &gt; <span class="number">10</span>)</span><br><span class="line">	<span class="comment">//没有元素直接抛出异常</span></span><br><span class="line">	.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h2>迭代</h2><p>RxJava的迭代不同于常见的C语言迭代，RxJava是通过已经存在的值作为scan函数的参数而转换为另一个值。下面例子是求数列{1,2,3,4…}的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> <span class="title class_">Observable</span>.OnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(Subscriber&lt;? <span class="built_in">super</span> Integer&gt; subscriber)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">      subscriber.onNext(i);</span><br><span class="line">    &#125;</span><br><span class="line">    subscriber.onCompleted();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).scan(<span class="keyword">new</span> <span class="title class_">Func2</span>&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">  <span class="comment">//1 2 3 4  5(before)</span></span><br><span class="line">  <span class="comment">//1 3 6 10 15(after)</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">(Integer integer, Integer integer2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> integer + integer2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>抽样（基于时间）</p><h4>buffer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(subscriber -&gt; &#123;</span><br><span class="line">	<span class="comment">//产生10个事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">990</span>);</span><br><span class="line">            subscriber.onNext(String.valueOf(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            subscriber.onError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    subscriber.onCompleted();</span><br><span class="line">    <span class="comment">//每3秒合并一个Integer事件 </span></span><br><span class="line">&#125;).buffer(<span class="number">3</span>, TimeUnit.SECONDS).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[3, 9, 6]</span><br><span class="line">[6, 2, 3]</span><br><span class="line">[6, 4, 3]</span><br><span class="line">[4]</span><br></pre></td></tr></table></figure><h4>sample</h4><p>code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(990);</span><br><span class="line">                        subscriber.onNext(String.valueOf(new Random().nextInt(10)));</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        subscriber.onError(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).doOnNext(s -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;doOnNext &quot; + s + &quot; at &quot; + System.currentTimeMillis());</span><br><span class="line">        &#125;).sample(3, TimeUnit.SECONDS).forEach(each -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;forEach &quot; + each + &quot; at &quot; + System.currentTimeMillis());</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">doOnNext 0 at 1440944616333</span><br><span class="line">doOnNext 3 at 1440944617326</span><br><span class="line">doOnNext 7 at 1440944618318</span><br><span class="line">forEach 7 at 1440944618341</span><br><span class="line">doOnNext 9 at 1440944619312</span><br><span class="line">doOnNext 4 at 1440944620304</span><br><span class="line">doOnNext 8 at 1440944621297</span><br><span class="line">forEach 8 at 1440944621327</span><br><span class="line">doOnNext 4 at 1440944622291</span><br><span class="line">doOnNext 9 at 1440944623286</span><br><span class="line">doOnNext 4 at 1440944624279</span><br><span class="line">forEach 4 at 1440944624327</span><br><span class="line">doOnNext 5 at 1440944625273</span><br></pre></td></tr></table></figure><h2>flatmap的探究</h2><p>与Map不同，它一般用于一对多，或者多对一。<strong>最终Stream流的总长度将会改变</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line">List&lt;Integer&gt; a = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;Integer&gt; b = Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">List&lt;Integer&gt; c = Arrays.asList(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">List&lt;Integer&gt; out = Stream.of(a,b,c).flatMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;List&lt;Integer&gt;, Stream&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Stream&lt;Integer&gt; <span class="title function_">apply</span><span class="params">(List&lt;Integer&gt; integers)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> integers.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//out = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><p>一个简易flatMap的源码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamCompat</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Collection&lt;T&gt; origin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StreamCompat</span><span class="params">(Collection&lt;T&gt; origin)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.origin = origin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R&gt; StreamCompat&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span> &#123;</span><br><span class="line">        Collection&lt;R&gt; mapped = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;R&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T t : origin) &#123;</span><br><span class="line">            mapped.add(mapper.apply(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamCompat</span>&lt;R&gt;(mapped);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R&gt; StreamCompat&lt;R&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends StreamCompat&lt;? extends R&gt;&gt; mapper)</span> &#123;</span><br><span class="line">        Collection&lt;R&gt; flatted = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;R&gt;();</span><br><span class="line">        <span class="keyword">for</span> (T t : origin) &#123;</span><br><span class="line">            StreamCompat&lt;? <span class="keyword">extends</span> <span class="title class_">R</span>&gt; result = mapper.apply(t);</span><br><span class="line">            flatted.addAll(result.origin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StreamCompat</span>&lt;R&gt;(flatted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>Summary</h2><p>RxJava的确是一种新的开发方式，能够方便的进行测试，以下是个人对RxJava的一些看法</p><p>优点：</p><ul><li>RxJava跨平台很棒，服务器，iOS与Android可以拥有相同的逻辑，复用相同的代码，这点非常棒</li><li>RxJava可以包装大量历史遗留代码，简化开发流程，提高调试速度</li><li>RxJava可以按照函数依次进行测试，因为所有功能都是解耦的</li><li>RxJava是测试维护人员的惊喜，也有可能是维护人员的噩梦（比如Lambda表达式）</li><li>RxJava实现了jdk7上的Closures（闭包）</li></ul><p>不足：</p><ul><li>RxJava的学习成本比较高，需要国内先导者进行翻译与传教，需要说服开发团队学习使用，<s>目前来看不会的都找不到工作了</s></li><li>RxJava的全局try/cathc，还有包装类的存在，担心在性能上有损失（虽然目前还没有看出差别，而且全局try/catch只有在发生异常才有损失）</li></ul><h1>Refference</h1><ol><li><a target="_blank" rel="noopener" href="http://www.devtf.cn/?p=174">http://www.devtf.cn/?p=174</a></li><li><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/22847105/when-do-you-use-map-vs-flatmap-in-rxjava">http://stackoverflow.com/questions/22847105/when-do-you-use-map-vs-flatmap-in-rxjava</a></li></ol><h4>RxJava2的flatMap操作</h4></div><div class="tags"><a class="tag-link" href="/tags/FP/" rel="tag">FP</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>