<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="本文首先讲了如何对null等场景写防御代码，接着介绍了多种返回异常数据的表示方法。"><meta name="keyword" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>关于Null、Empty与Exception的思考</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body class="container"><header id="header"><div class="header"><div class="header-left"><div class="author"><div class="author-name"><a href="/">諺</a></div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">Archives</a></li><li style="font-size:.9rem"><a href="/archives" rel="nofollow">zh</a></li><li style="font-size:.9rem"><a href="#" rel="nofollow">|</a></li><li style="font-size:.9rem"><a href="/en" rel="nofollow">en</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">Epistemology</a></li><li><a href="/books" rel="nofollow">読書</a></li></ul></div></div></header><div class="content-wrapper"><div class="post"><section class="article"><div class="title">关于Null、Empty与Exception的思考</div><div class="date">2016-09-15に投稿</div><div class="content"><p>本文首先讲了如何对null等场景写防御代码，接着介绍了多种返回异常数据的表示方法。</p><span id="more"></span><h2>1. 如何写防御代码</h2><p>在调用第三方数据(这里包括调用其它接口，或者客户端发来的请求)时，一般有三种可能：</p><ul><li>第一是通过文档<strong>白纸黑字</strong>进行约束数据源一定不为空，或者到底谁负责校验，因此作为绝对信任返回值，可以不做空判断；</li><li>第二种就是未知的，可能为null。这种在没有文档、没有源码，甚至接口都是动态代理桩的情况下，只能对代码表示WTF了。</li><li>第三种返回的是空白的List。</li></ul><p>通过上面三种，常见的数据源大多按照如下设计</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> [<span class="string">&quot;1111&quot;</span>,<span class="string">&quot;2222&quot;</span>,<span class="string">&quot;3333&quot;</span>]</span><br><span class="line"><span class="number">2.</span> []</span><br><span class="line">3. &#123;&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;body&quot;:&#123; [&quot;1111&quot;,&quot;2222&quot;,&quot;3333&quot;]&#125;&#125;</span><br><span class="line"><span class="number">4.</span> &#123;<span class="attr">&quot;code&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="attr">&quot;message&quot;</span>:<span class="string">&quot;arg illegal&quot;</span>,<span class="attr">&quot;body&quot;</span>:<span class="literal">null</span>&#125;</span><br><span class="line"><span class="number">5.</span> &#123;<span class="attr">&quot;code&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="attr">&quot;message&quot;</span>:<span class="string">&quot;arg illegal&quot;</span>,<span class="attr">&quot;body&quot;</span>:[]&#125;</span><br><span class="line">6. null</span><br></pre></td></tr></table></figure><p>其中1, 2, 3, 4, 5都是常见的API，其中1, 2可以直接进行业务操作，而3, 4, 5需要一个状态码检查。上述API只要JSON反序列化过程是正常的，基本没有问题，不用做空判断可以直接执行业务；但是第五个却返回了null，那么问题来了。</p><h3>1.1. 对于NULL的处理方法</h3><p>null是一个很让人厌恶的类型，曾经造成了“10亿美元的错误”，虽然JDK8提供了<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">Optional</a>的设计，然而在目前场景中，很少有Optional的实现。null同时也经常意味不明，有时代表着没找到数据；有时代表着没有错误，甚至有时代表错误码（就像go语言中<code>ret,err = func()</code>的写法），那么到底如何处理null呢？</p><h4>1.1.1. 兼容场景</h4><p>如果你希望直接适配第三方的返回值，可以将null转为一个空白对象，比如<code>Collections.&lt;T&gt;emptyList()</code>，这样在之后的业务代码中，无论是遍历还是其它转换，因为它本身长度为0，不会产生任何额外错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list的结果不明朗</span></span><br><span class="line">List&lt;String&gt; list = getService().queryById(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//先调用`safe()`保证安全，再进行业务</span></span><br><span class="line">safe(list).stream()</span><br><span class="line">  .filter(s -&gt; s.lenght() &gt; <span class="number">3</span>)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里就是你对null的适配</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">safe</span><span class="params">(Collection&lt;T&gt; collection)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(collection==<span class="keyword">null</span>)&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;input list is null, will return a emptyList&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Collections.&lt;T&gt;emptyList();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> collection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>没有找到</code>不等于<code>null</code>，也不等于<code>错误</code>，上面的接口返回null，意义不明，导致出现无谓的防御代码</p><p>如果是容器类，可以将null装换为Collections.<t>emptyList()</t></p><p>如果是对象类，请接着看。</p></blockquote><blockquote><p>上面业务可以使用Common Collection4, RxJava, JDK8 Stream等工具进行处理，不必自己造轮子。</p></blockquote><h4>1.1.2. 强硬场景</h4><p>如果你明确不接受null，你可以直接抛出异常，进行甩锅，值得注意的是，这里仅仅是对开发者甩锅，而<strong>不能</strong>对用户甩锅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = getService().queryById(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//强行甩锅</span></span><br><span class="line">Objects.requireNonNull(list);</span><br><span class="line"><span class="comment">//开始业务</span></span><br><span class="line">list.....</span><br></pre></td></tr></table></figure><h3>1.2. 对于异常/错误的处理方法</h3><p>当在调用接口等不安全的场景中，可能因为网络连接等问题而抛出异常，因此，<strong>所有</strong>心里没有底的接口都<strong>必须</strong>放在try/catch中</p><p>常见异常/错误的处理设计如下</p><p>错误码风格的设计（比较成熟的使用广泛的设计）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//some Exception</span></span><br><span class="line">  <span class="keyword">return</span> Msg.of(<span class="string">&quot;0&quot;</span>,<span class="string">&quot;success!&quot;</span>,resp);</span><br><span class="line">&#125; <span class="keyword">catch</span>(ChildException ce)&#123;</span><br><span class="line">  <span class="keyword">return</span> Msg.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;call &#123;xxService&#125; failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回空白数据的设计（如果打了Log，此方法也比较可行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//some Exception</span></span><br><span class="line">  <span class="keyword">return</span> Msg.of(<span class="string">&quot;0&quot;</span>,<span class="string">&quot;success!&quot;</span>,resp);</span><br><span class="line">&#125; <span class="keyword">catch</span>(ChildException ce)&#123;</span><br><span class="line">  <span class="keyword">return</span> Msg.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;failed&quot;</span>,Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回null的设计（这个是大坑，所有人都没意见吧）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//some Exception</span></span><br><span class="line">  <span class="keyword">return</span> msg(<span class="string">&quot;0&quot;</span>,<span class="string">&quot;success!&quot;</span>,resp);</span><br><span class="line">&#125; <span class="keyword">catch</span>(ChildException ce)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出异常的设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//some Exception</span></span><br><span class="line">  <span class="keyword">return</span> msg(<span class="string">&quot;0&quot;</span>,<span class="string">&quot;success!&quot;</span>,resp);</span><br><span class="line">&#125; <span class="keyword">catch</span>(ChildException ce)&#123;</span><br><span class="line">  <span class="keyword">throw</span> ce;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的建议如下</p><ol><li>如果你当前实现的业务代码可以被底层平台全局try/catch保证，那么放心地直接抛出异常吧，这样代码写的最简洁</li><li>当你面向用户，异常<strong>中断</strong>了程序的执行，直接返回错误码即可，body可以写null，也可以写<code>[]</code>，但是我强烈推荐返回空白列表。</li><li>当你面向用户，异常可以被处理并接着执行程序，你只需要把它catch住即可。</li><li>当你面相开发者，异常中断了程序执行，直接抛出。</li><li>当你面相开发者，异常没有中断了程序执行，打Log跳过。</li><li>当没有业务错误时，直接返回正确的结果。</li></ol><h2>2. 如何安全迭代</h2><p>在获取到数据源后，并不代表里面都不是空的，forEach或者迭代器不能帮你过滤null，例子如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="keyword">null</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//无论使用Java8的forEach，还是迭代器，它们都不保证null过滤</span></span><br><span class="line"><span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">    <span class="comment">//跑到null时将抛出空指针</span></span><br><span class="line">    System.out.println(<span class="string">&quot;integ2er = &quot;</span> + integer.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你需要这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java8的方法</span></span><br><span class="line">list.stream().filter(i -&gt; i!=<span class="keyword">null</span>).doSomething;</span><br><span class="line"><span class="comment">//RxJava的方法</span></span><br><span class="line">Obeservable.from(list).filter(i -&gt; i!= <span class="keyword">null</span>).doSomething();</span><br><span class="line"><span class="comment">//自己写JDK8一下的工具类或者用Guava等工具类</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; list,Predicate&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">  List&lt;T&gt; arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  <span class="keyword">for</span>(T t: list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p.test(t))&#123;</span><br><span class="line">      arr.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好的实践是，你应该记住无论何时都不要把null放入容器(set, map…)中，这是何等怠惰的做法。</p><h2>3. 如何返回数据</h2><h4>3.1. 如何返回非空的对象</h4><p>下面是最常见的场景，直接返回了null，不过我认为是一种反模式，推荐加入<code>@Nullable</code>注解让IDE帮你进行更多的静态分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad practice: &quot;return null&quot; == &quot;no found&quot;</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id = database.find(name);</span><br><span class="line">  <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Employee(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要更优秀的代码，它是这样的，这样你获取到的值永远都是非空的，我最推荐的是这个方法，它在错误码场景中非常地常见。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id = database.find(name);</span><br><span class="line">  <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Employee.NOBODY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Employee(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种是异常的表示方法，也是符合OOP的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id = database.find(name);</span><br><span class="line">  <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> EmployeeNotFoundException(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Employee(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>3.2. 如何返回List</h4><p>返回的List永远不要设计为null，否则看起来很丑，而且客户端需要再次校验，推荐如下的形式，这个在上文也讲过了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getByAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">  List&lt;Employee&gt; list = database.find(age);</span><br><span class="line">  <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.&lt;Employee&gt;emptyList();</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>3.3. SUM</h4><p>说了这么多，总的就是两句：</p><ol><li>在面向用户的业务代码中，别人的代码不要信任，一定要过滤掉null，阻止null继续传递；</li><li>自己的业务代码要对用户/其它开发者负责，一定不要返回null，万不得已时也要加上<code>@Nullable</code>标记</li><li>在面向开发者的底层代码中，直接抛异常，节省联调时间。</li></ol><h2>4. try/catch过多是否影响性能？</h2><p>有时候在某些场景，对自己的代码不够自信，对底层不了解，而且是面向用户开发，因此希望处理所有的异常。</p><p>这时全局try/catch就登场了，关于全局try/catch，比如RxJava就是这样写的，网上有写评论说会影响性能，但是通过<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/141560/should-try-catch-go-inside-or-outside-a-loop">老外的讨论</a>，<strong>只有发生了异常</strong>才会去进行查询异常表、导出trace，进而影响性能。而如果没有出现异常，是不会发生性能变低的情景的。</p><p>我的建议如下：</p><ul><li>它处理了所有的异常，起码对用户来说不会出现错误堆栈信息。</li><li>它并不能代替你完成所有的异常处理，在被全局try/catch包裹的更小代码片段中，仍然需要try/catch进行捕获处理。</li></ul><h2>5. Refference</h2><ol><li><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/6546875/collections-emptylist-instead-of-null-check">http://stackoverflow.com/questions/6546875/collections-emptylist-instead-of-null-check</a></li><li><a target="_blank" rel="noopener" href="https://blogs.msdn.microsoft.com/ericlippert/2009/05/14/null-is-not-empty/">https://blogs.msdn.microsoft.com/ericlippert/2009/05/14/null-is-not-empty/</a></li><li><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/1274792/is-returning-null-bad-design">http://stackoverflow.com/questions/1274792/is-returning-null-bad-design</a></li><li><a target="_blank" rel="noopener" href="http://www.yegor256.com/2014/05/13/why-null-is-bad.html">http://www.yegor256.com/2014/05/13/why-null-is-bad.html</a></li><li><a target="_blank" rel="noopener" href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">Null References, The Billion Dollar Mistake</a></li><li>在v2ex上的<a target="_blank" rel="noopener" href="https://www.v2ex.com/t/306433#reply12">讨论帖</a></li><li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/j-lo-exception-misdirection/">Java 异常处理的误区和经验总结</a></li></ol></div><div class="tags"></div></section><ul class="nav"><li>Prev:<a href="/android%E4%B8%8B%E7%9A%84%E5%9F%BA%E4%BA%8Enfc%E7%9A%84%E9%87%91%E8%9E%8D%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91/">Android下的基于NFC的金融业务开发</a></li><li>Next:<a href="/spring%E4%B8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-ioc/">Spring下的控制反转(IOC)</a></li></ul><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the<a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript></div></div></div></div><footer><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer><script>window.onload=function(){var a,e,n,t;a=window,e=document,t="script",n="ga",a.GoogleAnalyticsObject=n,a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=+new Date,n=e.createElement(t),t=e.getElementsByTagName(t)[0],n.async=1,n.src="//www.google-analytics.com/analytics.js",t.parentNode.insertBefore(n,t),ga("create","UA-102296742-1","auto"),ga("send","pageview")}</script></body></html>