<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="Spring Cloud Function实现了类似于AWS Lambda的云函数调用，属于Serverless架构。它是基于SpringBoot开发的FAAS项目，目前Star只有100多，可以说是玩具级别。但是功能还是很全的。它基于Reactor进行设计，类似于Akka中的Actor或者RxJava中的Lift管道操作符"><meta name="keyword" content="CodeReview,FAAS,MicroService,Serverless,Spring,SpringBoot,SpringCloud"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Serverless开源项目分享-Spring-Cloud-Function</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">Serverless开源项目分享-Spring-Cloud-Function</div><div class="date">2017-08-19 / modified at 2022-04-04</div><div class="content"><blockquote><span>️This article has been <strong>over 1 years</strong> since the last update.</span></blockquote><p>Spring Cloud Function实现了类似于<a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/lambda-introduction.html">AWS Lambda</a>的云函数调用，属于<a target="_blank" rel="noopener" href="https://serverless.com/">Serverless</a>架构。它是基于SpringBoot开发的<a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-function">FAAS项目</a>，目前Star只有100多，可以说是玩具级别。但是功能还是很全的。它基于<a target="_blank" rel="noopener" href="https://projectreactor.io">Reactor</a>进行设计，类似于Akka中的Actor或者RxJava中的Lift管道操作符</p><span id="more"></span><blockquote><h4>The Serverless Architecture</h4><p>Deploy your applications as independent functions, that respond to events, charge you only when they run, and scale automatically.</p></blockquote><p>阅读本文需要如下知识点</p><ul><li>了解基本SpringBoot的注解，可以参考《SpringBoot揭秘》</li><li>掌握注解扫描/处理器与动态代理技术(又是如何写一个Parser)</li><li>熟练使用Stream与FluxAPI，否则连Demo都看不懂</li></ul><p>本文要做的事</p><ul><li>本文不分析前台<strong>JAX</strong>-<strong>RS</strong>的路由实现，它只是一个由Map与Regex构造的模式匹配</li><li>本文主要分析Function的注册、编译与执行流程，不分析supplier/consumer</li></ul><hr><h2>函数式编程</h2><p>无状态函数是指无副作用的函数，也就是函数式编程中所谓的“纯函数”，比如map，filter，它们在LISP语言中叫做Lambda表达式。因为不涉及共享变量，所以总是线程安全的。</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-function">Spring Cloud Function</a>: Spring推出的微服务框架，可以动态注册Java8函数</li><li><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/lambda-introduction.html">AWS Lambda</a>: 云函数调用属于<a target="_blank" rel="noopener" href="https://serverless.com/">Serverless</a>架构</li><li><a target="_blank" rel="noopener" href="https://projectreactor.io">Reactor</a>编程范式: 与无状态函数配合有两种形式，一种是CallBack，比如RxJava,Flux, 还有一种是模式匹配 Scala, Clojure, Akka, Erlang</li><li>select: Select系统调用本质也是无副作用，给下游可读或者可写的fd，再通过函数指针进行调用</li></ul><p>优点: 容易开发与热部署，测试用例也好实现。<br>缺点: 代码不容易理解，很难调试，(分布式情况下)全局函数可能命名重复而互相覆盖，目前只在Erlang等电信领域中比较多，纯Java的不成熟。</p><h2>什么是Lambda函数</h2><p>Lambda函数最开始来自于<a target="_blank" rel="noopener" href="https://www.gnu.org/software/emacs/manual/html_node/eintr/lambda.html">Lisp</a>，是一种匿名函数</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 定义一个f(x)=7*x</span></span><br><span class="line">(<span class="name">lambda</span> (<span class="name">number</span>) (<span class="name">*</span> <span class="number">7</span> number))</span><br><span class="line"><span class="comment">;; 调用Lambda函数</span></span><br><span class="line">((<span class="name">lambda</span> (<span class="name">number</span>) (<span class="name">*</span> <span class="number">7</span> number) <span class="number">3</span>)</span><br><span class="line">=&gt; <span class="number">21</span></span><br></pre></td></tr></table></figure><p>在Groovy/Ruby中也有类似的设计，比如Groovy中代码中<code>&#123;&#125;</code>就是lambda的语法糖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个f(x)=7*x</span></span><br><span class="line"><span class="keyword">def</span> closure = &#123;number-&gt; <span class="number">7</span> * number&#125;</span><br><span class="line"><span class="comment">// 调用Lambda函数</span></span><br><span class="line">&#123;number-&gt; <span class="number">7</span> * number&#125; <span class="number">3</span></span><br><span class="line">=&gt; <span class="number">21</span></span><br></pre></td></tr></table></figure><p>其实上面有一个潜规则，Lambda函数应该尽量避免与外界接触，最好是“无副作用”的纯函数，以免引入全局变量使架构变复杂。</p><p>目前的AWS，阿里云等云服务商，通过提供一个云函数的运行环境（比如OpenFAAS），用户提供函数代码，按执行时间收费。这就是所谓的Serverless架构，或者称作FAAS架构(FunctionAsAService)，比如CI构建编译等低频高性能要求的业务就适合这种架构。</p><p>当然，尽管网上说的神乎其神，不过在技术实现上我也觉得FAAS和JMX、在线OJ并没有本质区别</p><h2>OOP编程与FP编程范式</h2><p>它们俩个都属于<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Programming_paradigm">编程范式</a>，但是稍微有点不同，同时这两种也不是对立的。参考如下</p><blockquote><ul><li>王垠----<a target="_blank" rel="noopener" href="http://www.yinwang.org/blog-cn/2013/03/31/purely-functional">对函数式语言的误解</a></li><li>阮一峰----<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">函数式编程初探</a></li></ul></blockquote><p>最主要的区别：对函数的理解不同。比如在Java中用接口来模拟Lambda函数，而不是直接作为入参</p><h2>拉通主流程</h2><p>测试如下Shell</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x ./script/*.sh</span><br><span class="line"><span class="built_in">cd</span> ./script</span><br><span class="line"><span class="comment"># 前端编译器，端口为8080</span></span><br><span class="line">./function-registry.sh</span><br><span class="line"><span class="comment"># 用于生成文件到/tmp/function-registry</span></span><br><span class="line">.registerFunction.sh -n uppercaseStr -f <span class="string">&quot;s-&gt;s.toString().toUpperCase()&quot;</span> -i <span class="string">&#x27;String&#x27;</span> -o <span class="string">&#x27;String&#x27;</span> </span><br><span class="line"><span class="comment"># 函数Proxy，端口为9000</span></span><br><span class="line"><span class="comment"># 启动时讲通过FunctionProxyApplicationListener扫描spring.cloud.function.import</span></span><br><span class="line"><span class="comment"># 并读取 /tmp/function-registry 下的字节码</span></span><br><span class="line">./web.sh -f uppercaseStr -p 9000</span><br><span class="line"><span class="comment"># 客户端调用</span></span><br><span class="line">curl -H <span class="string">&quot;Content-Type: text/plain&quot;</span> -H <span class="string">&quot;Accept: text/plain&quot;</span> localhost:9000/uppercaseStr -d foo</span><br></pre></td></tr></table></figure><p>最终返回了FOO，说明就成功了</p><p>从上面也可以看出，现在的架构太复杂了，要专门开一个编译前端</p><h2>断点分析</h2><p>现在开始考验你的代码阅读量了，一般是按照“日志”，“断点”，“JMX”，“源码”进行分析的。</p><h4>编译流程分析</h4><p>此部分主要是</p><ul><li>对文本脚本进行组装为java源文件</li><li>并通过sun闭源工具(com.sun.tools.javac.api.JavacTool)生成class</li></ul><p>首先在下面打上断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.cloud.function.compiler.app.CompilerController#registerFunction</span><br></pre></td></tr></table></figure><p>通过分析<code>CompilerController</code>的REST路由，可以发现此部分是一个纯生成文件的模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JAX-RS(请求)</span><br><span class="line">	|</span><br><span class="line">CompilerController</span><br><span class="line">	|</span><br><span class="line">调用 ToolProvider.getSystemJavaCompiler() 进行 javac 源码</span><br><span class="line">	|</span><br><span class="line">存储Class文件到/tmp/function-registry</span><br></pre></td></tr></table></figure><p>此部门代码主要难点在于源码的拼装与检查，而编译是通过sun闭源的JavacTool中的javac实现(本文不分析)</p><p>我们甚至可以把在/tmp目录下的文件给拷贝出来</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /tmp/function-registry/functions/uppercase.fun ./uppercase.class</span><br></pre></td></tr></table></figure><p>用IDEA打开反编译的结果是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.cloud.function.compiler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.function.compiler.FunctionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UppercaseFunctionFactory</span> <span class="keyword">implements</span> <span class="title class_">FunctionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UppercaseFunctionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Function&lt;String, String&gt; <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Function)((Serializable)((var0) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> var0.toString().toUpperCase();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，通过<code>registerFunction.sh</code>发送请求后，在CompilerApplication平台在内部生成了Class文件，并保存为文件到<code>/tmp/function-registry</code>目录下。</p><h4>函数代理侧实现</h4><p>代理侧就是<code>./web.sh</code>中扫描<code>/tmp/function-registry</code>并注册为JAX-RS服务的过程</p><ul><li>定制了FunctionProxyApplicationListener: 监听了ApplicationPreparedEvent事件，当【上下文启动完成而没有刷新】时，触发此事件，并invoke其中的onApplicationEvent方法</li><li>通过<code>PropertySourcesBinder</code>实现对env中的K-V进行反序列化，并获取<code>spring.cloud.function.compile</code>与<code>spring.cloud.function.import</code>的value</li><li>通过<code>registerByteCodeLoadingProxy</code>构造单例Bean，key为function的名词，value为FunctionProxy的实现类</li></ul><p>由于web.sh涉及到很多变量，如何打上断点呢，可以在web.sh中加入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=y,address=5005</span><br></pre></td></tr></table></figure><p>接着配置IDE的remote，点击debug即可</p><p>由于现在不清楚JAX-RS的路由，无法快速上手，有个技巧就是在String中打上断点</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String toUpperCase() &#123;</span><br><span class="line"><span class="addition">+   return toUpperCase(Locale.getDefault());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过断点与curl，可以发现此框架是通过类似RxJava的框架折腾出来的，断点很难打，接着通过分析stacktrace，可以定位出通过url路由到function的方法为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.cloud.function.web.flux.FunctionHandlerMapping<span class="comment">#findFunctionForPost</span></span><br></pre></td></tr></table></figure><p>其中url与Function的映射处理为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T, R&gt; Function&lt;T, R&gt; <span class="title function_">lookupFunction</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (Function&lt;T, R&gt;) Stream.of(StringUtils.tokenizeToStringArray(name, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">    <span class="comment">// 从HashMap获取缓存</span></span><br><span class="line">    .map(functions::get)</span><br><span class="line">    .filter(f -&gt; f != <span class="literal">null</span>)</span><br><span class="line">    .reduce(<span class="literal">null</span>, (f1, f2) -&gt; f1 == <span class="literal">null</span> ? f2 : f1.andThen((Function)f2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并最终返回<code>FluxFunction&lt;ByteCodeLoadingFunction&gt;</code>，这里的FluxFunction类似于Akka的Actor，而内部的ByteCodeLoadingFunction是实现类，实现将同步函数转换为Flux响应式调用(断点难度也直线上升)</p><p>接着，通过一系列的<code>onNext</code>最终调用到<code>toUpperCase</code></p><p>总的来说，目前基本上就是玩具，暂时<strong>不建议花时间</strong>分析这个项目。</p><h2>自己实现FAAS</h2><p>总的来说，这次分析主流程并不难，因为我在以前的JMX文章中写过几行代码就能搞定动态执行JS等脚本的方法</p><p>下面是一个基于jsr223精简版FAAS实现</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FAAS</span>&#123;</span><br><span class="line">    Closure eval = &#123;script -&gt;</span><br><span class="line">        <span class="comment">//jsr223，此处内置了定制GroovyClassLoader</span></span><br><span class="line">        ScriptEngine engine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">&quot;groovy&quot;</span>);</span><br><span class="line">        Object eval = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eval = engine.eval(script)</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.memoize()<span class="comment">/*记忆化执行优化*/</span></span><br><span class="line">    <span class="comment">// 可以用etcd/zk/redis封装代替</span></span><br><span class="line">    <span class="keyword">def</span> map = [:]</span><br><span class="line">    <span class="type">void</span> reg(name,func)&#123;</span><br><span class="line">        map.put(name,func)</span><br><span class="line">    &#125;</span><br><span class="line">    Object run(funcName, Object... args)&#123;</span><br><span class="line">        <span class="keyword">def</span> func = map.get(funcName)</span><br><span class="line">        <span class="keyword">def</span> toRun = func + <span class="string">&#x27; &#x27;</span> + args?.join(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        println <span class="string">&quot;toRun = $toRun&quot;</span></span><br><span class="line">        eval toRun</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">FAAS faas = new FAAS()</span><br><span class="line">faas.reg(<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;&#123;a,b-&gt;a+b&#125;&#x27;</span>)</span><br><span class="line">assert faas.run(<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>) == <span class="number">3</span></span><br><span class="line">faas.reg(<span class="string">&#x27;uppercase&#x27;</span>,<span class="string">&#x27;&#123;s-&gt;s.toUpperCase()&#125;&#x27;</span>)</span><br><span class="line">assert faas.run(<span class="string">&#x27;uppercase&#x27;</span>,<span class="string">&#x27;&quot;Hell&quot;&#x27;</span>) == <span class="string">&#x27;HELL&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个基础上加入API网关、缓存优化、JIT优化、热部署等，可以比SpringCloud更快更好。</p><p>当然这个实现的并不安全，比如</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缺乏管理权限导致被rm</span></span><br><span class="line">faas.reg(<span class="string">&#x27;attack&#x27;</span>,<span class="string">&#x27;&#123;a-&gt; a.execute().text&#125;&#x27;</span>)</span><br><span class="line">faas.run(<span class="string">&#x27;attack&#x27;</span>,<span class="string">&#x27;&quot;rm -rf ~&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>就是代码任意执行漏洞，把整个机器给黑掉了</p><h2>总结</h2><p>通过对开源框架SpringCloudFunction进行分析，可以发现它目前只属于玩具级别</p><ul><li>语言上只支持纯Java8，还要精通Stream/Flux层层包装操作，无法大范围推广</li><li>此框架总体上就是重构了一个ScriptEngine，最底层甚至还是用文件进行共享，还不如二次封装ScriptEngine执行JVM语言(js/jruby/groovy/kotin)来的痛快</li><li>SpringCloudFunction不支持<strong>在方法中调用其它已注册的Function</strong>，无法复用代码，这点绝对是硬伤</li><li>引入了一堆学习成本较高的注解/接口来模拟【闭包】，这个是Java本身的缺点。动态代理+注解的形式，比不上动态语言的methodMissing</li><li>我认为更好的设计是使用JVM动态语言，后期我会以Groovy为例详细说下GroovyClassLoader</li><li>无论是Spring还是Groovy，都没解决一个重要问题: 无断点调试的IDE提供支撑</li></ul><p>总的来说，开源的FAAS尚不成熟，需要后期跟进。如果Spring项目更新了，本文后期也会更新。</p></div><div class="tags"><a class="tag-link" href="/tags/CodeReview/" rel="tag">CodeReview</a><a class="tag-link" href="/tags/FAAS/" rel="tag">FAAS</a><a class="tag-link" href="/tags/MicroService/" rel="tag">MicroService</a><a class="tag-link" href="/tags/Serverless/" rel="tag">Serverless</a><a class="tag-link" href="/tags/Spring/" rel="tag">Spring</a><a class="tag-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a><a class="tag-link" href="/tags/SpringCloud/" rel="tag">SpringCloud</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>