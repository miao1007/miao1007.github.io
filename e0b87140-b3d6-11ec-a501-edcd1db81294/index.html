<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="本书主要介绍了一款开源CPU的前端设计，对Silicon领域或者计算机组成有兴趣的可以看一看。它是一本非常有价值的书，建议投入一定时间去精读。"><meta name="keyword" content="Book,RISC-V"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>RISC-V处理器读书笔记</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://eu.umami.is/script.js" data-website-id="449a84b6-be9e-49de-a4cc-e0fa6fea1df9"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">RISC-V处理器读书笔记</div><div class="date no-print">2018-12-21 / modified at 2022-04-04 / 2.7k words / 10 mins</div><div class="content"><blockquote><span>️This article has been <strong>over 3 years</strong> since the last update.</span></blockquote><p>本书主要介绍了一款开源CPU的前端设计，对Silicon领域或者计算机组成有兴趣的可以看一看。它是一本非常有价值的书，建议投入一定时间去精读。</p><span id="more"></span><blockquote><p>注意: 本文作者并非硬件领域专家，而只是爱好者，因此本文是不可靠的。同时本文联想非常广泛，需要耐心阅读</p></blockquote><p>在阅读本书前，需要补充如下知识</p><h4>半导体制造流程</h4><p>半导体行业是一个门槛高，周期长的行业，从设计图纸到最终手机中的芯片，主要有如下流程</p><ul><li>前端(ASIC): 主要通过Verilog编写数字电路与高手编写模拟电路，最终通过EDA工具综合后生成网表(netlist)，与编译器一样，主要是通过描述生成未经过优化的AST</li><li>DFT: Design for test，用于为网表生成测试矢量，并加入测试电路</li><li>后端(COT): 对网表进行layout，布线，面积，Mask等设计（如果前端没做好，那么后端就要背锅了），最终生成GDS文件给Fabrication厂商</li><li>生产(MES): 通过Wafer/Bump/封装/Test等步骤，最终实现量产</li></ul><p>本书主要讲的是【前端流程】中的【数字电路设计】的【CPU】设计，是半导体领域中的理论图纸设计阶段</p><h4>时钟(CLK)</h4><p>众所周知，CPU需要时钟“跳动”才能“实时”工作。在芯片中，主要采用锁相环(Phase-locked loop)实现高频时钟生成（Clock generator）</p><ul><li>外频(主时钟): 通过晶振(<em>quartz crystal oscillator</em>)实现外部(比如主板)时钟生成，Quartz就是石英的意思，它有<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A3%93%E9%9B%BB%E6%95%88%E6%87%89">压电效应</a>，实现高精度震荡。</li><li>倍频: 通过芯片内部的<a target="_blank" rel="noopener" href="https://www.analog.com/en/analog-dialogue/articles/phase-locked-loop-pll-fundamentals.html">PLL</a>电路实现，实现将外频分割(dividing the frequency)为更细的频率，这个是借助模拟电路实现负反馈动态调节，本文玩不转就不讲了。</li></ul><p>最终时钟的总频率等于: 外频 * 倍频，我们在前端数字电路中只有理想的0和1，时钟跳动的快，工作速度上线就越高。当然在实际开发中，一般通过模拟器进行计算</p><ul><li>通过EDA工具实现模拟（Simulation），速度较慢</li><li>通过Emulator集群进行模拟，速度较快，但是机器非常贵</li><li>甚至在《我的世界》游戏中，受限于红石的时钟速度，导致电路速度很慢。</li></ul><p>引申到高层软件开发中，无论是异步Promise，事件驱动，还是消息队列，它内部一定<strong>有一个软件层次的时钟源(比如while或者第三方inoke)</strong>。在微服务作业中，我们有个叫做Quartz的开源定时任务，它本质也是定时发送时钟信号。翻看Flink的SourceFunction源码，它里面几乎都有一个while(true)实现采样生成数据源。</p><h4>Verilog</h4><p>Verilog是一种硬件描述语言，注意是对硬件的DSL描述(更类似Graphviz而不是Java)。编写者是数字电路Designer而不是Promgrammer，它虽然有for/if/always等高级实现，但是本质上silicon不可能实现for语句的，在专业开发中一般不推荐使用，而是用<code>assign</code>实现组合逻辑</p><p>在Mac下可以运行开源的iverilog进行编译Verilog文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install icarus-verilog</span><br></pre></td></tr></table></figure><p>或者使用Windows下的ModelSim/Eclipse进行查看</p><blockquote><p>对于新语言，我建议第一步先找个IDE拐棍，然后上源码进行入门 。看完上面后，再看一些<code>How CPU works</code>的视频加深理解</p></blockquote><h2>背景</h2><h4>基本术语</h4><ul><li>CPU: 目前的CPU在大部分情况下均指SOC，除了处理器本身还包括额外的IP/KGD(Known good die)</li><li>Instrcution: 指令，也就是“字节码”结构体，一般由<code>PC+操作数+参数</code>构成，被硬件进行Decode为AST并执行</li><li>ISA: 指令集架构(Instrcution Set Architecture/ˈɑrkɪˌtɛktʃɚ/)，主要有以x86为代表的CISC(Complex Instruction Set Computer)与R(educed)ISC，现在的嵌入式硬件主要是RISC架构</li><li>32与64位: 指通用寄存器的的宽度(越长越好)，而非指令长度(越短越好，甚至可以压缩)</li></ul><h4>关于ARM</h4><p>ARM主要有两种授权方式</p><table><thead><tr><th></th><th>纯IP核</th><th>ARM架构</th></tr></thead><tbody><tr><td>授权方式</td><td>起步价便宜，后续按片收费</td><td>起步价贵，买断，后续不收费</td></tr><tr><td>研发成本</td><td>低，把现成IP拿来用</td><td>高，耗时长，需要自己实现，可以看作自主研发</td></tr><tr><td>代表厂商</td><td>小厂商</td><td>Hisilicon等，一般用于高端产品</td></tr></tbody></table><p>目前大厂除了使用ARM架构，也会自研架构，但是问题还是在生态上</p><h4>关于RISC-V</h4><p>RISC-V(读作Risk-five)是一款Berkeley诞生开源硬件，本书的蜂鸟V200是经过业界工程师的专业设计，本书主要就是讲这个设计。作者的观点非常明确：适用于低功耗嵌入式场景中，尽可能设计简洁的指令与架构，而<strong>将复杂逻辑移动到编译器优化与库函数中</strong>，以降低硬件复杂度。</p><h2>流水线(Pipeline)</h2><p>本质上CPU也是一个解释器，在CPU中有流水线，与富士康的流水线一样，通过分配工作给专职模块，用空间换时间，尽可能实现每个时钟周期每个电路都在<strong>连续不断</strong>工作，提高面积利用效率。</p><p>before, 由于电路耦合在一起，需要60个单位的时间执行这个长指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INPUT -&gt; 逻辑组(60) -&gt; OUTPUT</span><br></pre></td></tr></table></figure><p>after，通过分工，实现20个周期即可完成计算（代价是面积更大/设计更复杂）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INPUT -&gt; 逻辑组(20) -&gt; 寄存器 -&gt; 逻辑组(20) -&gt; 寄存器 --&gt; 逻辑组(20) -&gt; OUTPUT</span><br></pre></td></tr></table></figure><p>每个逻辑计算需要时间，比如某个复杂逻辑耗时为60个时钟，通过3层流水线设计后，可以将耗时降低到20个时钟（理论计算），进而提高工作主频。</p><p>CPU流水线的设计思路与软件中的函数式编程(比如Flink/RxJava)是一样的，区别是CPU依赖时钟提供信号，而软件中抽象成了Batch/Stream概念；</p><p>下面以硬件，大数据与前端技术进行类比，它们都是将单个复杂任务<strong>分而治之</strong>，最终合并的设计。</p><table><thead><tr><th></th><th>CPU</th><th>分布式计算(以Flink为例)</th><th>Jenkins Pipeline</th></tr></thead><tbody><tr><td>数据源</td><td>时钟信号</td><td>SourceFunction(通过轮询poll实现，有Interval)</td><td>SCM Pull轮询</td></tr><tr><td>流水线</td><td>多级电路，提高计算主频</td><td>函数式编程，提高计算主频</td><td>CSP</td></tr><tr><td>代价</td><td>牺牲面积/分支预测</td><td>部署/合并难度</td><td>牺牲可读性</td></tr><tr><td>信道</td><td>Register</td><td>Akka MailBox</td><td>Curry</td></tr></tbody></table><p>软硬件的很多思想是融合贯通的，通过整理思考，可以提高自己知识的广度。很多前端的新技术，在硬件看来实际上就是炒冷饭（比如前端的<em>Prelink</em>预加载技术在硬件中就是分支预测）。学习完新的知识后，一定要总结固化，否则后期就学不动了。</p><h4>经典的RISC流水线(Classic RISC pipeline)</h4><p>步骤: Instruction fetch, decode, execution, memory access and write register back.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Fivestagespipeline.png/800px-Fivestagespipeline.png" alt="Fivestage pipelien"></p><h2>分支预测单元(Branch Prediction Unit)</h2><p>分支预测指在带条件的jump指令时，由于流水线中下一个指令到底跳转到哪还在计算中，猜不出接下来执行的指令是什么，如果此时暂停等待跳转结果，那么流水线周期就浪费了。对于此问题，可以使用分支预测（Brach Prediction）来判断下一步跳转的方向与地址，先执行了再说，万一猜对了就赚了。</p><p>我们取一个常见的<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/11227902/4016014">例子</a>，当我们在运行如下代码时，可以发现<code>Arrays.sort</code>是否进行对下面循环的速度有较大的影响，这是由于<code>data[c] &gt;= 128</code>是完全随机的，导致CPU无法预判下一步指令到底是什么，导致性能变差。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generate data</span></span><br><span class="line"><span class="type">int</span> arraySize = <span class="number">32768</span>;</span><br><span class="line"><span class="type">int</span> data[] = new <span class="type">int</span>[arraySize];</span><br><span class="line">Random rnd = new Random(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; arraySize; ++c)</span><br><span class="line">    data[c] = rnd.nextInt() % <span class="number">256</span>;</span><br><span class="line"><span class="comment">// !!! With this, the next loop runs faster</span></span><br><span class="line">Arrays.sort(data);</span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="type">long</span> start = System.nanoTime();</span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i)&#123;</span><br><span class="line">    <span class="comment">// Primary loop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; arraySize; ++c)&#123;</span><br><span class="line">        <span class="keyword">if</span> (data[c] &gt;= <span class="number">128</span>)</span><br><span class="line">            sum += data[c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println((System.nanoTime() - start) / <span class="number">1000000000.0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br></pre></td></tr></table></figure><p>分支预测有很多种类，比如</p><ul><li>默认认为不会跳转，直接执行下一个指令(最偷懒的实现)</li><li>默认执行PC数向下跳转的指令(优化for循环)</li><li>通过硬件HashMap动态维护缓存(高级处理器实现)</li></ul><p>而在RISC-V中，采用是较为简单的第二种预测，它默认循环中不会有复杂的判断</p><h4>分支预测优化</h4><p>通过上面的例子，可以发现在写高性能代码时也是有讲究的，特别是嵌入式软件(Java不涉及)</p><ul><li>高耗时任务中尽可能写连续的指令，不要用if等条件跳转语句(而换成HashJoin等类似方法)</li><li>模式匹配中，尽可能将可能性更高的条件放到前面</li><li>通过一些宏<code>#define likely(x)</code>帮助编译器生成更好的汇编代码(一般要开到O2)</li></ul><p>上述优化可能牺牲代码的<strong>可读性</strong>，因此分支预测优化仅限于核心模块</p><h4>敏捷项目的分支预测</h4><p>可能很多人都看过一张很著名的图，客户需要一个秋千，最终研发实际交付了一个轮胎。在软件开发中，传统的瀑布(waferfall)方法论是整体进行，此迭代速度较慢，因为一个周期下需要干一堆事情</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;------------------- 30days ------------------&gt;</span><br><span class="line">Require -&gt; Design -&gt; Implement -&gt; Test -&gt; Deploy</span><br></pre></td></tr></table></figure><p>对此，项目中引入了敏捷开发(Agile software development)，也就是将任务拆解为多次小迭代(small sprints)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;------------------- 30days ------------------&gt;</span><br><span class="line">&lt;--sprints1----sprints2---sprints3---sprints4-&gt;</span><br></pre></td></tr></table></figure><p>其实这里也是通过多级流水线与分支预测的结合，只不过这里的分支预测的实现不是电路，而是开发人员的项目管理经验。如果能力不够或者客户配合不够，就成了“假敏捷”了。<br>Agile并不能改善代码质量，核心还是在流水线的实现上</p><p>本书主要就是看了流水线的实现，其它的也看不懂，就写到这吧</p><h2>广告</h2><p>目前半导体行业极其缺少即懂业务又懂软件的开发，在各大厂裁员的情况下，半导体(<s>夕阳</s>)行业发展仍然非常迅速。如果你比较热爱持续改进，领域驱动设计，数据仓库建设，机器识别，Java等技术，有机会与制造专家合作设计功能，可以联系本人内推，加入国内第一IC厂商且有HC号。</p><h2>APPENDIX</h2><ul><li>使用JS实现的RISV与Linux: <a target="_blank" rel="noopener" href="https://bellard.org/jslinux/">https://bellard.org/jslinux/</a></li></ul></div><div class="tags"><a class="tag-link" href="/tags/Book/" rel="tag">Book</a><a class="tag-link" href="/tags/RISC-V/" rel="tag">RISC-V</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry.</a><span> All contents are not allowed to be redistributed or synthesised without an explicit permission.</span></div></footer></div></body></html>