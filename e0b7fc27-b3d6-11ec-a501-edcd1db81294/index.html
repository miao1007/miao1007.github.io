<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="Cold Startup Perfermance Improvement in Android"><meta name="keyword" content="Android,Performance"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>探究Android的冷启动优化</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://eu.umami.is/script.js" data-website-id="449a84b6-be9e-49de-a4cc-e0fa6fea1df9"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">探究Android的冷启动优化</div><div class="date no-print">2016-09-23 / modified at 2022-04-04 / 1.6k words / 6 mins</div><div class="content"><blockquote><span>️This article has been <strong>over 3 years</strong> since the last update.</span></blockquote><p>Cold Startup Perfermance Improvement in Android</p><span id="more"></span><p>本文依据平台如下</p><ul><li>机型: 魅蓝Note(高通615真八核/2G/1080P/4.4)</li><li>效果:1.1s -&gt; 0.7s(实际用户看到的假界面时间更短)</li><li>检测网站: <a target="_blank" rel="noopener" href="https://nimbledroid.com">https://nimbledroid.com</a>，是 @程序亦非猿 推荐的哦</li></ul><p>###1. 启动过程概述<br>在应用层，普通APP启动过程大致如下：</p><ol><li>加载Application<ul><li>静态代码段/构造函数</li><li>onCreate方法</li></ul></li><li>加载主Activity<ul><li>静态代码段/构造函数</li><li>消息队列第一次循环: onCreate，通过setContentview解析、加载xml</li><li>消息队列第二次循环: 被动地调用Choreographerd中的FrameDisplayEventReceiver的run()进行进行实际绘制</li></ul></li></ol><p>为了提高用户感知，我希望在主线程中执行的顺序如下(注意本流程不适用于插件化的App):</p><ol><li>尽快显示DecoView(Main Thread)(显示Theme中定义的ActionBar、背景等)</li><li>尽快显示xml中的静态View(Main Thread)(显示xml中的布局)</li><li>加载第三方黑盒SDK(Main Thread)</li><li>进行网络、图片等框架的构造(Main Thread)</li><li>通过框架进行业务请求(Gson/OkHttp等, Worker Thread)，并更新View</li></ol><blockquote><p>不建议在Application中初始化耗时任务，它将直接导致白屏</p></blockquote><p>###2. 用户感知优化<br>本部分可以提高上文1，2，3的用户体验</p><p>####2.1. 加载伪背景(0.1~0.2s)<br>DecoView的优先级比<code>setContentView</code>优先级更高，所以可以让DecoView显示一个伪启动背景界面，而不是白屏黑屏或者没界面甩锅给手机厂商，让用户感受到App正在加载是一个好的选择。</p><p>绘制一个App启动的草图，如下，一个是<code>Toolbar</code>，一个是<code>背景</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;layer-list</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:opacity=&quot;opaque&quot;</span><br><span class="line">&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;item android:gravity=&quot;top&quot;&gt;</span><br><span class="line">    &lt;shape android:shape=&quot;rectangle&quot;&gt;</span><br><span class="line">      &lt;solid android:color=&quot;#c8ececec&quot;/&gt;</span><br><span class="line">    &lt;/shape&gt;</span><br><span class="line">  &lt;/item&gt;</span><br><span class="line"></span><br><span class="line">  &lt;item</span><br><span class="line">      android:top=&quot;75dp&quot;</span><br><span class="line">      android:gravity=&quot;top&quot;&gt;</span><br><span class="line">    &lt;shape android:shape=&quot;rectangle&quot;&gt;</span><br><span class="line">      &lt;solid android:color=&quot;@color/primary&quot;/&gt;</span><br><span class="line">    &lt;/shape&gt;</span><br><span class="line">  &lt;/item&gt;</span><br><span class="line">&lt;/layer-list&gt;</span><br></pre></td></tr></table></figure><p>设置windowBackground</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;ColdStartTheme&quot; parent=&quot;APPTheme&quot;&gt;</span><br><span class="line">  &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/cold_start_bg&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>在启动时先加载了伪背景，然后才加载了真正的View元素</p><p><img src="http://upload-images.jianshu.io/upload_images/98641-c71947382ad8a99e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="伪背景加载 → 绘制完成View"></p><p>最终可以让用户觉得“提高”了0.1~0.2s的速度</p><blockquote><p>参考文章:</p><ol><li><a target="_blank" rel="noopener" href="http://saulmm.github.io/avoding-android-cold-starts">avoding-android-cold-starts</a></li><li><a target="_blank" rel="noopener" href="http://blog.waynell.com/2015/11/17/android-cold-start/">Android冷启动时间优化 - Wayne’s blog</a></li><li><a target="_blank" rel="noopener" href="https://github.com/DreaminginCodeZH/MaterialColdStart">GitHub - MaterialColdStart</a></li></ol></blockquote><blockquote><p>上述方案均不能很好处理状态栏，如果你使用Translucent，慎用</p></blockquote><p>####2.2. XML布局优化<br>此部分适用于解析、处理、绘制静态xml时的优化</p><p>xml布局优化是老生常谈的话题了，本质是减少无谓的绘制，网上面试宝典很多，这里就也不介绍了。解决方法如下：</p><ol><li>使用Include，Merge，viewStub简化布局</li><li>使用相对布局，layer-list降低树的层级</li><li>使用gone标签可以跳过绘制</li><li>被遮挡的view避免重复绘制</li></ol><blockquote><p>参考文章：</p><ol><li><a target="_blank" rel="noopener" href="http://stormzhang.com/android/2014/04/10/android-optimize-layout/">http://stormzhang.com/android/2014/04/10/android-optimize-layout/</a></li><li><a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0125/2356.html">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0125/2356.html</a></li></ol></blockquote><p>###3. 延后启动耗时框架<br>本部分不能压缩总时间，只是将耗时操作<strong>移动</strong>到后面而已，可以让白屏时间减少0.2~0.3s(取决于框架数量)。</p><p>####3.1. 实现方法<br>在onCreate()的最后，加入post操作，即可实现在绘制XmlView完成后再进行非UI的耗时操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().post(new Runnable() &#123;</span><br><span class="line">  @Override public void run() &#123;</span><br><span class="line">    //加载Applicaiton中的框架 40+ms</span><br><span class="line">    GlobalContext.startThirdFrameWork();</span><br><span class="line">    //构建网络框架 120ms</span><br><span class="line">    repo = SquareUtils.getRetrofit(URL).create(GithubService.class);</span><br><span class="line">    //进行ssl库的初始化请求 40+ms</span><br><span class="line">    onRefresh();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>####3.2. 实现原理</p><p>在XML被inflate后，需要通过<code>mDecoView.addView(xmlView)</code>进行添加。</p><p>addview最终调用<code>ViewRootImpl</code>的方法<code>scheduleTraversals()</code>，进行了消息队列的优先独占操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br></pre></td></tr></table></figure><p>接着调用<code>doTraversal()</code>释放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br></pre></td></tr></table></figure><p>SyncBarrier拥有消息队列的独占性，当使用<code>SyncBarrier</code>时，后面的消息将被阻塞，这样在主线程中就有更多的CPU时间可以分给WMS进行绘图了。在View绘制完成后，解除SyncBarrier后才会调用我们在上文Post的耗时框架加载任务，这样就实现了延迟加载。</p><p>###4. 多线程初始化</p><p>此部分真的可以压缩启动时间，但是对SDK线程安全有一定的要求，在黑盒SDK下容易出现问题</p><p>下文复用了OkHttp中的单例Worker线程池，节省了0.16s的启动时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SquareUtils.getDispatcher().executorService().execute(new Runnable() &#123;</span><br><span class="line">  @Override public void run() &#123;</span><br><span class="line">    Log.d(TAG, &quot;run: &quot; + System.currentTimeMillis());</span><br><span class="line">    //42ms</span><br><span class="line">    GlobalContext.startThirdFrameWork();</span><br><span class="line">    //120ms</span><br><span class="line">    repo = SquareUtils.getRetrofit(DanbooruAPI.KONACHAN).create(DanbooruAPI.class);</span><br><span class="line">    runOnUiThread(new Runnable() &#123;</span><br><span class="line">      @Override public void run() &#123;</span><br><span class="line">        //40ms</span><br><span class="line">        onRefresh();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，你就能比较充分利用你的真八核手机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主线程: 解析xml ----------addView(）--------| → 更新界面</span><br><span class="line">线程池: 初始化框架 --post(请求网络)---wait()--|</span><br></pre></td></tr></table></figure><p>###5. 混淆<br>经过测试，混淆在一定程度上可以提高速度，属于免费的性能提升，但是不是非常明显，大概只有100ms</p><blockquote><p>混淆后要记得测试</p></blockquote><p>###6. 总结<br>通过上述方法，可以压榨0.3~0.6s的时间，让用户能够更快的启动APP</p><p>本文例子: <a target="_blank" rel="noopener" href="https://github.com/miao1007/AnimeWallpaper">Github - AnimeWallpaper</a>，目前启动速度0.7s，求各位star!</p><p>###附录. Retrofit框架加载时间分析<br>Retrofit 在知乎上有人这样回答的，大意是<code>动态代理 == 反射 == 慢</code>，这就是典型的半桶水，不懂装懂。</p><p>通过对每个方法进行统计后，结果却是这样的：</p><p>retrofit构造(128ms)</p><ul><li>构造OkHttp:121ms, 其中javax.ssl构建耗时117ms，调用的是一个SSL遍历native操作，这个基本无法避免；缓存文件初始化1ms</li><li>构造GsonFactory 4ms: 主要是classloader加载的时间</li><li>其他 3ms</li></ul><p>retrofit访问网络前接口的拼装(42ms)</p><ul><li>RxJava框架: 12ms</li><li>动态代理: 1ms</li><li>Gson库: 27ms，主要进行反射操作</li><li>其他: 2ms</li></ul><p>随着SSL的普及，javax.ssl必然会被加载，这个100ms的时间在native中黑盒执行，很难避免，只能等手机ROM去优化喽；剩下的就是Gson的时间比较久，这个时间还是可以接受的。</p><blockquote><p>从上面也可以看出，与动态代理相关的时间，并没有想象中那么慢，不要看到反射就觉得慢，网络I/O请求与之后<strong>拼装</strong>的时间加起来，比动态代理要多的多</p></blockquote></div><div class="tags"><a class="tag-link" href="/tags/Android/" rel="tag">Android</a><a class="tag-link" href="/tags/Performance/" rel="tag">Performance</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" data-loading="lazy" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry.</a><span> All contents are not allowed to be redistributed or synthesised without an explicit permission.</span></div></footer></div></body></html>