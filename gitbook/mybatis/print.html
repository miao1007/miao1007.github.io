<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="dynamic-sql/index.html"><strong aria-hidden="true">2.</strong> 动态SQL与LanguageDriver</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dynamic-sql/ognl.html"><strong aria-hidden="true">2.1.</strong> OGNL的简介</a></li><li class="chapter-item expanded "><a href="dynamic-sql/xml-to-ast.html"><strong aria-hidden="true">2.2.</strong> XML如何转换为ASTNode</a></li><li class="chapter-item expanded "><a href="dynamic-sql/dynamic-proxy.html"><strong aria-hidden="true">2.3.</strong> 执行与动态代理</a></li></ol></li><li class="chapter-item expanded "><a href="mapping/index.html"><strong aria-hidden="true">3.</strong> Nested映射实现</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mapping/impl.html"><strong aria-hidden="true">3.1.</strong> 映射实现</a></li><li class="chapter-item expanded "><a href="mapping/merge-left-join.html"><strong aria-hidden="true">3.2.</strong> 如何合并LEFT-JOIN</a></li></ol></li><li class="chapter-item expanded "><a href="practice/index.html"><strong aria-hidden="true">4.</strong> Mybatis实践与SQL优化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practice/cache.html"><strong aria-hidden="true">4.1.</strong> L2 Cache</a></li><li class="chapter-item expanded "><a href="practice/multi-join.html"><strong aria-hidden="true">4.2.</strong> 多级联查</a></li><li class="chapter-item expanded "><a href="practice/parent-child-tree.html"><strong aria-hidden="true">4.3.</strong> Parent-child-id-tree</a></li><li class="chapter-item expanded "><a href="practice/transaction.html"><strong aria-hidden="true">4.4.</strong> 事务</a></li></ol></li><li class="chapter-item expanded "><a href="datebase/dds.html"><strong aria-hidden="true">5.</strong> 分布式数据库</a></li><li class="chapter-item expanded "><a href="datebase/procedure.html"><strong aria-hidden="true">6.</strong> 存储过程</a></li><li class="chapter-item expanded "><a href="datebase/index.html"><strong aria-hidden="true">7.</strong> 索引</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="datebase/bitmap-index.html"><strong aria-hidden="true">7.1.</strong> 位图索引</a></li><li class="chapter-item expanded "><a href="datebase/inverted-index.html"><strong aria-hidden="true">7.2.</strong> NoSQL与倒排索引</a></li></ol></li><li class="chapter-item expanded "><a href="other/sql-explain.html"><strong aria-hidden="true">8.</strong> 调试执行计划</a></li><li class="chapter-item expanded "><a href="datebase/transaction.html"><strong aria-hidden="true">9.</strong> 事务</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="datebase/transaction/readcommit.html"><strong aria-hidden="true">9.1.</strong> read commit</a></li><li class="chapter-item expanded "><a href="datebase/transaction/repeatable.html"><strong aria-hidden="true">9.2.</strong> Repeatable read</a></li><li class="chapter-item expanded "><a href="datebase/transaction/serializable.html"><strong aria-hidden="true">9.3.</strong> Serializable</a></li></ol></li><li class="chapter-item expanded "><a href="other/dws.html"><strong aria-hidden="true">10.</strong> DWS</a></li><li class="chapter-item expanded "><a href="other/ges.html"><strong aria-hidden="true">11.</strong> 图数据库</a></li><li class="chapter-item expanded "><a href="other/reference.html"><strong aria-hidden="true">12.</strong> 参考文献与Wiki</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>本书是对开源项目Mybatis分析系列文章</p>
<h4 id="面向读者"><a class="header" href="#面向读者">面向读者</a></h4>
<ul>
<li>了解Mybatis的基本用法，在Spring中的配置与SQL语法</li>
<li>了解DSL的基本概念</li>
</ul>
<h4 id="为读者提供了"><a class="header" href="#为读者提供了">为读者提供了</a></h4>
<p>Mybatis通过XML定义了如何“查询”与如何“显示”的DSL，所以叫做半自动化ORM框架。本书将重点介绍这两点</p>
<ul>
<li>Mybatis如何执行动态SQL</li>
<li>Mybatis如何实现ResultMapping</li>
<li>Mybatis各种插件与生成器介绍</li>
</ul>
<h4 id="预先准备"><a class="header" href="#预先准备">预先准备</a></h4>
<p>在阅读本书前，需要导入如下源码，并使用IDE打开此项目</p>
<pre><code class="language-sh">git clone https://github.com/mybatis/mybatis-3.git
# 由于mybatis最新为快照，我们选择稳定版本
git checkout mybatis-3.4.6
mvn clean package -Dmaven.test.skip=true
</code></pre>
<h4 id="技术交流"><a class="header" href="#技术交流">技术交流</a></h4>
<p>邮件: <a href="mailto:miao1007@gmail.com">miao1007@gmail.com</a></p>
<h4 id="license"><a class="header" href="#license">license</a></h4>
<p>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="动态sql"><a class="header" href="#动态sql">动态SQL</a></h1>
<h2 id="language-driver"><a class="header" href="#language-driver">Language Driver</a></h2>
<p>在MyBatis中，通过<code>LanguageDriver</code>担任Interceptor的工作，它是一个DSL解释器，如果这点你明白了，后面就很容易理解。它的主要流程如下</p>
<pre><code>xml--(parser)--&gt;AST-(apply)--&gt;SQL
</code></pre>
<h2 id="xmllanguagedriver"><a class="header" href="#xmllanguagedriver">XMLLanguageDriver</a></h2>
<p>在默认实现中，Mybatis首先在如下位置反序列化XML为MixedSqlNode，这里可以看作为一个S表达式</p>
<pre><code class="language-java">org.apache.ibatis.scripting.xmltags.XMLLanguageDriver#createSqlSource
</code></pre>
<p>MixedSqlNode内部含有一个SqlNode数组，通过深度遍历执行<code>apply</code>调用OGNL解析其中的text</p>
<pre><code>org.apache.ibatis.scripting.xmltags.DynamicSqlSource#getBoundSql
</code></pre>
<p>其中<code>$</code>将被替换为字符串，而<code>#</code>将作为JDBC参数，供原生JDBC使用</p>
<h2 id="定制languagedriver"><a class="header" href="#定制languagedriver">定制LanguageDriver</a></h2>
<p>当你认为XML的表达能力较弱，重复代码过多时，可以考虑对<code>LanguageDriver</code>进行定制</p>
<ul>
<li>开发Groovy-based的mybatis-dsl，提高表达效率</li>
<li>开发基于其它模版引擎的dsl</li>
<li>使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpringEL</a>替换原有采用Ognl的ExpressionEvaluator，这样进行<code>&lt;if&gt;</code>判断时更加简洁</li>
</ul>
<p>但是目前研究LanguageDriver的文档并不多，后续想要提高MyBatis效率，就靠这里了</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ognl的简介"><a class="header" href="#ognl的简介">OGNL的简介</a></h1>
<p><a href="https://en.wikipedia.org/wiki/OGNL">OGNL</a>是一种表达式语言，用于获取对象的属性或者调用方法。它在Mybatis/Struts（以及漏洞）等涉及到模版的场景中经常使用。</p>
<p>语法这里就不讲了，需要注意的是</p>
<ul>
<li>OGNL大部分场景是取属性，不建议new对象</li>
<li>OGNL不支持类似Groovy的safe-null，比如<code>user?.role?.name</code>这样的问号表达式，而SpingEL是支持的</li>
<li>OGNL定位是XML中的胶水，调试方便程度肯定不如Java，因此尽可能不折腾</li>
</ul>
<h4 id="从断点开始"><a class="header" href="#从断点开始">从断点开始</a></h4>
<p>在Mybatis中封装了如下的OGNL，测试用例如下</p>
<pre><code class="language-java">Object a = OgnlCache.getValue(&quot;a + 1&quot;, Collections.singletonMap(&quot;a&quot;, 10));
System.out.println(&quot;a = &quot; + a);//返回 11
</code></pre>
<blockquote>
<p>只要在<code>OgnlCache.getValue</code>中打上了断点，所有的动态SQL生成过程均可以看见细节</p>
</blockquote>
<p>有了上面的断点处，你就可以明白平时很多可能含糊的位置了</p>
<p>假如你在XML中写了如下的语句，是否会有疑问需要<code>!= null</code>这个语句呢</p>
<pre><code class="language-xml">&lt;if test=&quot;example != null&quot;&gt;
</code></pre>
<p>这时就可以断点，可以发现<code>OgnlCache</code>更上一层的调用栈是</p>
<pre><code class="language-java">org.apache.ibatis.scripting.xmltags.ExpressionEvaluator#evaluateBoolean
</code></pre>
<p>通过阅读这里的代码，可以发现只要为0或者空，就返回false（类似于Groovy的asBoolean），因此在这里就彻底搞懂了<code>test</code>标签的底层含义，你的xml可以简写为<code>test=&quot;example&quot;</code></p>
<blockquote>
<p>OGNL非常方便扩展DSL，特别是在进行自定义注解时，可以帮助开发者节约很多时间</p>
</blockquote>
<h2 id="ognl底层执行过程"><a class="header" href="#ognl底层执行过程">OGNL底层执行过程</a></h2>
<p>OGNL与其它语言一样，也是从字符串到AST，到最后基于上下文的便利实现的，举个例子</p>
<pre><code class="language-java">(3 + (4 * 5)) - (a / 4)
</code></pre>
<p>将被转换为如下的树</p>
<pre><code>(- (+ 3 (* 4 5) ) (/ a 4))
</code></pre>
<p>然后调用如下方法进行树的深度遍历</p>
<pre><code class="language-java">ognl.SimpleNode#getValue
</code></pre>
<p>最终返回结果</p>
<blockquote>
<p>相关过程比较复杂，可以看更专业的<a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter">怎样写一个解释器</a></p>
</blockquote>
<h2 id="线程安全"><a class="header" href="#线程安全">线程安全</a></h2>
<p>Mybatis内部使用了一个<code>ConcurrentHashMap</code>作为AST的cache，OGNL的执行本身是各自的上下文，是线程安全的。</p>
<h2 id="ognl相关暗坑"><a class="header" href="#ognl相关暗坑">OGNL相关暗坑</a></h2>
<h4 id="ognl与map"><a class="header" href="#ognl与map">OGNL与Map</a></h4>
<p>在ognl中，假如你的map是{'aaa.bbb.ccc' =&gt; v1}这样的，那么在求值时，一定要写</p>
<pre><code>map.get('aaa.bbb.ccc')
</code></pre>
<p>而不是</p>
<pre><code>map.aaa.bbb.ccc
</code></pre>
<blockquote>
<p>通过OGNL的ObjectAcessor可以了解到解析详情，此外<code>StrictMap</code>也专门限制了这种歧义</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="xml如何转换为astnode"><a class="header" href="#xml如何转换为astnode">XML如何转换为ASTNode</a></h1>
<p>在上面的ONGL中，讲到了如下的方法是所有动态sql的执行</p>
<p>我们先挑一个简单的例子</p>
<pre><code class="language-xml"> &lt;select id=&quot;getParentWithComplex&quot; resultMap=&quot;personMapComplex&quot;&gt;
     SELECT id, firstName, lastName, parent_id, parent_firstName, parent_lastName
     &lt;if test=&quot;1+1&quot;&gt;
         FROM ${'Person' + ''}
     &lt;/if&gt;
     WHERE firstName = #{firstName,jdbcType=VARCHAR}
     AND lastName = #{lastName,jdbcType=VARCHAR}
     LIMIT 1
&lt;/select&gt;
</code></pre>
<p>它将被构造为<code>MixedSqlNode</code>，<code>MixedSqlNode</code>就是类似S表达式的数组结构</p>
<pre><code class="language-java">// MixedSqlNode
public class MixedSqlNode implements SqlNode {
  private final List&lt;SqlNode&gt; contents;
}
</code></pre>
<p>在如下位置通过XML反序列化，一个用Map维护Tag的Pattern Match</p>
<pre><code class="language-java">org.apache.ibatis.scripting.xmltags.XMLScriptBuilder#parseDynamicTags
</code></pre>
<p>最终样式为</p>
<pre><code>(text (if test text) text)
</code></pre>
<p>在执行时将从左到右进行深度优先遍历</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="动态代理"><a class="header" href="#动态代理">动态代理</a></h1>
<p>在MyBatis中，通过<a href="https://www.baeldung.com/java-dynamic-proxies">动态代理</a>实现生成Mapper的实现类。</p>
<p>构造位置</p>
<pre><code>org.apache.ibatis.binding.MapperRegistry#getMapper
</code></pre>
<p>动态代理的最终实现在这里，它是对JDBC的encapsule</p>
<pre><code class="language-java">org.apache.ibatis.binding.MapperMethod#execute
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="nested映射实现"><a class="header" href="#nested映射实现">Nested映射实现</a></h1>
<p>本部分只分析嵌套映射的实现</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="映射实现"><a class="header" href="#映射实现">映射实现</a></h1>
<p>多级映射实现</p>
<h4 id="导入源码"><a class="header" href="#导入源码">导入源码</a></h4>
<pre><code class="language-sh">git clone https://github.com/mybatis/mybatis-3.git
# 由于mybatis最新为快照，我们选择稳定版本
git checkout mybatis-3.4.6
mvn clean package -Dmaven.test.skip=true
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mybatis如何合并left-join"><a class="header" href="#mybatis如何合并left-join">MyBatis如何合并LEFT-JOIN</a></h1>
<p>首先举一个例子，假如学生有很多课程，在Mybatis中最常见的写法应该是这样的</p>
<pre><code class="language-xml">&lt;select&gt;
    select 
    	stu.id as id,
    	stu.name as name
    	les.id as les_id,
    	les.name as les_name
    from
    	student stu 
    left join lesson les stu.id = les.stu_id
&lt;/select&gt;
</code></pre>
<p>这种场景就是一对多的查询，我们一般用LEFT JOIN来查。假如LEFT JOIN 查询了如下的结果</p>
<table><thead><tr><th>id</th><th>name</th><th>les_id</th><th>les_name</th></tr></thead><tbody>
<tr><td>1</td><td>tony</td><td>11</td><td>php</td></tr>
<tr><td>1</td><td>tony</td><td>12</td><td>cpp</td></tr>
<tr><td>1</td><td>tony</td><td>13</td><td>java</td></tr>
</tbody></table>
<p>你肯定不希望有三个重复ID的Student</p>
<pre><code class="language-js">var arr = [
    {id: '1', name: 'tony',les_id: '11', les_name: &quot;php&quot;},
    {id: '1', name: 'tony',les_id: '12', les_name: &quot;cpp&quot;},
    {id: '1', name: 'tony',les_id: '13', les_name: &quot;java&quot;}
]
</code></pre>
<p>而是希望返回的是一个如下的对象</p>
<pre><code class="language-js">{
    id: '1',
    name: 'tony',
    lessons: [
        {id:11,name:'php'},
        {id:12,name:'cpp'},
        {id:13,name:'java'},
    ]
}
</code></pre>
<p>这时就要靠MyBatis神奇的ResultMap框架了，其实这个就是函数式编程中常见的GroupBy操作</p>
<h2 id="分析"><a class="header" href="#分析">分析</a></h2>
<p>在Mybatis的多级映射中，使用Map作为GroupBy的依据，断点如下</p>
<pre><code class="language-java">org.apache.ibatis.executor.resultset.DefaultResultSetHandler#applyNestedResultMappings
</code></pre>
<p>其中重点在如下位置加上断点并对比<code>combinedKey</code>的变化情况</p>
<pre><code class="language-java">final CacheKey rowKey = createRowKey(nestedResultMap, rsw, columnPrefix);
final CacheKey combinedKey = combineKeys(rowKey, parentRowKey);
Object rowValue = nestedResultObjects.get(combinedKey);
</code></pre>
<h2 id="更多层嵌套如何写"><a class="header" href="#更多层嵌套如何写">更多层嵌套如何写？</a></h2>
<p>假如有如下Student对象，LIST对象中嵌入了课程detail对象，那么这个时候如何写SQL的自动映射呢？</p>
<pre><code class="language-java">{
 	id: 1,
    name: 'yoki',
    lessons: [{
        id: '11',
        name: 'math',
        detail:{
            time: 40,
            hard: 'middile'
        }
    }]
}
</code></pre>
<p>假如我们使用<code>columnPrefix</code>，那么对应的映射为</p>
<pre><code class="language-xml">&lt;resultMap type=&quot;xxxx&quot; id=&quot;vstudentMap&quot; extend=&quot;studentMap&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
    &lt;result property=&quot;name&quot; column=&quot;name&quot; /&gt;
    &lt;collection property=&quot;lessons&quot; resultMap=&quot;lessonMap&quot;columnPrefix=&quot;les_&quot; /&gt;
&lt;/resultMap&gt;
&lt;resultMap type=&quot;xxxx&quot; id=&quot;lessonMap&quot;&gt;
    &lt;id property=&quot;time&quot; column=&quot;time&quot; /&gt;
    &lt;result property=&quot;hard&quot; column=&quot;hard&quot; /&gt;
    &lt;association property=&quot;detail&quot; columnPrefix=&quot;ldt_&quot; resultMap=&quot;resultMap&quot;/&gt;
&lt;/resultMap&gt;
</code></pre>
<p>此刻关键就在于加入正确的前缀</p>
<pre><code class="language-sql">select 
	stu.id,
	stu.name,
	les.id as les_id,
	les.name as les_name,
	-- 此次前缀要加两次，否则prefix将无法生效
	ldt.time as les_ldt_time,
	ldt.hard as les_ldt_hard
from
	student stu
left join lesson les on stu.lesson_id = les.id
left join lesson_dtl ldt on les.detail_id = ldt.id
</code></pre>
<p>上面的两次前缀如果没有加的话，那么将返回null，这个在MyBatis的官网上与StackOverflow上都没有的例子，这种方法能够完整复与继承用各种resultMap，对代码维护性是最佳的</p>
<p>（很多人不会这样写，就只能拷代码了，引入重复性）</p>
<h2 id="如何返回完整的分页"><a class="header" href="#如何返回完整的分页">如何返回完整的分页</a></h2>
<p>从上面可以发现，假如当前业务有分页需求，你想查10条数据</p>
<pre><code class="language-sql">select * from (
	select temp.*, rownum as row_id from(
    	select 
            stu.id,
            stu.name,
            les.id as les_id,
            les.name as les_name,
            ldt.time as les_ldt_time,
            ldt.hard as les_ldt_hard
        from
            student stu
        left join lesson les on stu.lesson_id = les.id
        left join lesson_dtl ldt on les.detail_id = ldt.id
    ) where rownum &lt;= 20
) where row_id &gt; 10;
</code></pre>
<p>上面的SQL，看起来是没有问题的，网上大部分也是这种场景，但是这种可以说与鸡肋差不多</p>
<ul>
<li>单表的分页一般通过Mybatis各种开源插件即可实现</li>
<li>而多表分页，一般涉及到JOIN查询，就会有一对多，由于rownum被MyBatis软分组合并影响，导致最终结果会变少，导致在查看数据时前台每次分页的size会不断变化，用户体验较差</li>
</ul>
<p>你可能需要用临时表这样写</p>
<pre><code class="language-sql">with stu_view as (
	select * from (
        select temp.*, rownum as row_id from(
            select 
                DISTINCT stu.id
            from
                student stu
            left join lesson les on stu.lesson_id = les.id
            left join lesson_dtl ldt on les.detail_id = ldt.id
            order by stu.id
        ) where rownum &lt;= 20
    ) where row_id &gt; 10;
)
select 
    stu.id,
    stu.name,
    les.id as les_id,
    les.name as les_name,
    ldt.time as les_ldt_time,
    ldt.hard as les_ldt_hard
from
    student stu
left join lesson les on stu.lesson_id = les.id
left join lesson_dtl ldt on les.detail_id = ldt.id
where stu.id in (select stu_view.id from stu_view)
order by stu.id
</code></pre>
<p>这样写性能明显变差了，但是也是没有办法的办法，因为你查出的并不是每次10条，所以统计去重后的count就要代入条件计算，后面还要再left join一次。虽然慢了，但是普通10行或者30行的分页应该是够了</p>
<ul>
<li>distinct: 对重复字段进行过滤，如果你在这里的<code>DISTINCT</code>后面引入了LEFT JOIN的表字段，那么在一对多的情况下，<code>DISTINCT</code>将不会生效</li>
<li>order by id: 保证id是按照顺序提取出符合条件的前N条</li>
<li>where stu.id in: 由于这里的id是存储在B-Tree中的连续字段，因此实际用in并不会慢，相反如果这里使用了INNER JOIN的HASH INDEX，速度反而变得更慢</li>
</ul>
<h2 id="如何写动态sql"><a class="header" href="#如何写动态sql">如何写动态SQL</a></h2>
<p>如下是我在进行复杂查询时， 涉及到分页与报表导出的SQL例子</p>
<pre><code class="language-xml">&lt;select id=&quot;selectByCondition&quot;&gt;
    &lt;if test=&quot;!param.export&quot;&gt;
    with stu_view as (
        select * from (
            select temp.*, rownum as row_id from(
                select 
                    DISTINCT stu.id
                from
                    student stu
                left join lesson les on stu.lesson_id = les.id
                left join lesson_dtl ldt on les.detail_id = ldt.id
        		&lt;include refid=&quot;whereclause&quot;&gt;
                order by stu.id
            ) where rownum ;lt= 20
        ) where row_id ;gt 10;
    )
    &lt;/if&gt;
    select 
        stu.id,
        stu.name,
        les.id as les_id,
        les.name as les_name,
        ldt.time as les_ldt_time,
        ldt.hard as les_ldt_hard
    from
        student stu
    left join lesson les on stu.lesson_id = les.id
    left join lesson_dtl ldt on les.detail_id = ldt.id
    &lt;if test=&quot;!param.export&quot;&gt;where stu.id in (select stu_view.id from stu_view)&lt;/if&gt;
    &lt;if test=&quot;param.export&quot;&gt;&lt;include refid=&quot;whereclause&quot;&gt;&lt;/if&gt;
    order by stu.id
&lt;/select&gt;
</code></pre>
<p>充分使用if标签，避免维护多个sql，这样基本上就玩到MyBatis的较高水平了</p>
<p>更加推荐的方案是，使用metabase、redash等BI工具进行查询，配合jinja模版引擎实现</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mybatis实践"><a class="header" href="#mybatis实践">Mybatis实践</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="l2-cache"><a class="header" href="#l2-cache">L2 Cache</a></h2>
<h3 id="如何启动l2-cachehow-to-enable-l2-cache"><a class="header" href="#如何启动l2-cachehow-to-enable-l2-cache">如何启动L2 Cache(How to enable L2 cache)</a></h3>
<p>See at http://www.mybatis.org/mybatis-3/sqlmap-xml.html#cache</p>
<h3 id="cache是如何工作的how-cache-works"><a class="header" href="#cache是如何工作的how-cache-works">Cache是如何工作的(How cache works)</a></h3>
<h4 id="构造步骤construct-steps"><a class="header" href="#构造步骤construct-steps">构造步骤(Construct Steps)</a></h4>
<p>We can read source code here </p>
<pre><code class="language-java">// Impl: PERPETUAL(永久): org.apache.ibatis.cache.impl.PerpetualCache
// Decorator: LRU(最近使用): org.apache.ibatis.cache.decorators.LruCache
org.apache.ibatis.builder.MapperBuilderAssistant#useNewCache
</code></pre>
<ol>
<li>Construct a new instance of <code>cache</code> using reflection.</li>
<li>Set individual properties using SystemMetaObject.</li>
<li>Call org.apache.ibatis.builder.InitializingObject#initialize for customization[/ˌkʌstəmɪ'zeʃən/], see <a href="https://github.com/mybatis/mybatis-3/issues/816">#816</a></li>
<li>Add decorator cache chains by <code>build</code></li>
<li>Put the <code>cache</code> into a <code>Map&lt;NameSpace, Cache&gt;</code></li>
</ol>
<p>If your are using a standard cache, your will get</p>
<pre><code>// see org.apache.ibatis.annotations.CacheNamespace
// It may **produce dirty data** on distributed scopes.
SynchronizedCache -&gt; LoggingCache -&gt; LruCache -&gt; PerpetualCache
</code></pre>
<p>And if you are using a customized cache, you will get</p>
<pre><code>LoggingCache -&gt; CustomCache
</code></pre>
<blockquote>
<p>If you want to get a log, please override <code>getId</code>  and return the id with the mapper's namespace.</p>
</blockquote>
<h4 id="cache流程process-flow"><a class="header" href="#cache流程process-flow">Cache流程(Process flow)</a></h4>
<p>By default(<code>cacheEnabled=true</code>), the framework will create a CachingExecutor[/ɪg'zekjʊtə/] as a proxy(which is called the second level cache) for the database executor. </p>
<pre><code class="language-java">// Query -&gt; CachingExecutor -&gt; SimpleExecutor
org.apache.ibatis.session.Configuration#newExecutor
</code></pre>
<p>There is a brief process flow digram demonstrates how Mybatis caches when a query comes.</p>
<ul>
<li>L1 cache implementation: Java HashMap, aka LocalCache.</li>
<li>L2 cache implementation: Redis. <code>HGET</code> and <code>HSET</code> are commands for Redis <a href="https://redis.io/commands#hash">hash</a> data type. And id is the namespace of mapper.</li>
</ul>
<pre><code class="language-mermaid">sequenceDiagram
  	Query--&gt;&gt;CacheExecutor: HGET id cacheKey?
	CacheExecutor--&gt;&gt; SimpleExecutor: HashMap.get(cacheKey)
	SimpleExecutor --&gt;&gt; DB: select * form TABLE
	activate DB
    DB --&gt;&gt; SimpleExecutor: value
    deactivate DB
    CacheExecutor --&gt;&gt; SimpleExecutor: HashMap.put(cacheKey, value)
    SimpleExecutor --&gt;&gt; CacheExecutor: value
    Query --&gt;&gt;CacheExecutor: HSET id cacheKey value
    CacheExecutor--&gt;&gt;Query: value  	




</code></pre>
<p>For more information(distribute redis lock), read my gitbook for <a href="practice/%7B%7Bbook.homePage%7D%7D">redis</a></p>
<h3 id="事务transactionalcachemanager"><a class="header" href="#事务transactionalcachemanager">事务(TransactionalCacheManager)</a></h3>
<p>In L2 cache, <strong>only <code>put</code>, <code>get</code> and <code>clear</code> will be called</strong> despite all methods of interface are implemented.</p>
<h3 id="改进redis缓存redis-caching-improvement"><a class="header" href="#改进redis缓存redis-caching-improvement">改进Redis缓存(Redis caching Improvement)</a></h3>
<p>In addition to LinkedHashMap-based LRU cache, We also use Redis for distributed caching. Of course, there is already a Jedis-based open source project called <a href="https://github.com/mybatis/redis-cache">Redis-cache</a></p>
<p>However, there are some improvements to be done.</p>
<ul>
<li>it creates a pool on each construction, singleton instance is better.</li>
<li>Doesn't support Redis <a href="https://redis.io/topics/sentinel">sentinel</a> mode.</li>
<li>JDK-based Serializer is <a href="https://developers.slashdot.org/story/18/05/26/0520227/oracle-calls-java-serialization-a-horrible-mistake-plans-to-dump-it">risky</a> when deployed on different platform. JSON, XML or <a href="https://developer.android.com/reference/android/os/Parcelable">Parcelable</a> is preferred.</li>
<li>Lack of namespace for Redis. <code>cache:com.xx.mapper</code> is more maintainable and debuggabe when you <code>DEL</code> keys by prefix.</li>
</ul>
<p>Your need to fork the project and create your own cache.</p>
<h3 id="handle-mutiple-table-with-cache-ref"><a class="header" href="#handle-mutiple-table-with-cache-ref">Handle mutiple table with cache-ref</a></h3>
<p>If there is a student with lessons, two mapper turns cache on.</p>
<pre><code class="language-xml">&lt;!-- com.xxx.lessonMapper --&gt;
&lt;mapper namespace=&quot;com.xxx.lessonMapper&quot;&gt;
    &lt;cache type=&quot;REDIS&quot;/&gt;
    &lt;select id=&quot;selectLessonWithStudent&quot;&gt;
        SELECT s.name, s.age, l.name as L_NAME 
        from student s left join lesson l
        on s.lesson_id = l.id
    &lt;/select&gt;
&lt;/mapper&gt;
&lt;!-- com.xxx.studentMapper --&gt;
&lt;mapper namespace=&quot;com.xxx.studentMapper&quot;&gt;
    &lt;cache type=&quot;REDIS&quot;/&gt;
    &lt;update&gt;
    UPDATE student set name= #name
    &lt;/update&gt;
&lt;/mapper&gt;

</code></pre>
<p>when student's name is updated, the result of  <code>selectLessonWithStudent</code> is not flushed, and dirty data will be fetched.</p>
<p>fixed by shared namespace</p>
<pre><code class="language-diff">&lt;!-- com.xxx.lessonMapper --&gt;
&lt;mapper namespace=&quot;com.xxx.lessonMapper&quot;&gt;
-    &lt;cache type=&quot;REDIS&quot;/&gt;
+    &lt;cache-ref namespace=&quot;com.xxx.studentMapper&quot;/&gt;
    &lt;select id=&quot;selectLessonWithStudent&quot;&gt;
        SELECT s.name, s.age, l.name as L_NAME 
        from student s left join lesson l
        on s.lesson_id = l.id
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>When data in lesson or student updates, <code>flushCache</code> will be called, and <strong>ALL</strong> cache in the namespace will be flushed, <strong>no update by special cacheKey</strong>, so the hit ratio will be explicitly lower. </p>
<pre><code class="language-java">// ALL cache in the same namespace will be flushed.
org.apache.ibatis.executor.CachingExecutor#flushCacheIfRequired
</code></pre>
<p>Concuclusion</p>
<ul>
<li>It's better to use cache on the only one table.</li>
<li>When using cache with joined tables, use cache-ref to share namespace or turn cache off  mannually. </li>
<li>It's better to handle cache in business code and find your own cachekey(eg: put in Elastic as a document)</li>
</ul>
<p>Alternative performance improvement</p>
<ul>
<li>
<p>analyse SQL AST in interceptor and flush only changed changed -&gt; It's too complex.</p>
</li>
<li>
<p>Do static analyse on XML and SQL -&gt;  It's too complex too.</p>
</li>
</ul>
<h2 id="appendix"><a class="header" href="#appendix">APPENDIX</a></h2>
<h4 id="voiding-the-risk-of-l1-cache"><a class="header" href="#voiding-the-risk-of-l1-cache">Voiding the risk of L1 Cache</a></h4>
<p>In most situations, turning L1 cache on is risky if you have <strong>no control over</strong> the project. The two cached results may refer to the same pointer(eg: repeat queries in a for loop).</p>
<pre><code class="language-java">// eg: in a service
List&lt;Student&gt; list1 = mapper.select();
// do modification
list1.get(0).setName(&quot;Modified&quot;);
// get dirty data from cache
List&lt;Student&gt; list2 = mapper.select();
assert(list1 == list2)
</code></pre>
<p>to fix the problem</p>
<ul>
<li>
<p>avoid same query in <code>@Transactional</code>, and always remove repeat queries.</p>
</li>
<li>
<p>turn L1 cache off(see  issue #482) and directly hit the DB.</p>
</li>
</ul>
<pre><code class="language-xml">&lt;settings&gt;
  &lt;!-- will flush the hashMap after the query in BaseExecutor. --&gt;
  &lt;setting name=&quot;localCacheScope&quot; value=&quot;STATEMENT&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><p>本文是多级查询（例如下图）的Mybatis设计思路分享。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/98641-2daece50516e51e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="某宝商品筛选框" /></p>
<ul>
<li><del>如何让前台生成上面的筛选框</del>(todo)</li>
<li>如何实现前端传入筛选条件后端自动拼接SQL</li>
</ul>
<p>关键词: <code>mybatis</code>, <code>restful</code></p>
<h2 id="1-需求分析"><a class="header" href="#1-需求分析">1. 需求分析</a></h2>
<p>在开发中，经常会遇到筛选框等复杂查询，但是每次开发效率都不是很高。</p>
<h4 id="11-现有方案与不足"><a class="header" href="#11-现有方案与不足">1.1. 现有方案与不足</a></h4>
<ul>
<li>Elastic缺少实时性，需要搭建MQ，搭建Elastic集群，牵一发动全身。它更加适用于保存计算结果后的数据仓库(DW)</li>
<li>对于单表查询，可以用开源的通用Mapper方案</li>
<li>对于多表查询，除了在mapper.xml 中加入大量硬编码或者代码生成器的产物，似乎也并没有什么好的办法。此外前后台接口也是一锅粥，需要定制VO对象，同时开发人员良莠不齐，在xml中拷贝了一大堆代码，后期改动成本非常高。</li>
</ul>
<p>举个例子，有下面的对象，分别是学生，课程与分数</p>
<pre><code class="language-java">@Table(name = &quot;STUDENT&quot;)
public class Student{
    public Integer id;
    public String name;
    public List&lt;Lesson&gt; lessons;
}
@Table(name = &quot;LESSON&quot;)
public class Lesson{
    public Integer id;
    public Integer studentId;
    public String name;
    public List&lt;Grade&gt; grades;
}
@Table(name = &quot;GRADE&quot;)
publib class Grade{
    public Integer id;
    public Integer lessonId;
    public String rate;
}
</code></pre>
<p>对应的SQL如下</p>
<pre><code class="language-sql">SELECT 
	s.id,
	s.name,
	l.id as l_id,
	l.name as l_name,
	g.rate
FROM student s
LEFT JOIN LESSON l on s.id = l.student_id
LEFT JOIN GRADE g on l.id = g.lesson_id
</code></pre>
<p>假如此刻你的需求是做一个筛选网站，比如筛选出“选择了数学课，而且数学分数在60-70之间”的所有学生，而且这个查询需要前台动态拼接，不希望写额外的VO对象，那么应该如何设计呢？</p>
<p>针对上面的问题，愿景如下</p>
<ul>
<li>前端最好能够动态直接拼接通用请求，避免重复写VO</li>
<li>前后端开发效率希望从3～5天，降低至一天出Demo</li>
</ul>
<h2 id="2-系统设计"><a class="header" href="#2-系统设计">2. 系统设计</a></h2>
<p>结合前端开发能力与其他开源方案，主要有如下方案</p>
<ul>
<li>如果直接暴露SQL给前端，这个是不可能的，安全性先不说，由于细分工导致前端不会拼SQL的大有人在。</li>
<li>基于ElasticSearch的QueryDSL设计，这个可以说是AST了，但是过于复杂，没有Parser(它的Client只能透传Netty报文)</li>
<li>自己设计查询DSL，自己通过反射解析并生成复用通用Mapper中的ExampleCriterion</li>
</ul>
<p>既然本文写了，肯定是用第三种方法啦，最终前台接口设计如下，发送的是一个原始的AST，树形的path被拍瘪(flatten)过，本方法比较类似原生Lucense的查询方案</p>
<pre><code class="language-js">[
    {
        'path': 'lessons.name',
        'opt': 'EQUALS',
        'args': ['数学']
    },
    {
        'path': 'lessons.grades.rate',
        'opt': 'IN',
        'args': ['60','70']
    }
]
</code></pre>
<p>后台将根据前端自动通过path生成SQL</p>
<pre><code class="language-sql">SELECT 
	s.id,
	s.name,
	l.id as l_id,
	l.name as l_name,
	g.rate
FROM student s
LEFT JOIN LESSON l on s.id = l.student_id
LEFT JOIN GRADE g on l.id = g.lesson_id
WHERE l.name = #{?} AND g.rate in #{?}
</code></pre>
<h2 id="3-方案实现"><a class="header" href="#3-方案实现">3. 方案实现</a></h2>
<h4 id="31--解析ast可复用"><a class="header" href="#31--解析ast可复用">3.1.  解析AST(可复用)</a></h4>
<p>这一步需要将前台的JSON解析为通用Mapper(tk)的Example，伪代码如下</p>
<pre><code class="language-java">Map&lt;String, Example&gt; tkExampleMap = [:];
asts.stream()
.filter(ast -&gt; ast.path?.trim()) //过滤空字符串
// 按照点号进行分组, &quot;aa.bb.cc&quot; -&gt; &quot;aa.bb&quot;
.groupBy(ast -&gt; ast.path.find(&quot;\\w+\\.\\w+&quot;))
.forEach(path, groupAsts -&gt; {
    // 通过反射获取类型，比如getFieldTypeByPath('lessons.grades')
    // =&gt; Class Gradle
    Class c = getFieldTypeByPath(path)
    Example e = new Example(c);
    // 通过 opt 与 args 生成Criterion，一个简单的模式匹配映射
    // 这里可以查询通用Mapper的API
    createCriterionFromOpts(e, groupAsts)
    tkExampleMap.put(path, e);
})
</code></pre>
<p>很多人可能会在这里疑惑为什么需要分组(GroupBy)，这里分组是为了避免生成多个对应了同一个表的Example，这样后期查询再去重就不好做了</p>
<h4 id="32-引入mapperxml模版可复用"><a class="header" href="#32-引入mapperxml模版可复用">3.2. 引入mapper.xml模版(可复用)</a></h4>
<p>首先找一个放公共的xml，把这个代码段放进去，这个也是来源于通用Mapper的，一个字没改</p>
<pre><code class="language-xml">&lt;sql id='byExampe'&gt;
    &lt;if test=&quot;criteria.valid&quot;&gt;
        ${@tk.mybatis.mapper.util.OGNL@andOr(criteria)}
        &lt;trim prefix=&quot;(&quot; prefixOverrides=&quot;and |or &quot; suffix=&quot;)&quot;&gt;
            &lt;foreach collection=&quot;criteria.criteria&quot; item=&quot;criterion&quot;&gt;
                &lt;choose&gt;
                    &lt;when test=&quot;criterion.noValue&quot;&gt;
                        ${@tk.mybatis.mapper.util.OGNL@andOr(criterion)} ${alias}.${criterion.condition}
                    &lt;/when&gt;
                    &lt;when test=&quot;criterion.singleValue&quot;&gt;
                        ${@tk.mybatis.mapper.util.OGNL@andOr(criterion)} ${alias}.${criterion.condition} #{criterion.value}
                    &lt;/when&gt;
                    &lt;when test=&quot;criterion.betweenValue&quot;&gt;
                        ${@tk.mybatis.mapper.util.OGNL@andOr(criterion)} ${alias}.${criterion.condition} #{criterion.value} and
                        #{criterion.secondValue}
                    &lt;/when&gt;
                    &lt;when test=&quot;criterion.listValue&quot;&gt;
                        ${@tk.mybatis.mapper.util.OGNL@andOr(criterion)} ${alias}.${criterion.condition}
                        &lt;foreach close=&quot;)&quot; collection=&quot;criterion.value&quot; item=&quot;listItem&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt;
                            #{listItem}
                        &lt;/foreach&gt;
                    &lt;/when&gt;
                &lt;/choose&gt;
            &lt;/foreach&gt;
        &lt;/trim&gt;
    &lt;/if&gt;
&lt;/sql&gt;
</code></pre>
<h4 id="33-编写自有xml复用不可"><a class="header" href="#33-编写自有xml复用不可">3.3. 编写自有XML(复用不可)</a></h4>
<p>实现自己的接口</p>
<pre><code class="language-xml">&lt;sql id=&quot;whereExample&quot;&gt;
  &lt;where&gt;
    &lt;if test=&quot;example.student&quot;&gt;
      &lt;foreach collection=&quot;example.student.oredCriteria&quot; item=&quot;criteria&quot;&gt;
        &lt;include refid=&quot;byExampe&quot;&gt;
          &lt;property name=&quot;alias&quot; value=&quot;s&quot;/&gt;
        &lt;/include&gt;
      &lt;/foreach&gt;
      &lt;if test=&quot;example.get('student.lessons')&quot;&gt;
        &lt;foreach collection=&quot;example.get('student.lessons').oredCriteria&quot; item=&quot;criteria&quot;&gt;
         &lt;include refid=&quot;byExampe&quot;&gt;
          &lt;property name=&quot;alias&quot; value=&quot;l&quot;/&gt;
         &lt;/include&gt;
        &lt;/foreach&gt;
      &lt;/if&gt;
      &lt;if test=&quot;example.get('student.lessons.grades')&quot;&gt;
        &lt;foreach collection=&quot;example.get('student.lessons.grades').oredCriteria&quot; item=&quot;criteria&quot;&gt;
          &lt;include refid=&quot;byExampe&quot;&gt;
            &lt;property name=&quot;alias&quot; value=&quot;g&quot;/&gt;
          &lt;/include&gt;
        &lt;/foreach&gt;
      &lt;/if&gt;
    &lt;/if&gt;
  &lt;/where&gt;
&lt;/sql&gt;

&lt;select id=&quot;selectStudentByExample&quot;&gt;
  SELECT
    s.id,
    s.name,
    l.id as l_id,
    l.name as l_name,
    g.rate
  FROM student s
  LEFT JOIN LESSON l on s.id = l.student_id
  LEFT JOIN GRADE g on l.id = g.lesson_id
  &lt;include refid=&quot;whereExample&quot;/&gt;
&lt;/select&gt;

&lt;!-- 下面的是count需要用的，默认left-join的个数是不正确的，如果你使用了PageHelper的话 --&gt;
&lt;select id=&quot;selectStudentByExample_COUNT&quot;&gt;
  SELECT
    count(distinct s.id)
  FROM student s
  LEFT JOIN LESSON l on s.id = l.student_id
  LEFT JOIN GRADE g on l.id = g.lesson_id
  &lt;include refid=&quot;whereExample&quot;/&gt;
&lt;/select&gt;
</code></pre>
<p>在java侧只用传入Example代码即可</p>
<pre><code class="language-groovy">studentMapper.selectStudentByExample([
    'example': tkExampleMap
])
</code></pre>
<p>这样就全部ok了，后端只用写一个xml即可完成查询业务的开发，前端拼接AST即可</p>
<h2 id="4-方案的优缺点"><a class="header" href="#4-方案的优缺点">4. 方案的优缺点</a></h2>
<p>优点</p>
<ul>
<li>针对查询复杂度非常高的企业IT系统，开发效率有质的提升</li>
<li>对中低级开发比较友好，<strong>拷贝xml代码的现象更少</strong></li>
<li>再说一个政治不正确的，领导一般对这种改进都比较重视</li>
</ul>
<p>缺点</p>
<ul>
<li>对通用mapper强依赖</li>
<li>由于OGNL语言的不足，空判断与重复代码写的很丑</li>
<li>没有经过大规模的考验</li>
<li>安全扫描可能无法通过</li>
</ul>
<p>针对上述缺点的解决方法</p>
<ul>
<li>持续迭代底层实现</li>
<li>自己定制Mybatis的LanguageDriver或者OGNL</li>
</ul>
<h2 id="5-附录"><a class="header" href="#5-附录">5. 附录</a></h2>
<h4 id="51-ognl与map"><a class="header" href="#51-ognl与map">5.1. OGNL与Map</a></h4>
<p>在ognl中，假如你的map是{'aaa.bbb.ccc' =&gt; v1}这样的，那么在求值时，一定要写</p>
<pre><code>map.get('aaa.bbb.ccc')
</code></pre>
<p>而不是</p>
<pre><code>map.aaa.bbb.ccc
</code></pre>
<blockquote>
<p>通过OGNL的ObjectAcessor可以了解到解析详情</p>
</blockquote>
<h4 id="52-与的区别"><a class="header" href="#52-与的区别">5.2. <code>#{}</code>与<code>${}</code>的区别</a></h4>
<ul>
<li>
<p>美元符号是OGNL执行语句，用来生成字符串，比如<code>test=&quot;a&gt;0&quot;</code>	</p>
<blockquote>
<p>在<code>include</code>标签中，<code>${}</code>为特例，它只能传递文本，不能传递Object，有点类似于C中的宏<code>#define alias &quot;student&quot;</code></p>
</blockquote>
</li>
<li>
<p>而井号是一个占位符，内部<strong>不支持</strong>执行OGNL表达式，执行时将被替换为JDBC中的问号<code>?</code>，并在运行时填值，可以防止SQL注入</p>
</li>
<li>
<p>这两个可以在OgnlCache.getValue中打断点，就能明白OGNL何时执行</p>
</li>
</ul>
<h4 id="53-如何自定义xml标签"><a class="header" href="#53-如何自定义xml标签">5.3. 如何自定义XML标签</a></h4>
<p>在mybatis中，虽然xml已经提供了丰富的操作，比如<code>if</code>, <code>forEach</code>，但是这些标签特别是进行空判断时，与Groovy等语言相比就非常冗长，能不能像Angular或者VUE一样定制自己的xml的标签呢？</p>
<p>很遗憾，目前并不能很容易做到，从<code>XMLLanguageDriver</code>中可以看出，所有的标签都是硬编码的，所以如果你想自己实现那么你就要维护自己的<code>LanguageDriver</code></p>
<h4 id="54-不错的网站"><a class="header" href="#54-不错的网站">5.4 不错的网站</a></h4>
<ul>
<li><a href="https://my.oschina.net/zudajun/blog">https://my.oschina.net/zudajun/blog</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="parent-child-id-tree"><a class="header" href="#parent-child-id-tree">Parent-child-id-tree</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="事务"><a class="header" href="#事务">事务</a></h2>
<p>首先需要注意的是，MyBatis的事务与HttpSession是无关的。MyBatis是基于动态代理进行Wrapper的，而HttpSession是基于Filter的。</p>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<p>在Spring-session包中</p>
<pre><code>org.mybatis.spring.SqlSessionTemplate.SqlSessionInterceptor#invoke
</code></pre>
<p>通过MyBatis的Mapper中的动态代理前后包装实现事务，而非使用了Spring的AOP</p>
<pre><code class="language-$xslt">SqlSession sqlSession = getSqlSession(
      SqlSessionTemplate.this.sqlSessionFactory,
      SqlSessionTemplate.this.executorType,
      SqlSessionTemplate.this.exceptionTranslator);
try {
  Object result = method.invoke(sqlSession, args);
  if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) {
    // force commit even on non-dirty sessions because some databases require
    // a commit/rollback before calling close()
    sqlSession.commit(true);
  }
  return result;
} catch (Throwable t) {
  Throwable unwrapped = unwrapThrowable(t);
  if (SqlSessionTemplate.this.exceptionTranslator != null &amp;&amp; unwrapped instanceof PersistenceException) {
    // release the connection to avoid a deadlock if the translator is no loaded. See issue #22
    closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);
    sqlSession = null;
    Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);
    if (translated != null) {
      unwrapped = translated;
    }
  }
  throw unwrapped;
} finally {
  if (sqlSession != null) {
    closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);
  }
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h4 id="分布式数据库系统dds"><a class="header" href="#分布式数据库系统dds">分布式数据库系统(DDS)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Distributed_database">DDS</a>是一个远程的反向代理数据库，它可以</p>
<ol>
<li>对内将各种厂商，各种业务的DB进行统一管理</li>
<li>对外暴露SQL92等标准语法的连接，用户不知道内部的表用户，也不知道DB密码</li>
<li>实现读写分离与最终一致性</li>
<li>实现SQL热点查询命令的预编译优化、缓存查询结果、统计缓慢SQL等。</li>
</ol>
<p>目前各大厂商都有实现，比如阿里/华为云的云数据库，这个玩意还是很难搞的，需要很多专家团队去对业务进行优化。</p>
<h4 id="与zk的集成"><a class="header" href="#与zk的集成">与zk的集成</a></h4>
<p>在很多DDS的架构中，一般通过zk作为&quot;Naming Service&quot;进行发布注册</p>
<p>服务侧发布节点，举个例子</p>
<pre><code>zookeeper:
/
    /namingservice
        /dds
            /node
                [node1,node2,node3]
</code></pre>
<p>客户端调用</p>
<ul>
<li>开发支持zk的JDBC驱动</li>
<li>对node中节点的健康度进行查询，并选择最好的</li>
<li>把DDS当作单机数据库使用</li>
</ul>
<h2 id="dds的大致介绍"><a class="header" href="#dds的大致介绍">DDS的大致介绍</a></h2>
<p>只进行理论介绍</p>
<h4 id="事务一致性"><a class="header" href="#事务一致性">事务一致性</a></h4>
<p>这个是个难题</p>
<p>详见: http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency</p>
<h4 id="水平分库垂直分库"><a class="header" href="#水平分库垂直分库">水平分库/垂直分库</a></h4>
<p>这里注意是分库，不是分表</p>
<ul>
<li>水平分库: 按照地区等枚举进行分库</li>
<li>垂直分库: 如果把数据表看成结构体的话，垂直分库就是将结构体砍成几份</li>
</ul>
<h4 id="读写分离"><a class="header" href="#读写分离">读写分离</a></h4>
<p>todo</p>
<h4 id="调试与分析功能"><a class="header" href="#调试与分析功能">调试与分析功能</a></h4>
<p>此部分主要提供日志与JMX功能供上游开发调试</p>
<ul>
<li>耗时日志定位</li>
<li>JMX支持</li>
</ul>
<p>可以统计出耗时、报错等详细信息</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h3 id="快速过一下存储过程"><a class="header" href="#快速过一下存储过程">快速过一下存储过程</a></h3>
<p>学习流程</p>
<ul>
<li>先去Wiki/IBM等资料库快速学习入门一下</li>
<li>掌握一下某个厂商(比如Oracle)的DDL</li>
<li>掌握其在Hibernate等库中的使用方法(本文略)</li>
</ul>
<h4 id="如何创建存储过程"><a class="header" href="#如何创建存储过程">如何创建存储过程？</a></h4>
<p>存储过程即可以通过鼠标在软件中点点点完成创建(强烈推荐)，也可以直接手写</p>
<p>Oracle的<a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_6009.htm">文档</a>中对存储过程有一个明确的定义，可以看出它过于接近原生AST了，因此写起来有样板代码过多的感觉。</p>
<p><img src="https://docs.oracle.com/cd/B19306_01/server.102/b14200/img/create_procedure.gif" alt="create_procedure" /></p>
<p>我们在网上找一个PROCEDURE的例子</p>
<pre><code class="language-sql">CREATE OR REPLACE PROCEDURE count_comments (  
   postId IN NUMBER,  
   commentCount OUT NUMBER )  
AS 
BEGIN 
    SELECT COUNT(*) INTO commentCount  
    FROM post_comment  
    WHERE post_id = postId; 
END;
</code></pre>
<p>如果通过Groovy的Closure进行类比，它实际上就是这样的</p>
<pre><code class="language-groovy">def count_comments = {NUMBER postId-&gt;
	NUMBER commentCount = &quot;SELECT COUNT(*) FROM post_comment WHERE post_id = postId&quot;.eval();
  	return commentCount
}
</code></pre>
<p>所以存储过程是一个非常简单的函数，纯体力劳动，甚至外包都会写。并不是很多博客上说的高级DBA操作。</p>
<h4 id="一般用存储过程干啥"><a class="header" href="#一般用存储过程干啥">一般用存储过程干啥？</a></h4>
<p>上面也说了存储过程一般只是一个纯函数，而在实际业务开发中，我们通常直接用XML/注解等DSL在Java源码中去描述数据库中的对象，然后再调用Hibernate等工具帮你生成SQL，而不是手动拼接SQL(有注入风险，而且拼接的SQL项目难维护)。</p>
<p>那么为什么需要存储过程呢？当然是不得不用时才会用，比如超大数据，性能问题才会使用。</p>
<p>SQL是一种对数据库进行查询操作的外部DSL，相对于Java/js等语言来说，学起来并不舒服。王垠曾在<a href="http://www.yinwang.org/blog-cn/2014/04/24/relational">一篇文章</a>中批评过“数据库完全可以使用普通的程序语言（Java，Scheme 等）的“远程执行”来进行查询，而不需要专门的查询语言&quot;。</p>
<p>今天本文说的<a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E7%A8%8B%E5%BA%8F">存储过程</a>就是SQL中的”函数“，它用于直接操作数据库中的”结构体“数组，与JVM类语言中设计的Closure并没有什么本质的不同。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><p>在分析索引前，为了控制学习进度防止一口吃个大胖子</p>
<ul>
<li>建议将数据库的数据抽象为全在内存中，不涉及磁盘IO读写，忽略它的序列化与反序列化</li>
<li>将数据与索引抽象为两个集合，先不要一步到位就去折腾红黑树</li>
<li>可以把索引集合看成一个“瘦表”</li>
</ul>
<pre><code class="language-groovy">class Student{
    String id;
    String name;
    String age;
}
List&lt;Student&gt; dates;
Collection&lt;Map&lt;name,rowId&gt;&gt; idx;
Closure findTableByIndex = {query-&gt;
    return dates.select{rowId in (idx.findAll{it.name==query}.map{it.value})}
}
findTableByIndex(&quot;john smith&quot;)
</code></pre>
<h2 id="数据库的基本结构"><a class="header" href="#数据库的基本结构">数据库的基本结构</a></h2>
<h2 id="索引的优劣"><a class="header" href="#索引的优劣">索引的优劣</a></h2>
<ul>
<li>通过空间换时间，节约了查询速度</li>
<li>需要维护索引内部结构的排序，因此进行写入修改操作时，速度较慢</li>
</ul>
<h4 id="参考"><a class="header" href="#参考">参考</a></h4>
<ul>
<li>https://tech.meituan.com/mysql-index.html</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="位图索引"><a class="header" href="#位图索引">位图索引</a></h1>
<p>位图索引(Bitmap-Index)是一个性能强大，但是稍微使用不当就反而降低性能的索引类型，一般用于给枚举做索引</p>
<pre><code class="language-sql">SELECT count(*) FROM INV_SKU_PHOHE WHERE VENDOR IN ('HAUWEI', 'XIAOMI', 'APPLE')
</code></pre>
<p>上面就统计了三个厂商的库存</p>
<p>位图在更新索引时，是整个表都会锁住，重新计算所有的BitArray，但是它又没有像Redis那样的渐进式rehash，因此相对于B-tree更重，不适合频繁输入不同的数据。</p>
<h4 id="生成的索引例子"><a class="header" href="#生成的索引例子">生成的索引例子</a></h4>
<p>比如有如下数据</p>
<table><thead><tr><th>RID</th><th>NAME</th><th>VENDOR</th></tr></thead><tbody>
<tr><td>1</td><td>A</td><td>HAUWEI</td></tr>
<tr><td>2</td><td>B</td><td>XIAOMI</td></tr>
<tr><td>3</td><td>C</td><td>HAUWEI</td></tr>
<tr><td>4</td><td>D</td><td>HAUWEI</td></tr>
<tr><td>5</td><td>E</td><td>APPLE</td></tr>
</tbody></table>
<p>由于有三个索引，将生成如下索引(注意下文Bit-Array是数组，而不是字符串)</p>
<table><thead><tr><th></th><th>R1</th><th>R2</th><th>R3</th><th>R4</th><th>R5</th></tr></thead><tbody>
<tr><td>HAUWEI</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>XIAOMI</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>APPLE</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>Bit-Array</td><td>0001</td><td>0010</td><td>0001</td><td>0001</td><td>0100</td></tr>
</tbody></table>
<p>最终当搜索<code>HUAWEI</code>时，可以理解为进行BIT-OR运算</p>
<table><thead><tr><th>QUERY</th><th>ROW</th><th>bitwise-OR</th></tr></thead><tbody>
<tr><td>0001</td><td>0001</td><td>1</td></tr>
<tr><td>0001</td><td>0010</td><td>0</td></tr>
<tr><td>0001</td><td>0001</td><td>1</td></tr>
<tr><td>0001</td><td>0001</td><td>1</td></tr>
<tr><td>0001</td><td>0100</td><td>0</td></tr>
</tbody></table>
<p>这样就查出来了，由于Bitwise运算非常简单，因此查询速度较快</p>
<h4 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h4>
<p>一般用于高读低写的场景，可以在晚上离线生成，但是非实时数据</p>
<ul>
<li>数据仓库(data warehouses)，比如BOM数据库，卡号数据库，采购数据库</li>
<li>报表生成与查询业务</li>
</ul>
<h4 id="替代工具alternative"><a class="header" href="#替代工具alternative">替代工具(alternative)</a></h4>
<p>Elastic等全文检索工具的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html">keyword</a>类型，它将不进行分词(not_analyzed)而精确存储</p>
<pre><code class="language-http">PUT inv_sku_phone
{
  &quot;mappings&quot;: {
    &quot;_doc&quot;: {
      &quot;properties&quot;: {
        &quot;vendor&quot;: {
          &quot;type&quot;:  &quot;keyword&quot;
        }
      }
    }
  }
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="nosql与倒排索引"><a class="header" href="#nosql与倒排索引">NoSQL与倒排索引</a></h1>
<p>相比于传统的SQL中的<code>like</code>搜索，在Elastic/MongoDB等NoSql中，采用了倒排索引(inverted index)的技术</p>
<blockquote>
<p>https://www.elastic.co/guide/en/elasticsearch/guide/current/inverted-index.html</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="调试执行计划"><a class="header" href="#调试执行计划">调试执行计划</a></h1>
<p>在掌握任何一门新语言时，都需要如下途径</p>
<ul>
<li>直观掌握语言的AST与用法</li>
<li>调试并掌握语言如何运行</li>
</ul>
<p>而SQL就是一门查询过滤List数据结构的DSL，但是SQL本身的语法糟糕，表达力低下的语言，稍微where写错位置查询效率就变了很多。</p>
<p>本部分将介绍我的调试环境的配置</p>
<ul>
<li>旗舰版Intellij/DataGrip</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="事务-1"><a class="header" href="#事务-1">事务</a></h1>
<p>有如下表格</p>
<table><thead><tr><th align="left"><strong>Isolation Level</strong></th><th align="left">Dirty Read</th><th align="left">Nonrepeatable Read</th><th align="left">Phantom/ˈfæntǝm/ Read</th></tr></thead><tbody>
<tr><td align="left"><del>Read uncommitted</del></td><td align="left">Possible</td><td align="left">Possible</td><td align="left">Possible</td></tr>
<tr><td align="left">Read committed</td><td align="left">Not possible</td><td align="left">Possible</td><td align="left">Possible</td></tr>
<tr><td align="left">Repeatable read</td><td align="left">Not possible</td><td align="left">Not possible</td><td align="left">Possible</td></tr>
<tr><td align="left">Serializable</td><td align="left">Not possible</td><td align="left">Not possible</td><td align="left">Not possible</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="read-commit"><a class="header" href="#read-commit">read commit</a></h1>
<p>Read Committed的全称是read committed rather than transaction</p>
<p>详见  https://docs.oracle.com/database/121/CNCPT/consist.htm#CNCPT1319</p>
<h2 id="查询场景"><a class="header" href="#查询场景">查询场景</a></h2>
<p>只要其它事务有commit，无论是update/insert/delete，变更马上就能实时看到</p>
<h2 id="update场景"><a class="header" href="#update场景">update场景</a></h2>
<p>当两个事务同时更新冲突事务时，后更新的事务会阻塞等待前者commit，前者commit后，会覆盖前者的数据</p>
<pre><code class="language-puml">@startuml
|Trans1|
start
:begin;
:update salary=11 where ID='1' \n =&gt; OK;
|#AntiqueWhite|Trans2|
:begin;
:update salary=12 where ID='1' \n =&gt; Blocked;
|Trans1|
:commit;
|Trans2|
:1 row updated.;
:select salary where ID='1' \n =&gt; 12;
|#AntiqueWhite|Trans1|
:select salary where ID='1' \n =&gt; 12;

stop
@enduml
</code></pre>
<p>当两个事务同时更新不冲突的事务时，只要没有commit，就是各搞各的。</p>
<h2 id="insertdelete场景"><a class="header" href="#insertdelete场景">insert/delete场景</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="repeatable-read"><a class="header" href="#repeatable-read">Repeatable read</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="serializable"><a class="header" href="#serializable">Serializable</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="数据仓库"><a class="header" href="#数据仓库">数据仓库</a></h2>
<p>比如HW的DWS
https://www.huaweicloud.com/product/dws.html</p>
<h4 id="切片方案"><a class="header" href="#切片方案">切片方案</a></h4>
<h4 id="存储方案"><a class="header" href="#存储方案">存储方案</a></h4>
<p>列存储与行存储</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="图数据库"><a class="header" href="#图数据库">图数据库</a></h1>
<p>https://www.huaweicloud.com/product/ges.html</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="参考文献与wiki"><a class="header" href="#参考文献与wiki">参考文献与Wiki</a></h1>
<h4 id="最佳实践项目"><a class="header" href="#最佳实践项目">最佳实践项目</a></h4>
<p>我个人建议学习Mybatis中参考<a href="https://github.com/SonarSource/sonarqube">SonarQube</a>的项目，优点如下</p>
<ul>
<li><code>@CheckForNull</code>, <code>@Nullable</code>, <code>@Param</code>等严谨的注解</li>
<li>支持MySql, Oracle等多个Vendor(databaseId)</li>
<li>与Elastic结合的数据库设计</li>
<li>SonarQube本身就是做代码质量检测的，因此开源项目本身就是一个样板</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
