<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="本文先从Fibonacci递归计算开始，介绍了通过DP消除栈的算法，以及CPS的基本概念与Jenkins底层实现。"><meta name="keyword" content="CPS,DP,FP,Groovy,Jenkins"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>动态规划与JenkinsCPS技术</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body class="container"><header id="header"><div class="header"><div class="header-left"><div class="author"><div class="author-name"><a href="/">諺</a></div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">Archives</a></li><li style="font-size:.9rem"><a href="/archives" rel="nofollow">zh</a></li><li style="font-size:.9rem"><a href="#" rel="nofollow">|</a></li><li style="font-size:.9rem"><a href="/en" rel="nofollow">en</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">Epistemology</a></li><li><a href="/books" rel="nofollow">読書</a></li></ul></div></div></header><div class="content-wrapper"><div class="post"><section class="article"><div class="title">动态规划与JenkinsCPS技术</div><div class="date">2020-02-15に投稿</div><div class="content"><p>本文先从Fibonacci递归计算开始，介绍了通过DP消除栈的算法，以及CPS的基本概念与Jenkins底层实现。</p><span id="more"></span><p>本文读者要求：掌握CPS/DP/Groovy的基本使用，编译理论的基本方法，部分需了解Jenkins。</p><p>本文目的：介绍DP、CPS的理论，以及CPS在Jenkins的实践。</p><h2>What is DP?</h2><p>DP(dynamic programming，动态规划)是缓存计算结果的方法，通过给参数注入全局缓存/消除栈等方法，降低重复计算成本。</p><p>以求fibonacci为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  in:0 1 2 3 4 5 6</span></span><br><span class="line"><span class="comment">// out:0 1 1 2 3 5 8</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(i - <span class="number">2</span>) + fibonacci(i - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子如果你经过调试，就会发现有很多重复计算，也很容易产生栈溢出，我们尝试使用DP解决</p><p>方法一：我们可以加一个全局缓存<code>int[] dp</code>，这种方法与使用Redis当缓存没有区别，也很像“科学管理”中的计算尺</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：top down DP，没有消除栈，空间复杂度为O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] dp)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    dp[i] = i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i] = fibonacci(i - <span class="number">2</span>, dp) + fibonacci(i - <span class="number">1</span>, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二，通过for循环消除递归调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法二：down-top，这种方法通过jump消除了栈，仍然消耗了O(N)的空间复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[i+<span class="number">1</span>];</span><br><span class="line">  dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    dp[j] = dp[j-<span class="number">1</span>] + dp[j-<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三，是更优写法，这种通过少数几个寄存器就实现了缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法三：递归栈消除+低空间复杂度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    c = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的场景中，我个人最推荐第二种方案，因为思路是很清晰的，熟悉后再尝试优化到第三种</p><h2>迭代与递归的选择/转换</h2><p>无论是OJ题目，还是真实项目，它们都是现实的问题，现实的问题就有方法论去实施，去分解，所以不要惧怕这些问题。</p><ul><li>递归的顶层方法论其实是求导，通过分解为最小任务，并用多个参数实验获取结果。它可以实现最小的状态转移语意，代码量最少，但是可能出现分解思路困难/堆栈异常/忽视关闭条件。</li><li>for循环等迭代底层都是JUMP命令，它没有栈，但是很多逻辑、全局变量混在一起，后面难以维护</li><li>以上问题均默认不开启编译器尾递归等优</li></ul><p>在真实问题中，我个人先使用递归设计出原型，再通过CPS/DP技术去实现Desugar，优化掉递归调用。</p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iMzA1cHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDo4MDNweDtoZWlnaHQ6MzA1cHg7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA4MDMgMzA1IiB3aWR0aD0iODAzcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48cmVjdCBmaWxsPSIjRkVGRUNFIiBoZWlnaHQ9IjM2Ljc5OTkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzYiIHg9IjEwIiB5PSIxMzMuNTk5OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU2IiB4PSIyMCIgeT0iMTU3LjU5OTgiPuWkjeadgumXrumimDwvdGV4dD48cmVjdCBmaWxsPSIjRkVGRUNFIiBoZWlnaHQ9IjUzLjU5OTkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMjI2IiB4PSIxMzYiIHk9IjEyNS4xOTk5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTY4IiB4PSIxNDYiIHk9IjE0OS4xOTk4Ij7mi4bop6PkuLrnirbmgIHovaznp7vnmoTpgJLlvZLpl67popg8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjA2IiB4PSIxNDYiIHk9IjE2NS45OTk4Ij4o5q+U5aaCZmFjdG9yaWFsKG4pPWZhY3RvcmlhbChuLTEpKjIpPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGhlaWdodD0iMzYuNzk5OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNzgiIHg9IjQxMiIgeT0iMjAiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNTgiIHg9IjQyMiIgeT0iNDMuOTk5OSI+ZWRnZSBjYXNlcyjmr5TlpoJudWxs5Zy65pmvKTwvdGV4dD48cGF0aCBkPSJNMzYyLDE1MS45OTk4IEwzNzIsMTUxLjk5OTggQzM4NywxNTEuOTk5OCAzODcsMzguNCA0MDIsMzguNCBMNDEyLDM4LjQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRkVGRUNFIiBoZWlnaHQ9IjM2Ljc5OTkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTUyIiB4PSI0MTIiIHk9IjE2MS45OTk4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTMyIiB4PSI0MjIiIHk9IjE4NS45OTk4Ij5EZXN1bGFyKOagiC/lj4LmlbDkvJjljJYpPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGhlaWdodD0iMzYuNzk5OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNzciIHg9IjYxNCIgeT0iNzYuNzk5OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE1NyIgeD0iNjI0IiB5PSIxMDAuNzk5OSI+Q3Vycnko5aSa5Y+C5pWw6L2s5Li65Y2V5Y+C5pWwKTwvdGV4dD48cGF0aCBkPSJNNTY0LDE4MC4zOTk4IEw1NzQsMTgwLjM5OTggQzU4OSwxODAuMzk5OCA1ODksOTUuMTk5OSA2MDQsOTUuMTk5OSBMNjE0LDk1LjE5OTkgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRkVGRUNFIiBoZWlnaHQ9IjM2Ljc5OTkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTY1IiB4PSI2MTQiIHk9IjEzMy41OTk5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTQ1IiB4PSI2MjQiIHk9IjE1Ny41OTk4Ij5Ub3AtZG93biBEUC/nqbrpl7TkvJjljJY8L3RleHQ+PHBhdGggZD0iTTU2NCwxODAuMzk5OCBMNTc0LDE4MC4zOTk4IEM1ODksMTgwLjM5OTggNTg5LDE1MS45OTk4IDYwNCwxNTEuOTk5OCBMNjE0LDE1MS45OTk4ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgaGVpZ2h0PSIzNi43OTk5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjQ4IiB4PSI2MTQiIHk9IjE5MC4zOTk4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjgiIHg9IjYyNCIgeT0iMjE0LjM5OTciPkNQUzwvdGV4dD48cGF0aCBkPSJNNTY0LDE4MC4zOTk4IEw1NzQsMTgwLjM5OTggQzU4OSwxODAuMzk5OCA1ODksMjA4Ljc5OTcgNjA0LDIwOC43OTk3IEw2MTQsMjA4Ljc5OTcgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRkVGRUNFIiBoZWlnaHQ9IjM2Ljc5OTkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNTIiIHg9IjYxNCIgeT0iMjQ3LjE5OTciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIzMiIgeD0iNjI0IiB5PSIyNzEuMTk5NiI+aW5saW5lPC90ZXh0PjxwYXRoIGQ9Ik01NjQsMTgwLjM5OTggTDU3NCwxODAuMzk5OCBDNTg5LDE4MC4zOTk4IDU4OSwyNjUuNTk5NyA2MDQsMjY1LjU5OTcgTDYxNCwyNjUuNTk5NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0zNjIsMTUxLjk5OTggTDM3MiwxNTEuOTk5OCBDMzg3LDE1MS45OTk4IDM4NywxODAuMzk5OCA0MDIsMTgwLjM5OTggTDQxMiwxODAuMzk5OCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik04NiwxNTEuOTk5OCBMOTYsMTUxLjk5OTggQzExMSwxNTEuOTk5OCAxMTEsMTUxLjk5OTggMTI2LDE1MS45OTk4IEwxMzYsMTUxLjk5OTggIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48IS0tTUQ1PVswMTA1YTM5YTQ1NjUwYTMzZGY2NzA1MTMwMzMwNjI1ZV0KQHN0YXJ0bWluZG1hcA0Kc2tpbnBhcmFtIHNoYWRvd2luZyBmYWxzZQ0KKyDlpI3mnYLpl67popgNCisrIOaLhuino+S4uueKtuaAgei9rOenu+eahOmAkuW9kumXrumimFxuKOavlOWmgmZhY3RvcmlhbChuKT1mYWN0b3JpYWwobi0xKSoyKQ0KKysrIGVkZ2UgY2FzZXMo5q+U5aaCbnVsbOWcuuaZrykNCisrKyBEZXN1bGFyKOagiC/lj4LmlbDkvJjljJYpDQorKysrIEN1cnJ5KOWkmuWPguaVsOi9rOS4uuWNleWPguaVsCkNCisrKysgVG9wLWRvd24gRFAv56m66Ze05LyY5YyWDQorKysrIENQUw0KKysrKyBpbmxpbmUNCkBlbmRtaW5kbWFwDQoKUGxhbnRVTUwgdmVyc2lvbiAxLjIwMjEuNChTdW4gQXByIDA0IDA4OjQ5OjM5IEdNVCAyMDIxKQooR1BMIHNvdXJjZSBkaXN0cmlidXRpb24pCkphdmEgUnVudGltZTogT3BlbkpESyBSdW50aW1lIEVudmlyb25tZW50CkpWTTogT3BlbkpESyA2NC1CaXQgU2VydmVyIFZNCkRlZmF1bHQgRW5jb2Rpbmc6IFVURi04Ckxhbmd1YWdlOiBlbgpDb3VudHJ5OiBVUwotLT48L2c+PC9zdmc+"><p>拆解方法也是有方法论的，它可以通过<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Design_of_experiments">DOE(Design of experiments)</a>找出输入与输出的关系，比如</p><ul><li>通过强制固定一些参数降低动态复杂度，DP一定是确定性的/无状态的，非NP问题</li><li>输出并不一定确切的值。比如计算EditDistance，只用求最终总和即可，而没要求具体的排列组合，这两个难度完全不一致。</li></ul><p>除此之外，还有一些技巧性强的常数复杂度方案甚至经验公式/数学方法，但是这种方法是需要学习与记忆的</p><h2>What is CPS?</h2><p>将阻塞的请求改为异步的Callback形式（或者返回一个Promise/Next的结构体），仅此而已。注意网上有很多文章说通过CPS可以消除栈，但是只说对了一半，在没有编译器优化的情况下，并不能将栈优化为JMP调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consumer也可以用Groovy的Closure实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fibonacciCps</span><span class="params">(<span class="keyword">int</span> i, Consumer&lt;Integer&gt; call)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    call.accept(i);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fibonacciCps(i - <span class="number">1</span>, <span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer a)</span> </span>&#123;</span><br><span class="line">        fibonacciCps(i - <span class="number">2</span>, <span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer b)</span> </span>&#123;</span><br><span class="line">            call.accept(a + b);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fibonacciCps(<span class="number">6</span>, <span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer sum)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;sum = &quot;</span> + integer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>平时编码这种写法可读性很差，很难显示区分同步还是异步执行，所以基本上没有利用的机会，一般会“人肉AST优化”到DP的第三种。</p><p>不过这样的好处是</p><ul><li>作为AST的中间态，方便编译器进行栈消除</li><li>实现在JVM上自己的“栈”与“VM”，以及持久化</li><li>实现数据“状态”的持久化（Checkpoint/Restore），比如Jenkins/CRIU</li></ul><h2>Jenkinsfile的CPS实现</h2><p>此部分介绍用户输入的Jenkinsfile脚本在Jenkins底层执行的流程</p><h4>字符串编译为BlockAST</h4><p>原始的脚本虽然写的像字符串，执行底层也是Groovy，但是它<strong>不是Groovy语言</strong></p><ul><li>所有Groovy语言的Token关键词(比如if/常数/变量)将不再是一个简单的JVM字节码，而有各个对应的Block，通过MetaMethodSite实现了&quot;编译&quot;为CPS的Block</li><li>静态工具类调用（比如forEach）/Closure表达式，通过CpsTransformer在编译时/运行时生成CPS转换，除非加入<code>@NoCPS</code>注解。有人可能看过王垠的40行代码，但是王垠的显然更高级。</li><li>定制的Step，通过<code>FunctionCallBlock</code>封装调用，它内部再使用CpsScript引擎去Eval</li></ul><p>在执行侧，Jenkins通过Groovy的Script实现了自己封装了一个Runtime，具体可以看<a href="/tags/Groovy/">Groovy</a>相关文章，避免自己从零写AST，最终输入的Groovy字符串将转为如下结构体</p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iMTYzcHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDoxMDA3cHg7aGVpZ2h0OjE2M3B4OyIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMTAwNyAxNjMiIHdpZHRoPSIxMDA3cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48cmVjdCBmaWxsPSIjRkVGRUNFIiBoZWlnaHQ9IjUzLjU5OTkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTkwIiB4PSIxMCIgeT0iNTQuMiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEwOSIgeD0iMjAiIHk9Ijc4LjE5OTkiPkNwc1RocmVhZEdyb3VwPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE3MCIgeD0iMjAiIHk9Ijk0Ljk5OTgiPijlsIbooqvmjIHkuYXljJbkuLpwcm9ncmFtLmRhdCk8L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgaGVpZ2h0PSI1My41OTk5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwNyIgeD0iMjUwIiB5PSI1NC4yIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODciIHg9IjI2MCIgeT0iNzguMTk5OSI+Q29udGludWFibGUgJmFtcDs8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNzgiIHg9IjI2MCIgeT0iOTQuOTk5OCI+Q29udGludWF0aW9uPC90ZXh0PjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGhlaWdodD0iMzYuNzk5OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI0NCIgeD0iNDA3IiB5PSIyMCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI0IiB4PSI0MTciIHk9IjQzLjk5OTkiPkVudjwvdGV4dD48cGF0aCBkPSJNMzU3LDgwLjk5OTkgTDM2Nyw4MC45OTk5IEMzODIsODAuOTk5OSAzODIsMzguNCAzOTcsMzguNCBMNDA3LDM4LjQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRkVGRUNFIiBoZWlnaHQ9IjM2Ljc5OTkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUiIHg9IjQwNyIgeT0iNzYuNzk5OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1IiB4PSI0MTciIHk9IjEwMC43OTk5Ij5CbG9ja0xpc3Q8L3RleHQ+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgaGVpZ2h0PSIzNi43OTk5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjgxIiB4PSI1MzIiIHk9IjQ4LjQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2MSIgeD0iNTQyIiB5PSI3Mi4zOTk5Ij7ln7rnoYBCbG9jazwvdGV4dD48cGF0aCBkPSJNNDgyLDk1LjE5OTkgTDQ5Miw5NS4xOTk5IEM1MDcsOTUuMTk5OSA1MDcsNjYuNzk5OSA1MjIsNjYuNzk5OSBMNTMyLDY2Ljc5OTkgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRkVGRUNFIiBoZWlnaHQ9IjM2Ljc5OTkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTMwIiB4PSI1MzIiIHk9IjEwNS4xOTk5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTEwIiB4PSI1NDIiIHk9IjEyOS4xOTk4Ij5GdW5jdGlvbkNhbGxCbG9jazwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMDMiIHg9IjcxNSIgeT0iMTE5Ljc5OTkiPuaJp+ihjHN0ZXBz562J5Yqf6IO9PC90ZXh0PjxwYXRoIGQ9Ik02NjIsMTIzLjU5OTkgTDY3MiwxMjMuNTk5OSBDNjg3LDEyMy41OTk5IDY4NywxMTQuMTk5OSA3MDIsMTE0LjE5OTkgTDcxMiwxMTQuMTk5OSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI4MCIgeD0iNzE1IiB5PSIxMzguNTk5OCI+5omn6KGMR3Jvb3Z55bel5YW357G7Q3BzRGVmYXVsdEdyb292eU1ldGhvZHM8L3RleHQ+PHBhdGggZD0iTTY2MiwxMjMuNTk5OSBMNjcyLDEyMy41OTk5IEM2ODcsMTIzLjU5OTkgNjg3LDEzMi45OTk4IDcwMiwxMzIuOTk5OCBMNzEyLDEzMi45OTk4ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTQ4Miw5NS4xOTk5IEw0OTIsOTUuMTk5OSBDNTA3LDk1LjE5OTkgNTA3LDEyMy41OTk5IDUyMiwxMjMuNTk5OSBMNTMyLDEyMy41OTk5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTM1Nyw4MC45OTk5IEwzNjcsODAuOTk5OSBDMzgyLDgwLjk5OTkgMzgyLDk1LjE5OTkgMzk3LDk1LjE5OTkgTDQwNyw5NS4xOTk5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTIwMCw4MC45OTk5IEwyMTAsODAuOTk5OSBDMjI1LDgwLjk5OTkgMjI1LDgwLjk5OTkgMjQwLDgwLjk5OTkgTDI1MCw4MC45OTk5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PCEtLU1ENT1bNjhmZTEyMTI5MjRkYzBmNTU0NDU4ZTRhNDdiMTk5M2ZdCkBzdGFydG1pbmRtYXANCnNraW5wYXJhbSBzaGFkb3dpbmcgZmFsc2UNCisgQ3BzVGhyZWFkR3JvdXBcbijlsIbooqvmjIHkuYXljJbkuLpwcm9ncmFtLmRhdCkNCisrIENvbnRpbnVhYmxlICZcbkNvbnRpbnVhdGlvbg0KKysrIEVudg0KKysrIEJsb2NrTGlzdA0KKysrKyDln7rnoYBCbG9jaw0KKysrKyBGdW5jdGlvbkNhbGxCbG9jaw0KKysrKytfIOaJp+ihjHN0ZXBz562J5Yqf6IO9DQorKysrK18g5omn6KGMR3Jvb3Z55bel5YW357G7Q3BzRGVmYXVsdEdyb292eU1ldGhvZHMNCkBlbmRtaW5kbWFwDQoKUGxhbnRVTUwgdmVyc2lvbiAxLjIwMjEuNChTdW4gQXByIDA0IDA4OjQ5OjM5IEdNVCAyMDIxKQooR1BMIHNvdXJjZSBkaXN0cmlidXRpb24pCkphdmEgUnVudGltZTogT3BlbkpESyBSdW50aW1lIEVudmlyb25tZW50CkpWTTogT3BlbkpESyA2NC1CaXQgU2VydmVyIFZNCkRlZmF1bHQgRW5jb2Rpbmc6IFVURi04Ckxhbmd1YWdlOiBlbgpDb3VudHJ5OiBVUwotLT48L2c+PC9zdmc+"><h4>CPS层执行与栈消除</h4><p>在CPS的内部AST，是一个<code>Block</code>单向链表，除了Parallel外，其它Block都是线性遍历的，因此设计上很简洁，这个与<a href="/gitbook/mybatis/">MyBatis</a>的<code>MixedSqlNode</code>/S-Expression是相同的设计思路</p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U2NyaXB0VHlwZT0iYXBwbGljYXRpb24vZWNtYXNjcmlwdCIgY29udGVudFN0eWxlVHlwZT0idGV4dC9jc3MiIGhlaWdodD0iMTAxcHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDo1MzFweDtoZWlnaHQ6MTAxcHg7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA1MzEgMTAxIiB3aWR0aD0iNTMxcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzPjxmaWx0ZXIgaGVpZ2h0PSIzMDAlIiBpZD0iZjFrdXZlZ3d0bmVhYjgiIHdpZHRoPSIzMDAlIiB4PSItMSIgeT0iLTEiPjxmZUdhdXNzaWFuQmx1ciByZXN1bHQ9ImJsdXJPdXQiIHN0ZERldmlhdGlvbj0iMi4wIi8+PGZlQ29sb3JNYXRyaXggaW49ImJsdXJPdXQiIHJlc3VsdD0iYmx1ck91dDIiIHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAuNCAwIi8+PGZlT2Zmc2V0IGR4PSI0LjAiIGR5PSI0LjAiIGluPSJibHVyT3V0MiIgcmVzdWx0PSJibHVyT3V0MyIvPjxmZUJsZW5kIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImJsdXJPdXQzIiBtb2RlPSJub3JtYWwiLz48L2ZpbHRlcj48L2RlZnM+PGc+PGcgaWQ9Ik5leHQiPjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMWt1dmVnd3RuZWFiOCkiIGhlaWdodD0iODAuMDAwMiIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI4NCIgeD0iNyIgeT0iNyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgeDE9IjciIHgyPSI5MSIgeTE9IjMzLjc5OTkiIHkyPSIzMy43OTk5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjgiIHg9IjM1IiB5PSIyNS45OTk5Ij5OZXh0PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI5IiB4PSIxMiIgeT0iNTAuOCI+QmxvY2s8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTIiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjAiIHg9IjEyIiB5PSI2NS4yMDAxIj5FbnY8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTIiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNjQiIHg9IjEyIiB5PSI3OS42MDAyIj5Db250aW51YXRpb248L3RleHQ+PC9nPjxnIGlkPSJCbG9jayI+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2Yxa3V2ZWd3dG5lYWI4KSIgaGVpZ2h0PSI2NS42MDAxIiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijg0IiB4PSIxNTciIHk9IjE0Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB4MT0iMTU3IiB4Mj0iMjQxIiB5MT0iNDAuNzk5OSIgeTI9IjQwLjc5OTkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIzMyIgeD0iMTgyLjUiIHk9IjMyLjk5OTkiPkJsb2NrPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIwIiB4PSIxNjIiIHk9IjU3LjgiPkVudjwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMiIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NCIgeD0iMTYyIiB5PSI3Mi4yMDAxIj5Db250aW51YXRpb248L3RleHQ+PC9nPjxnIGlkPSJOZXh0MiI+PHJlY3QgZmlsbD0iI0ZFRkVDRSIgZmlsdGVyPSJ1cmwoI2Yxa3V2ZWd3dG5lYWI4KSIgaGVpZ2h0PSI4MC4wMDAyIiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijg0IiB4PSIzMDciIHk9IjciLz48bGluZSBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuNTsiIHgxPSIzMDciIHgyPSIzOTEiIHkxPSIzMy43OTk5IiB5Mj0iMzMuNzk5OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjM2IiB4PSIzMzEiIHk9IjI1Ljk5OTkiPk5leHQyPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI5IiB4PSIzMTIiIHk9IjUwLjgiPkJsb2NrPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIwIiB4PSIzMTIiIHk9IjY1LjIwMDEiPkVudjwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMiIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NCIgeD0iMzEyIiB5PSI3OS42MDAyIj5Db250aW51YXRpb248L3RleHQ+PC9nPjxnIGlkPSJCbG9jazIiPjxyZWN0IGZpbGw9IiNGRUZFQ0UiIGZpbHRlcj0idXJsKCNmMWt1dmVnd3RuZWFiOCkiIGhlaWdodD0iNTAiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNjEiIHg9IjQ1Ni41IiB5PSIyMiIvPjxsaW5lIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS41OyIgeDE9IjQ1Ni41IiB4Mj0iNTE3LjUiIHkxPSI0OC43OTk5IiB5Mj0iNDguNzk5OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQxIiB4PSI0NjYuNSIgeT0iNDAuOTk5OSI+QmxvY2syPC90ZXh0PjwvZz48IS0tTUQ1PVs1ZGNlYmZkZjY1NzlkYTY2OTFkNTkzM2Q5ZmNmMGE0N10KbGluayBOZXh0IHRvIEJsb2NrLS0+PHBhdGggZD0iTTkxLjE4LDQ3IEMxMDkuOTUsNDcgMTMyLjE0LDQ3IDE1MS41LDQ3ICIgZmlsbD0ibm9uZSIgaWQ9Ik5leHQtdG8tQmxvY2siIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9IiNBODAwMzYiIHBvaW50cz0iMTU2Ljg3LDQ3LDE0Ny44Nyw0MywxNTEuODcsNDcsMTQ3Ljg3LDUxLDE1Ni44Nyw0NyIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjkiIHg9IjEwOS41IiB5PSI0MSI+ZXZhbC4uPC90ZXh0PjwhLS1NRDU9WzMwNWI4ZTEyY2U5NGMxMTY0MGVjYWI4YzhlNTY3ZWJjXQpsaW5rIEJsb2NrIHRvIE5leHQyLS0+PHBhdGggZD0iTTI0MS4xOCw0NyBDMjU5Ljk1LDQ3IDI4Mi4xNCw0NyAzMDEuNSw0NyAiIGZpbGw9Im5vbmUiIGlkPSJCbG9jay10by1OZXh0MiIgc3R5bGU9InN0cm9rZTojQTgwMDM2O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0iI0E4MDAzNiIgcG9pbnRzPSIzMDYuODcsNDcsMjk3Ljg3LDQzLDMwMS44Nyw0NywyOTcuODcsNTEsMzA2Ljg3LDQ3IiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyOSIgeD0iMjU5LjUiIHk9IjQxIj5ldmFsLi48L3RleHQ+PCEtLU1ENT1bMjliMWNjNjkxZGJmN2JjNGM5ODE1ZDUzOWZiYjg2MWFdCmxpbmsgTmV4dDIgdG8gQmxvY2syLS0+PHBhdGggZD0iTTM5MS4xNSw0NyBDNDEwLjQzLDQ3IDQzMy4wMSw0NyA0NTEuNDEsNDcgIiBmaWxsPSJub25lIiBpZD0iTmV4dDItdG8tQmxvY2syIiBzdHlsZT0ic3Ryb2tlOiNBODAwMzY7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSIjQTgwMDM2IiBwb2ludHM9IjQ1Ni40OSw0Nyw0NDcuNDksNDMsNDUxLjQ5LDQ3LDQ0Ny40OSw1MSw0NTYuNDksNDciIHN0eWxlPSJzdHJva2U6I0E4MDAzNjtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI5IiB4PSI0MDkuMjUiIHk9IjQxIj5ldmFsLi48L3RleHQ+PCEtLU1ENT1bYmZhYTE4MjZiY2Q5NzM1YWQyN2M0YzU0Y2NjZThkMzddCkBzdGFydHVtbA0KTmV4dDogQmxvY2sNCk5leHQ6IEVudg0KTmV4dDogQ29udGludWF0aW9uDQpOZXh0IC0+IEJsb2NrOiBldmFsLi4NCkJsb2NrOiBFbnYNCkJsb2NrOiBDb250aW51YXRpb24NCkJsb2NrIC0+IE5leHQyOiBldmFsLi4NCk5leHQyOiBCbG9jaw0KTmV4dDI6IEVudg0KTmV4dDI6IENvbnRpbnVhdGlvbg0KTmV4dDIgLT4gQmxvY2syOiBldmFsLi4NCkBlbmR1bWwNCgpQbGFudFVNTCB2ZXJzaW9uIDEuMjAyMS40KFN1biBBcHIgMDQgMDg6NDk6MzkgR01UIDIwMjEpCihHUEwgc291cmNlIGRpc3RyaWJ1dGlvbikKSmF2YSBSdW50aW1lOiBPcGVuSkRLIFJ1bnRpbWUgRW52aXJvbm1lbnQKSlZNOiBPcGVuSkRLIDY0LUJpdCBTZXJ2ZXIgVk0KRGVmYXVsdCBFbmNvZGluZzogVVRGLTgKTGFuZ3VhZ2U6IGVuCkNvdW50cnk6IFVTCi0tPjwvZz48L3N2Zz4="><p>内部通过循环一个单向链表进行消除，是不是很像DP优化的第三种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.cloudbees.groovy.cps.Continuable#run0</span></span><br><span class="line">Next n = cn.resumeFrom(e,k);</span><br><span class="line"><span class="keyword">while</span>(n.yield==<span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 我删掉了处理异常的代码行</span></span><br><span class="line">  n = n.step();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>JenkinsCPS的缺点</h4><p>由于它是对Jenkins深度定制的</p><ul><li>执行CPS必须需要Jenkins服务端（注意Agent只是执行原生字节码的，不处理CPS编排），没有成熟的离线解释器，因此执行限制于Jenkins单点</li><li>基于文件进行状态的持久化，这个毕竟是单点工具，没法比得过flink这种级别的Persisted States</li><li>断点调试很困难，基本上只能靠<code>echo</code>来分析脚本；CPS编程范式导致参数固定</li><li>作为插件开发者，那么这个Groovy/CPS的学习门槛的确有点高，从整个插件只有Kawaguchi一人主刀也可以看出</li></ul><h4>更深的语义定制</h4><p>假如你希望Jenkins能够实现更复杂的编排，或者自己的构建语法，可以尝试基于CPS再实现一层Interceptor，我基于此方案实现了</p><ul><li>YAML interceptor</li><li>Parallels BFS Tree嵌套并行执行构建</li><li>Log live tail</li></ul><p>这些是有门槛的定制场景，网上找不到开源的方案，全靠知识广度的积累。</p><h2>附录</h2><h4>关于Jenkins定制DevOps工具的前景</h4><ul><li>国内除了大型公司的工具组（比如我就经常看到阿里的人抱怨打了一天包都打不出来）有预算买现成的或者做这种改进，其它中小公司（所谓的Team）选择很有限。</li><li>小公司的DevOps方案（比如深圳有很多这种号称提高开发速度的小公司）我也调研过，但是很多核心思路、方向都落后业界，而且工资有限，导致产品没有竞争力</li><li>我个人认为这类工作很有挑战，因为它需要从裸机OS到容器、网关、Spring/CURD、ELK都要全局考虑，肯定比单独的Spring项目有难度。</li></ul><h4>参考链接</h4><p><a target="_blank" rel="noopener" href="https://www.kimsereylam.com/racket/lisp/2019/02/14/recursion-with-fibonacci.html">https://www.kimsereylam.com/racket/lisp/2019/02/14/recursion-with-fibonacci.html</a></p><p><a target="_blank" rel="noopener" href="http://arasio.hatenablog.com/entry/2016/10/08/220843">http://arasio.hatenablog.com/entry/2016/10/08/220843</a></p><h4>插件开发技巧（如何利用当前Step/Node信息）</h4><p>由于我不希望定制场景的代码引入到Java层（重启成本很高），但是又想获取到实时的Context信息，可以通过如下将业务代码移动到Groovy侧实现热部署</p><p>参考例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getting context of a *step*</span></span><br><span class="line"><span class="meta">@NoCPS</span> <span class="comment">// will not be compiled to CpsClosure, but MethodClosure</span></span><br><span class="line"><span class="function">def <span class="title">callback</span><span class="params">(result, Step s, CpsContext c)</span></span>&#123;</span><br><span class="line">  <span class="comment">// todo: use context, node and other metadata.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in your cps steps</span></span><br><span class="line">node&#123;</span><br><span class="line">  def result = sh(<span class="string">&quot;xxxxx&quot;</span>)</span><br><span class="line">  <span class="comment">// implementation in java is required.</span></span><br><span class="line">  <span class="comment">// customStep内部直接调用 callback.call(this, context) 即可触发Groovy</span></span><br><span class="line">  customStep(callback: <span class="keyword">this</span>.&amp;callback.curry(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>Jenkins核心调试断点位置</h4><p>从MQ取到Executor开始执行的位置(之前都是Jenkins的调度过程)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jenkinsci.plugins.workflow.job.WorkflowRun#run</span><br></pre></td></tr></table></figure><p>整个Workflow总断点位置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jenkinsci.plugins.workflow.cps.CpsFlowExecution#start</span><br></pre></td></tr></table></figure><p>如果只关注Step相关流程，可以在这里进行分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.jenkinsci.plugins.workflow.cps.DSL#invokeMethod</span><br></pre></td></tr></table></figure></div><div class="tags"><a class="tag-link" href="/tags/CPS/" rel="tag">CPS</a><a class="tag-link" href="/tags/DP/" rel="tag">DP</a><a class="tag-link" href="/tags/FP/" rel="tag">FP</a><a class="tag-link" href="/tags/Groovy/" rel="tag">Groovy</a><a class="tag-link" href="/tags/Jenkins/" rel="tag">Jenkins</a></div></section><ul class="nav"><li>Prev:<a href="/linux%E9%9A%94%E7%A6%BB%E4%B8%8E%E8%B0%83%E5%BA%A6%E3%80%8Cnamespace%E3%80%8D/">Linux隔离与调度「Namespace」</a></li><li>Next:<a href="/%E8%87%AA%E5%AE%85%E4%BD%9C%E6%A5%AD%E3%81%AE%E5%8A%B9%E7%8E%87%E5%8C%96/">自宅作業の効率化</a></li></ul><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the<a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript></div></div></div></div><footer><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer><script>window.onload=function(){var a,e,n,t;a=window,e=document,t="script",n="ga",a.GoogleAnalyticsObject=n,a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=+new Date,n=e.createElement(t),t=e.getElementsByTagName(t)[0],n.async=1,n.src="//www.google-analytics.com/analytics.js",t.parentNode.insertBefore(n,t),ga("create","UA-102296742-1","auto"),ga("send","pageview")}</script></body></html>