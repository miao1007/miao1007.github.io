<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="随着物联网与O2O业务的发展，NFC在小额支付领域的前景越来越广阔。本文结合多个公开文档，简要介绍了NFC的工作场景，同时使用RxAndroid实现了对NFC字节流的读取与异常捕捉；使用了MVP(好吧，其实是一个简单的静态代理)转移了Activity下的代码量；介绍了卡模拟过程中与Android底层的交互原理与简单示例。"><meta name="keyword" content="Android,NFC"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Android下的基于NFC的金融业务开发</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body class="container"><header id="header"><div class="header"><div class="header-left"><div class="author"><div class="author-name"><a href="/">諺</a></div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">Archives</a></li><li style="font-size:.9rem"><a href="/archives" rel="nofollow">zh</a></li><li style="font-size:.9rem"><a href="#" rel="nofollow">|</a></li><li style="font-size:.9rem"><a href="/en" rel="nofollow">en</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">Epistemology</a></li><li><a href="/books" rel="nofollow">読書</a></li></ul></div></div></header><div class="content-wrapper"><div class="post"><section class="article"><div class="title">Android下的基于NFC的金融业务开发</div><div class="date">2016-09-23に投稿</div><div class="content"><p>随着物联网与O2O业务的发展，NFC在小额支付领域的前景越来越广阔。本文结合多个公开文档，简要介绍了NFC的工作场景，同时使用RxAndroid实现了对NFC字节流的读取与异常捕捉；使用了MVP(好吧，其实是一个简单的静态代理)转移了Activity下的代码量；介绍了卡模拟过程中与Android底层的交互原理与简单示例。</p><span id="more"></span><hr><h1>1. NFC工作模式</h1><h4>1.1. 读卡器模式</h4><p>直接操作“NFC Tag”对象对实体卡片进行I/O操作，目前的NFC卡片大多都是运行Applet服务的嵌入式JAVA虚拟机（俗称CPU卡，比较贵，这个卡的性能非常弱，只能进行写改删查操作），我们通过AndroidAPI连接后，就可以使用各种字节命令（APDUS）控制卡片。比如网上的“公交卡充值/查询”APP就是与公交公司合作的读卡器。</p><h4>1.2. 点对点模式</h4><p>使用 <code>Android Bean</code> 技术进行点对点通信，NFC本身速度很慢，所以这项技术最多的场景就是通过两台同品牌手机的NFC私有的应用协议数据单元(APDU)配对，然后建立高速的蓝牙/WIFI通信进行数据交换，以节约适配蓝牙/WIFI的时间。比如高端蓝牙耳机QC35就支持NFC快速配对。</p><h4>1.3. 卡模拟模式</h4><p>这个场景下，我们可以把手机看成一张“公交卡/银行卡”。真正的应用过程在上级应用层与物理加密芯片之间。建行的&quot;Quick Pass&quot;/ApplePay等技术就是基于此的。</p><h5>1.3.1. 虚拟卡模式(Virtual Card Mode)</h5><p>某些手机内置了安全芯片(SE，Secure Element)，比如</p><ol><li>SD卡（银联主推）</li><li>手机内置（Embeded，终端厂商主推）</li><li>SIM卡内置（运营商主推），经过测试我的电信4G天翼卡就是支持卡模拟的</li></ol><p>这些芯片的内部实际上运行一个微型JAVA虚拟机，，一个卡（手机）可以装多个applet，它有自己的证书，上层协议是卡片与芯片内置的Applet进行加密交互。通过OAT（空中发卡）业务可以实现把服务器中的Applet二进制文件下载到手机芯片中（是不是有点像HotFix技术？），俗称“卡包”。</p><p>举个例子，我通过软件下载了“深圳通”“招商银行”两个applet到手机内置芯片中。当我要刷公交卡时，公交车上的机器将进行如下操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 公交卡applet <span class="keyword">from</span> applets</span><br><span class="line"><span class="keyword">select</span> 余额文件块  <span class="keyword">from</span>  公交卡applet</span><br><span class="line">...i<span class="operator">/</span>o work...</span><br></pre></td></tr></table></figure><p>它最大的好处就是写入了Applet后，手机没电了同样可以刷卡使用（取决于电路设计）。而且它支持多张卡，节约空间。</p><h5>1.3.2. 主机卡模式(Host Card Mode)</h5><p>在<a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/connectivity/nfc/hce.html">Android文档</a>中可以看到，谷歌在Kitkat后，提供了一种HCE(Host Card Emulation)的方法，只要在Android开发中继承<code>HostApduService</code>服务（类似于J2EE中的Applet），就可以实现软件上进行卡模拟，当然这类的应用层的安全性非常重要，最终还是通过云服务的一些Token/证书进行交互。以后移动互联网公司可能会在这个地方发力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CardReader &lt;----&gt; NFCAdapter &lt;----&gt; HostApduService &lt;----&gt; BackendCloudServer</span><br></pre></td></tr></table></figure><hr><h1>2. NFC的传输层协议栈</h1><blockquote><p>JAVA中 <code>byte</code> 是有符号一字节的，而<code>char</code>是编码过的两个字节的；C中<code>byte(也就是#define byte (unsigned char))</code>是无符号一个字节的，而<code>char</code>是有符号一字节的; 为了方便，我们全部使用byte与16进制进行表示</p></blockquote><p>APDU的数据结构如图，本质是一种编码，网上有很多序列化/反序列化的工具</p><p>发送的数据报</p><p><img src="http://upload-images.jianshu.io/upload_images/98641-aa5ffac3533ce404.png" alt="简书不支持table标签！！"></p><p>返回值是</p><p><img src="http://upload-images.jianshu.io/upload_images/98641-1607939682b49e16.png" alt="居然不支持table！"></p><hr><h1>3. NFC读卡器的Android开发</h1><h2>3.1. 配置Manifest</h2><p>配置权限与feature</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Use NFC feature and Permissions--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.NFC&quot;</span>/&gt;</span></span><br><span class="line">&lt;uses-feature</span><br><span class="line">  android:name=&quot;android.hardware.nfc&quot;</span><br><span class="line">  android:required=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><p>注意配置Activity的模式为<code>singleTop</code>，配置Activity不可转变屏幕（防止Intent丢失，支付宝也是这样做的）,配置NFCTech过滤器，配置Intent接收器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.NfcReaderActivity&quot;</span><br><span class="line">    android:launchMode=&quot;singleTop&quot;</span><br><span class="line">    android:alwaysRetainTaskState=&quot;true&quot;</span><br><span class="line">    android:label=&quot;@string/title_activity_nfcscanner&quot;&gt;</span><br><span class="line"></span><br><span class="line">      .....</span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--nfc filter--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.nfc.action.TECH_DISCOVERED&quot;</span> <span class="attr">android:resource</span>=<span class="string">&quot;@xml/nfc_tech_filter&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.nfc.action.TECH_DISCOVERED&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.nfc.action.TAG_DISCOVERED&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置NFC卡片技术过滤器，每个卡对应一个<code>&lt;tech-list&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--file nfc_tech_filter.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--重庆一卡通--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tech-list</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ISO 14443-4--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tech</span>&gt;</span>android.nfc.tech.IsoDep<span class="tag">&lt;/<span class="name">tech</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ISO 14443-3A--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tech</span>&gt;</span>android.nfc.tech.NfcA<span class="tag">&lt;/<span class="name">tech</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tech-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h2>3.2. 获取Intent</h2><p>在Activity中针对收到的Intent进行处理，onCreate是从其他App进入的情况，onNewIntent是已经在本App中收到新的Intent的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_nfcscanner);</span><br><span class="line">    handleIntent(getIntent());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onNewIntent(intent);</span><br><span class="line">    handleIntent(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来处理Intent，获取到Tag对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取到Intent的Action，注意多打Log</span></span><br><span class="line">  Log.d(TAG, <span class="string">&quot;handleIntent: &quot;</span> + intent.getAction());</span><br><span class="line">  <span class="keyword">if</span> (!intent.getAction().equals(NfcAdapter.ACTION_TECH_DISCOVERED)) &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;handleIntent: no valid action&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取Tag对象</span></span><br><span class="line">  tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);</span><br><span class="line">  <span class="comment">//获取卡ID，这个ID一般没什么用，有可能是卡自动生成的</span></span><br><span class="line">  Log.d(TAG, <span class="string">&quot;Id:&quot;</span> + Util.byteArraytoHexString(tag.getId()));</span><br><span class="line">  <span class="comment">//NFC卡片所支持的技术标准</span></span><br><span class="line">  Log.d(TAG, <span class="string">&quot;TechList:&quot;</span> + Arrays.toString(tag.getTechList()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>3.3. I/O处理</h2><p>接下来，我们通过Tag获取到I/O对象，通过字节流进行处理，这里的例子按照如下的标准进行解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISO-DEP (ISO 14443-4) 注意它与ISO-7816也是兼容的</span><br></pre></td></tr></table></figure><p>目前最完善的代码如下，基于RxAndroid进行异步处理，可以处理所有的异常，注意这里的<code>subscriber</code>是一个<code>RxAndroid</code>的回掉接口，它处理<code>成功</code>，<code>下一个</code>，<code>异常</code>这三个回掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;ResponseAPDU&gt; <span class="title">getResponseAPDUObservable</span><span class="params">(<span class="keyword">final</span> Tag tag,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">byte</span>... bytes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;ResponseAPDU&gt;() &#123;</span><br><span class="line">    <span class="meta">@WorkerThread</span> <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> ResponseAPDU&gt; subscriber)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tag == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscriber.onError(<span class="keyword">new</span> NullPointerException(</span><br><span class="line">            <span class="string">&quot;Tag is null,try again to turn on NFC and keep your card close to your phone!&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bytes == <span class="keyword">null</span> || bytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">        subscriber.onError(</span><br><span class="line">            <span class="keyword">new</span> NullPointerException(<span class="string">&quot;apdu is null or empty, cheak your command!&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      IsoDep iso = IsoDep.get(tag);</span><br><span class="line">      <span class="keyword">byte</span>[] result_all;</span><br><span class="line">      <span class="comment">//NfcA iso = NfcA.get(tag);</span></span><br><span class="line">      <span class="keyword">if</span> (iso == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscriber.onError(<span class="keyword">new</span> NullPointerException(<span class="string">&quot;Tech was not enumerated in NfcTechList&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      iso.setTimeout(<span class="number">5000</span>);<span class="comment">//ms</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!iso.isConnected()) &#123;</span><br><span class="line">          iso.connect();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          iso.close();</span><br><span class="line">          iso.connect();</span><br><span class="line">        &#125;</span><br><span class="line">        result_all = iso.transceive(bytes);</span><br><span class="line">        subscriber.onNext(ResponseAPDU.createFromPdu(result_all));</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        subscriber.onError(e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (iso != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            iso.close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">            subscriber.onError(ignored);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UI线程下，进行如下的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RxAndroid的回掉</span></span><br><span class="line">Subscriber subscriber = <span class="keyword">new</span> Subscriber&lt;ResponseAPDU&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;onCompleted:&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    mTextView_response.setText(e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(ResponseAPDU responseAPDU)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;onNext:&quot;</span> + responseAPDU.toString());</span><br><span class="line">    mTextView_response.setText(responseAPDU.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getResponseAPDUObservable(tag, data)</span><br><span class="line">    .subscribeOn(Schedulers.newThread())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure><blockquote><p>这里还有很大的优化空间，比如加入 keep-alive 机制，避免每读写一次都重新打开关闭流，当然这个需要与场景进行适配</p></blockquote><p>##3.4. 封装成高级对象(DTO)</p><p>通过以上步骤，我们能够得到一个简单的基于字节流的NFC读取器，但是更加进一步的开发（比如查询命令，SDK等）需要卡厂商提供内部公开的SDK，均有私钥的，就不能具体写了。有兴趣的可以去网上搜索<code>PBOC2.0</code>，网上有泄露的代码，貌似是GPL协议，各位慎重学一下。这个开发一点都不难，封装好I/O后，写改删查即可，主要难点在能够与公交公司谈拢（人家说不定看不上你，当然这个活不是程序员干的），以及谈拢后与对方开发进行联调。</p><hr><h1>4. NFC的卡模拟</h1><p>从12年开始，随着O2O的发展，国外的品牌手机都开始加入了对SE芯片的支持，中华酷联也开始加入了对SE卡的支持。</p><h2>4.1. 判断手机是否支持SE</h2><p>手机中必须有如下的文件，这是一个开源的项目，各大手机厂商都毫不吝啬的使用了，注意SmartcardService需要在后台运行才能调用，某些ROM被精简了，12年以后的高档机（比如三星，Sony大法）到现在的千元机（比如魅蓝NOTE）的ROM中一般都有这个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;system&#x2F;framework&#x2F;org.simalliance.openmobileapi.jar </span><br><span class="line">&#x2F;system&#x2F;app&#x2F;SmartcardService.apk</span><br></pre></td></tr></table></figure><p>如果没有的话，会报错ClassNoFoundException，这里我也没有比较好的解决方案，建议先放着，优先把支持的机子给适配好。</p><h2>4.2. AndroidSE的通信架构</h2><p>经过阅读开源代码，交互流程如下，NFC卡模拟开发实际上是基于Binder的，对AIDL与Binder通信需要有理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Activity(调用者)</span><br><span class="line">	 ↑</span><br><span class="line">	 | ServiceConnection</span><br><span class="line">	 ↓	</span><br><span class="line">SmartcardService:remote</span><br><span class="line">	 ↑</span><br><span class="line">	 | Parcel</span><br><span class="line">	 ↓	</span><br><span class="line">SmartcardService</span><br><span class="line">	 ↑</span><br><span class="line">	 | ServiceConnection</span><br><span class="line">	 ↓	</span><br><span class="line">com.android.internal.telephony.ITelephony:remote</span><br><span class="line">	 ↑</span><br><span class="line">	 | Parcel</span><br><span class="line">	 ↓	</span><br><span class="line">com.android.internal.telephony.ITelephony</span><br><span class="line">	 ↑</span><br><span class="line">	 | transmitIccBasicChannel()</span><br><span class="line">	 ↓	</span><br><span class="line">Framwork(JNI&#x2F;HAL&#x2F;Kernal)</span><br></pre></td></tr></table></figure><p>上文中的 <code>:remote</code>实际上就是 <code>Stub.asInterface()</code>实现远程打桩的代理调用，类似于Spring中的依赖查找。当然在SDK端，只用写AIDL即可，甚至SDK都被写好了。</p><blockquote><p>Binder机制实际上是基于 <code>ASHMEM(匿名共享内存)</code> 的IPC</p></blockquote><p>##4.3. 开发卡模拟</p><p>在AndroidStudio中，需要注意jar包的依赖形式，由于这个包是已经在系统框架中使用了，防止classloader重复加载，所以这个jar包不能打包到app中，只用在编译时设置为<code>provided</code>即可</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>], <span class="attr">exclude:</span> [<span class="string">&#x27;org.simalliance.openmobileapi.jar&#x27;</span>], <span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>)</span><br><span class="line">    <span class="comment">//provided表示只在编译时使用jar包，运行时默认环境中已经存在这个jar包了</span></span><br><span class="line">    <span class="comment">//jar包在网上有下载，注意要与ROM版本一直，不要一味求最新</span></span><br><span class="line">    provided files(<span class="string">&#x27;libs/org.simalliance.openmobileapi.jar&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的事情都交个openmobileapi的<a target="_blank" rel="noopener" href="https://code.google.com/p/seek-for-android/wiki/UsingSmartCardAPI">SDK</a>了，SDK提供了基于字节流的通信，我们可以使用okio这样的工具来转换字节与string，当然更高级的使用涉及到厂商的私钥，一般通过TSM发卡厂商提供的私有SDK与密钥进行更高层的封装（反正这些都有SDK），就完成开发了。</p><p>注意两点：</p><ol><li>回调是在Binder线程池中，所以注意谨慎操作UI组件</li><li>onDestory时注意释放连接</li></ol><h1>5. Source Code</h1><p>代码详见我的<a target="_blank" rel="noopener" href="https://github.com/miao1007/EasyNfc/">Github示例</a>，只保留了基于字节流的查询功能。<br><strong>NFC开发是大坑</strong>，适配很累，而且在第三方联调上很费时间，属于那种吃力不讨好最后又啥都没学到的。我不建议深入折腾</p><h1>参考</h1><ol><li><a target="_blank" rel="noopener" href="http://wiki.mbalib.com/wiki/%E4%B8%BB%E6%9C%BA%E5%8D%A1%E6%A8%A1%E6%8B%9F">http://wiki.mbalib.com/wiki/主机卡模拟</a></li><li><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/embedded/javacard/index2-136727.html">http://www.oracle.com/technetwork/java/embedded/javacard/index2-136727.html</a></li><li><a target="_blank" rel="noopener" href="http://www.cardwerk.com/smartcards/smartcard_standard_ISO7816-4_5_basic_organizations.aspx#table18">http://www.cardwerk.com/smartcards/smartcard_standard_ISO7816-4_5_basic_organizations.aspx#table18</a></li><li><a target="_blank" rel="noopener" href="http://www.wendangpan.com/702645731/">http://www.wendangpan.com/702645731/</a></li></ol></div><div class="tags"><a class="tag-link" href="/tags/Android/" rel="tag">Android</a><a class="tag-link" href="/tags/NFC/" rel="tag">NFC</a></div></section><ul class="nav"><li>Prev:<a href="/%E6%8E%A2%E7%A9%B6android%E7%9A%84%E5%86%B7%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">探究Android的冷启动优化</a></li><li>Next:<a href="/%E5%85%B3%E4%BA%8Enull%E3%80%81empty%E4%B8%8Eexception%E7%9A%84%E6%80%9D%E8%80%83/">关于Null、Empty与Exception的思考</a></li></ul><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the<a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript></div></div></div></div><footer><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer><script>window.onload=function(){var a,e,n,t;a=window,e=document,t="script",n="ga",a.GoogleAnalyticsObject=n,a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=+new Date,n=e.createElement(t),t=e.getElementsByTagName(t)[0],n.async=1,n.src="//www.google-analytics.com/analytics.js",t.parentNode.insertBefore(n,t),ga("create","UA-102296742-1","auto"),ga("send","pageview")}</script></body></html>