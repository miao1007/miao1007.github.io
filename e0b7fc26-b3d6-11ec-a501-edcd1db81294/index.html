<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="Github上有许多仿iOS的dialog，但是都没有让背景模糊，第三方的view太坑，不如自己对着iOS模拟器的图与动画做出来。耗费了很久时间终于搞定了，如下图，左边是仿iOS的dialog，右边是SupportV7的dialog。"><meta name="keyword" content="Android"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>打造高仿iOS的BlurDialog</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">打造高仿iOS的BlurDialog</div><div class="date">2016-09-23 / modified at 2022-04-04</div><div class="content"><blockquote><span>️This article has been <strong>over 1 years</strong> since the last update.</span></blockquote><p>Github上有许多仿iOS的dialog，但是都没有让背景模糊，第三方的view太坑，不如自己对着iOS模拟器的图与动画做出来。耗费了很久时间终于搞定了，如下图，左边是仿iOS的dialog，右边是SupportV7的dialog。</p><span id="more"></span><p><img src="http://upload-images.jianshu.io/upload_images/98641-2406b6c426f6f111.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BlurDialog"></p><h2>Dialog 生命周期的简要分析</h2><p>在构造函数时，创建了一个window，并设置了相关window属性。</p><p>当调用 <code>show()</code>时，首先调用了 <code>onCreate</code> 与 <code>onStart</code>（都是一些无关紧要的方法），最后通过 <code>WindowManager</code> 添加了 window 中的 DecoView，从这里开始，view就要开始走绘制流程了。</p><p>当调用 <code>dismiss()</code> 时，通过 <code>WindowManager</code> 移除了 View，并调用<br><code>onStop()</code> 执行可能的清理任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@see #Dialog (setUp window inside)</span><br><span class="line"></span><br><span class="line">@see #show()</span><br><span class="line"></span><br><span class="line">- @see #onCreate(Bundle) (call setContentView here)</span><br><span class="line"></span><br><span class="line">- @see #onStart()</span><br><span class="line"></span><br><span class="line">- mWindowManager.addView(mDecor, l);</span><br><span class="line"></span><br><span class="line">@see #dismiss()</span><br><span class="line"></span><br><span class="line">- mWindowManager.removeViewImmediate(mDecor);</span><br><span class="line"></span><br><span class="line">- @see #onStop() (clean work)</span><br></pre></td></tr></table></figure><p>如果我们需要自定义一个dialog，只需要在 <code>show()</code> 之前配置好 window 的属性，以及在 <code>onCreate()</code> 中将自定义的 xml 布局初始化即可。</p><blockquote><p>在 <code>mWindowManager.addview()</code> 之前，除非指定了 view 的dp高宽，否则输出的view高度等数据将是0，-1之类的值。为了获得准确的值，可以使用 <code>view.post()</code> 将消息入队，这样可以获取到正确的数据。</p></blockquote><p>##BlurAlertDialog 的实现</p><p>通过post入队即可，入队主要是为了准确测量偏移量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//初始化 BlurDrawable 的样式</span><br><span class="line">//`mRvFragCard`表示在底层的将要被模糊的View</span><br><span class="line">BlurDrawable drawable = new BlurDrawable(mRvFragCard);</span><br><span class="line"></span><br><span class="line">dialog.getWindow().getDecorView().post(new Runnable() &#123;</span><br><span class="line">  @Override public void run() &#123;</span><br><span class="line">  	//设置边缘圆弧的 dp</span><br><span class="line">    drawable.setCornerRadius(xxDp);</span><br><span class="line">    // 设置绘制偏移量</span><br><span class="line">    // 坐标为相对整个屏幕，dialog最左边，最上面的点</span><br><span class="line">    drawable.setDrawOffset(x,y);</span><br><span class="line">    dialog.getWindow().setBackgroundDrawable(drawable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dialog.show();</span><br></pre></td></tr></table></figure><blockquote><p>模糊效果可以参考我之前写的 <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/93475df308b8">BlurDrawable</a></p></blockquote><blockquote><p>注意不能用系统自带的dialog，因为它的内部是不开放的（也就是红色的代码），window创建流程也不透明，可能会抛出异常。</p></blockquote><h2>示例地址</h2><p><a target="_blank" rel="noopener" href="https://github.com/miao1007/AnimeWallpaper">本文项目</a></p><p>本部分完，需要ui的直接clone即可。</p><hr><p>以下为冗长的理论资料</p><h2>Window 与 WindowManager</h2><ul><li><p>window是对整个view的一套管理，对开发者来说仅仅是接口。<code>PhoneWindow</code> 是对 <code>window</code> 的抽象方法的实现，手机ROM厂商可以修改或者实现它，而开发者只能反射调用<code>PhoneWindow</code>的一些功能。</p></li><li><p>WindowManager是系统服务，负责view绘制。它对开发中看来也只是一个接口，通过 <code>getSystemService</code> 即可获得。</p></li></ul><p>接口由ROM实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/system/framework/framework.jar</span><br></pre></td></tr></table></figure><p>反编译jar后，可以获得对象 <code>android.view.WindowManagerGlobal</code>，具体流程可以看<a target="_blank" rel="noopener" href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=555&amp;extra=page%3D1">这里</a>，我们只需要知道这个函数涉及到AIDL通信，并且它是异步回调的即可。</p><blockquote><p>在国产ROM常见的状态栏字体变色，悬浮Activity等特色功能，都是由 <code>WindowManager</code> 负责绘制的，通过在 Window 中写入某些flag，之后重绘的时候就能显示出独有的样式。</p></blockquote><h2>Dialog 下的 Window 布局</h2><p>此场景适用于最原始的 Activity 与 Dialog ，它们的 ViewTree 布局如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DecoView </span><br><span class="line"></span><br><span class="line">DecorContentParent</span><br><span class="line"></span><br><span class="line">ContentView(android.R.id.content)</span><br><span class="line"></span><br><span class="line">你写的xml布局</span><br></pre></td></tr></table></figure><p>通过 Dump 工具可以验证：</p><p><img src="http://upload-images.jianshu.io/upload_images/98641-f359da4dd81c11c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dump"></p><h3>1. DecoView</h3><p>在 <code>PhoneWindow</code> 中，它的变量名为 <code>mDecor</code> , 它是 window 中的 top-level 的view，通过 <code>installDecor()</code> 进行构造，它默认的大小是 <code>wrap_content</code>，我们通常所说的 <code>window.setXXX()</code> 本质上调用的就是 DecoView(与它的子view)</p><blockquote><p>网上有部分文章说 <code>DecoView</code> 不是top-level 的 View，这个说法是错的，各位可以手动设置 id 测试</p></blockquote><h3>2. DecorContentParent</h3><p>在 <code>PhoneWindow</code> 中，它的变量名为 <code>mDecorContentParent</code>，通过它可以设置 <code>Window</code> 中的Title，<code>requestWindowFeature</code> 等功能，它是一个宽泛的层，层次可能是一层（在NoActionBar，notitle的条件下），可能有多个层，上图就有3层。在实际开发中，我们一般也用不到（如果非要用的话，还是只能反射调用）。</p><p>举个例子，在最新的 AppCompatActivity 中，它重写的<code>setContentView</code> 中通过 <code>ensureSubDecor()</code> 方法手动填充几个夹层View，这个算一个应用案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setContentView(int resId) &#123;</span><br><span class="line">	//对mWindow.setContentView()的一道包装</span><br><span class="line">	//添加部分View, 比如Actionbar/Title/Toolbar</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>3. ContentView</h3><p>在 <code>PhoneWindow</code> 中，它的变量名为 <code>mContentParent</code>。我们日常接触的就是 <code>ContentView</code> 了，它包装着我们写的xml布局</p><p>contentView可以通过ID获得，这个id是内置的，如下两个是等价的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android.R.id.content</span><br><span class="line">Window.ID_ANDROID_CONTENT</span><br></pre></td></tr></table></figure><h3>4. xml布局</h3><p>我们自己写的xml布局，需要注意 inflate 方法中的boolean值，它控制当前view是否依附到 parent 中。</p><p>如果view本身需要被add时（比如dialog，activity），调用<code>setContentView()</code>即可，它将生成view并依附到parent中。</p><p>如果这个view并没有parent（比如viewholder）， 选择不依附即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflater.inflate(ResId, null, false);</span><br></pre></td></tr></table></figure><h2>总结</h2><ol><li>尽量在setcontentView之前调用window属性</li><li>涉及到长宽等内容时，因为view的显示是异步的，所以需要post发送，以免获得到的结果为0</li></ol></div><div class="tags"><a class="tag-link" href="/tags/Android/" rel="tag">Android</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>