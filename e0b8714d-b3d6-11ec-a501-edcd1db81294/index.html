<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="还在用C语言的方法进行for循环处理字符串吗？是时候使用Regex了。"><meta name="keyword" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>高效学习正则表达式Regex</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">高效学习正则表达式Regex</div><div class="date">2016-07-27 / modified at 2022-04-04</div><div class="content"><blockquote><span>️This article has been <strong>over 1 years</strong> since the last update.</span></blockquote><p>还在用C语言的方法进行for循环处理字符串吗？是时候使用Regex了。</p><span id="more"></span><p>以前看过30分钟入门等网站，最后大多数情况学了五分钟就放弃了，虽然也会用一点Regex，但是基本也就会一个<code>*</code>，没有系统的学习过，今天写一下常见的Regex应用场景。</p><ul><li>验证功能</li><li>词汇提取</li><li>找现成的表达式</li></ul><hr><h2>验证功能</h2><p>验证功能这个网上基本烂大街，就随便举例两个吧</p><h4>判断http地址</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断http地址</span></span><br><span class="line">^(http[s]?:\/\/)?[^\s]+</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这个也是顶级的域名，是可以在内网上存在的</span></span><br><span class="line">http:<span class="comment">//aabb/</span></span><br></pre></td></tr></table></figure><h4>计算器正则的验证(运算符，数字，括号，无空格)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^[\(\d]?[\d\+\-\*\/\(\)]*[\)\d]?$</span><br><span class="line"></span><br><span class="line"><span class="comment">//testcase</span></span><br><span class="line"><span class="number">3</span>+<span class="number">4</span>*<span class="number">5</span>-((<span class="number">4</span>+<span class="number">2</span>)/(<span class="number">3</span>+<span class="number">5</span>)+<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4>HTTP框架</h4><p>许多HTTP框架的路由功能都是通过Regex实现的，最后维护一个<code>List&lt;Pattern&gt;</code>，当有请求来时，对List进行for循环匹配。</p><h2>提取功能</h2><p>还在用Substring吗？是不是经常遇到数组越界？试试regex吧！此功能在Regex叫做Group，它在完成了Match之后才有用，我们在写正则表达式时，使用 <code>()</code>进行分组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">splitByRegex</span><span class="params">(String line,String regex)</span>&#123;</span><br><span class="line">    List&lt;String&gt; captures =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> Pattern.compile(regex).matcher(line);</span><br><span class="line">    <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; matcher.groupCount() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            captures.add(matcher.group(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> captures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>提取地址</h4><p>比如我想提取HTTP字符串中的地址，除了自带的URI类以外，还可以用Regex，比如运行下面的匹配，被括号括住的表示将被提取出来。</p><p>输出将是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;https://mediatemple.net&quot;</span>;</span><br><span class="line">splitByRegex(s,<span class="string">&quot;MESSAGE \&quot;(\w*)\&quot; CODE (200)&quot;</span>) =&gt; [mediatemple.net]</span><br></pre></td></tr></table></figure><h4>提取命令</h4><p>这个在一些硬件类的通信或者<strong>某些OJ题目</strong>中经常出现（特别是某为），需要自己实现Parse，比如下面是某个输入命令，我希望提取其中去掉引号的消息与CODE</p><p>输出是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;MESSAGE \&quot;HELLO\&quot; CODE 200&quot;</span>;</span><br><span class="line">splitByRegex(s,<span class="string">&quot;MESSAGE \&quot;(\w*)\&quot; CODE (200)&quot;</span>) =&gt; [HELLO,<span class="number">200</span>]</span><br></pre></td></tr></table></figure><h4>短信提取</h4><p>这个在网上貌似有很多开源的方案，下文是一个例子，当然比不上手机ROM自带的云识别，但是还是可以凑合用的，如下（省略Java代码）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//regex</span></span><br><span class="line">您尾号[\d]&#123;<span class="number">4</span>&#125;卡([\d]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;月[\d]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;日)([\d\d]&#123;<span class="number">2</span>&#125;:[\d\d]&#123;<span class="number">2</span>&#125;)POS支出\(消费\)([\d,.]*)元，余额([\d,.]*)元。【工商银行】$</span><br><span class="line"></span><br><span class="line"><span class="comment">//testcase</span></span><br><span class="line">您尾号<span class="number">1234</span>卡<span class="number">7</span>月<span class="number">27</span>日<span class="number">18</span>:27POS支出(消费)<span class="number">20</span>元，余额<span class="number">3</span>,<span class="number">062.13</span>元。【工商银行】</span><br><span class="line"></span><br><span class="line"><span class="comment">//result</span></span><br><span class="line">[<span class="number">7</span>月<span class="number">27</span>日,<span class="number">18</span>:<span class="number">27</span>,<span class="number">20</span>,<span class="number">3</span>,<span class="number">062.13</span>]</span><br></pre></td></tr></table></figure><p>再来一个Uber的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//regex</span></span><br><span class="line">^【UBER优步】.*(\d&#123;<span class="number">4</span>&#125;).*</span><br><span class="line"></span><br><span class="line"><span class="comment">//testcase</span></span><br><span class="line">【UBER优步】还有一步，即可享受时尚风格、非凡体验。输入 <span class="number">9445</span> 以确认您的账户。</span><br><span class="line"></span><br><span class="line"><span class="comment">//result</span></span><br><span class="line">[<span class="number">9445</span>]</span><br></pre></td></tr></table></figure><h2>路由功能</h2><p>如下是简单正则表达式路由实现，Consumer是JDK8中的forEach回掉接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Consumer&lt;List&lt;String&gt;&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">route</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        map.keySet().forEach(regex -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (message.matches(regex)) &#123;</span><br><span class="line">                map.get(regex).accept(splitByRegex(message, regex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String regex, Consumer&lt;List&lt;String&gt;&gt; consumer)</span> &#123;</span><br><span class="line">        map.put(regex, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本部分可用于解析硬件命令、高难高耗时OJ的任务。</p><blockquote><p>多路由情况下，可能匹配被覆盖，此时考虑使用惰性求值<code>(xxx?)</code></p></blockquote><h2>More</h2><p>更多的例子可以在</p><ul><li><a target="_blank" rel="noopener" href="http://regexlib.com/Search.aspx?k=money&amp;c=-1&amp;m=-1&amp;ps=20">RegexLib</a>上去搜索现成的库</li><li>参考 JavaGrok，PyGrok等项目实现更完善的正则表达式</li></ul><h4>Intellij</h4><p>在Intellij下，可以点击正则表达式的位置，然后<code>Alt</code> + <code>Enter</code>，可以直接Inject Language，或者进行Regex的编辑与Check，希望大家能够用到。</p><h4>Sed命令</h4><p>调试后台报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出现 Caused by后立即停止滚动，以便看原因</span></span><br><span class="line">tailf catalina.log | sed -e <span class="string">&quot;/Caused by/q&quot;</span></span><br></pre></td></tr></table></figure><p>使用ag进行查询</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find urls in markdown file</span></span><br><span class="line">ag -o <span class="string">&#x27;\[(.+)\]\((http[s]?://[\w\d/\.]+)\)&#x27;</span> --nofile --nonumber **/*.md</span><br></pre></td></tr></table></figure><p>使用rg进行查询</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parse kv in package.json</span></span><br><span class="line">rg <span class="string">&#x27;\s+&quot;(.+)&quot;:\s+&quot;(.+)&quot;&#x27;</span> package.json -r <span class="string">&#x27;$1|$2&#x27;</span> -NI</span><br><span class="line"></span><br><span class="line"><span class="comment"># find urls in markdown file</span></span><br><span class="line">rg <span class="string">&#x27;\[(.+)\]\((http[s]?://[\w\d/\.]+)\)&#x27;</span> -r <span class="string">&#x27;$1 |  $2&#x27;</span> -NIoU  -t md | grep -v <span class="string">&#x27;|&#x27;</span></span><br></pre></td></tr></table></figure><p>简单的递归下降<a target="_blank" rel="noopener" href="https://github.com/jenkinsci/jenkins/blob/85797ebe63425844d922ca8ef6bb77f8aad1951b/core/src/main/java/hudson/Util.java#L185">Parser</a>实现处理dollar符号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern.compile(<span class="string">&quot;\\$([A-Za-z0-9_]+|\\&#123;[A-Za-z0-9_.]+\\&#125;|\\$)&quot;</span>);</span><br></pre></td></tr></table></figure><h2>关于高效学习的一点心得</h2><p>如果自己愿意花时间学的话，建议参考</p><ol><li>电子书《学习正则表达式》(图灵程序设计丛书)</li><li><a target="_blank" rel="noopener" href="http://regexr.com/">http://regexr.com/</a>，内部有example与expian功能，方便理解</li></ol><blockquote><p>关于书，个人推荐去下载Kindle电子版，搬家方便，不推荐去网上找盗版书。各位月收入上万的哥们，每小时的工作收入税前至少50，消费了自己的时间去找扫描的低质量书籍，不如直接买更划算。</p></blockquote><p>学习总成本：</p><ol><li>一本电子书书，20块搞定，跨平台，随时读</li><li>3个晚上业余时间，包括阅读与码字，约8小时</li></ol><p>学习成果：</p><ol><li>Regex的匹配与提取代码编写</li><li>Regex在Intellij与在线网站的调试经验</li></ol><p>百忙之中，学了一点，还是挺划得来。</p><blockquote><p>当然，后续又花了2个月的学习，总之正则表达式与Shell一样，适合现学现用。</p></blockquote></div><div class="tags"></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>