<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="开源版K8S以繁琐复杂而闻名，本文是在其基础上的常见加固方案。"><meta name="keyword" content="DevOps,Kubernetes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>K8S与常见加固</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">K8S与常见加固</div><div class="date">2022-03-27 / modified at 2023-02-20</div><div class="content"><p>开源版K8S以繁琐复杂而闻名，本文是在其基础上的常见加固方案。</p><span id="more"></span><h4>背景</h4><p>安全是一门非常专业的领域，同时也是奢侈品。本文仅介绍常见加固场景，但是并无法枚举。如果正式上线，建议进行专业的安全/隐私/合规的认证或者渗透测试。</p><p>作为业务开发人员甚至架构人员，一般来说是没法100%搞定安全的，因为无论你的设计经验多么丰富，你的知识库也难以跟上天天专职训练的安全团队，尤其是很多安全人员都是野生的，我个人认识的安全从业者即使拿了多个ACK也经常抑郁能力不行。</p><p>参考方向</p><ul><li>尽可能将问题转移给下游（比如Vault/KMS/PKI等通过多个审计标准的云服务，而不要自己尝试开发与长期更新维护安全组件）</li><li>尽可能参考现有的标准实施（比如隔离、策略、分级等要求，可以参考巨硬的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/compliance/regulatory/offering-home">标准</a>），这个也是要花钱找第三方刷测试的。比如你的应用刷过了10个知名测试，用户肯定更放心</li><li>尽可能从理论维度去枚举安全问题，毕竟不可能专职训练，而且经验/漏洞也会半衰贬值</li></ul><h2>产品安全生命周期</h2><p>应用安全不仅仅要求在机房侧实施，躲在防火墙后面就可以了，而是需要从需求分析开始做。</p><p>此文写得何等好啊：<a target="_blank" rel="noopener" href="https://xinsheng.huawei.com/cn/index.php?app=forum&amp;mod=Detail&amp;act=index&amp;id=4134815">参考地址</a></p><h2>供应链加固</h2><h4>静态安全问题（Vulnerable and Outdated Components）</h4><ul><li>静态扫描：<ul><li>编程语言级别的问题，比如memcp/反射/eval/SQL等，这种是很成熟的方案了，比如cppcheck、sonarqube，coverity等工具</li><li>开源片断：分析是否使用了GPL的片段（广义上不算安全问题）</li><li>IaaS扫描：HCL(Terraform)/Dockerfile/yaml也需要扫描。比如conftest就依赖了OPA作为规则引擎去执行校验，但是当前还是比较初级的阶段。</li></ul></li><li>第三方库的BOM跟踪：比如log4j出现问题后，可以实现立刻反查涉及到的软件（这是一个典型的图数据库场景）与CVE缺陷。<ul><li>跟踪mvn、pip、npm等依赖版本，以及镜像中<code>apt-update</code>的latest版本。</li><li>可以用OWASP的dependency-check扫描maven的tree，然后上报到sonarqube/CycloneDX等BOM平台</li><li>也可以用OWASP来扫描artifactory仓库的hash值，或者使用JFrog的XRay收费服务</li><li>甚至可以直接暴力反查当前容器中的jar包</li></ul></li></ul><p>这条很难，需要大量人力去维护软件的物料编码，相当于打造了软件的”ERP“系统。这里同时也要确保应用功能是用例完善的，否则升级版本成本很高。</p><h4>CI可信构建（Software and Data Integrity Failures ）</h4><p>这里要求整个从提交代码、构建、发布与签名的流程都需要可信，也有人把它叫做DevSecOps，涉及的知识面太广，最好能做到<code>源码-二进制一致性</code>，即任何时候通过某个tag打包，它的二进制都是可以复现的。这个流程过于烧钱，因此不过多讨论，可以<a target="_blank" rel="noopener" href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">参考这里</a>或者<a target="_blank" rel="noopener" href="https://www.manning.com/books/securing-devops">这里的书</a>。</p><p>构建系统大致有如下几种实现（Provision）</p><ul><li>通过VM/PM直接构建，比如HPC/EC2等，缺点是运维成本高，资源池化率低，经常一边超售一边空闲。</li><li>通过专业HPC调度器软件构建，比如LSF等，缺点是授权费、运维成本极高（比如LDAP/NFS等），安全上相对较好，因为默认是锁root的，只用了setUid来切换账号</li><li>基于Docker+PaaS进行调度，比如K8S/nomad，著名的CircleCI就是通过Nomad实现任务调度的，这里难点主要是docker in docker的构建，需要绑定daemon的socket文件，进而可以反向逃逸host的root。这里有一个小优化，假如宿主机安装了docker，那么docker内只需要单个docker文件即可使用，而不需要大量的依赖。</li><li>daemon-less构建：在上面Docker的基础上，使用kaniko等定制镜像实现docker-in-docker，注意在kaniko镜像中，仍然需要root权限去执行dockerfile的apt-update等任务，并非完全的rootless。而且可能需要与Jenkins的image混到一起。</li></ul><h4>（可选）二进制可逆性</h4><p>在源码（分支、TAG）、编译器版本（比如node/jdk）、二进制管理（jar包、docker image）等管理流程中，尽可能做到可逆性，即向交付用户源码自证清白，并由用户审计源码，甚至按照文档自行编译产生的二进制也能实现hash一致（时间除外）。</p><p>涉及到的工具</p><ul><li>Gitlab等托管工具</li><li>Artifactory等二进制储存工具（比如编译器的版本）</li><li>混合的需要版本的二进制管理,比如使用Perforce Helix Core</li><li>构建镜像与构建工具的版本管理：不建议通过将jdk/mvn/node等工具拷贝到构建镜像的单体中，也不建议通过yum等工具安装到根目录，而是建议专门维护一个只读的目录（nosuid/root_squash/ro）直接挂载（类似Github的方案），甚至使用Environment Module的方案直接rsync过去，否则构建镜像可能太胖。编译器的版本等元数据，可以通过Artifactory属性打入二进制中。</li></ul><p>这里同样也是需要大量人力的任务，一般只有ToB产品与量产硬件才需要</p><h2>运行时加固</h2><h4>运行时静态检查</h4><p>首选基于业界实践，先用自动化工具扫描下问题，让大家干活先搞起来。比如jar包版本，tomcat版本等。</p><h4>使用加固的容器环境</h4><ul><li>rootless容器：这个虽然有，但是当前生产还没人敢上，尤其是mount操作容易出现uid混乱的问题。</li><li>SYS_CAP限制：至少限制如下两个<ul><li>限制setuid</li><li>限制mount等操作，避免挂载<code>chmod+s 比如4755</code>，配置只读FS（readOnlyRootFilesystem）</li></ul></li></ul><h2>应用程序源码中的凭证加密（Cryptographic Failures ）</h2><h4>背景</h4><p>在源码的配置文件（比如application-prod.yml）中，一般会涉及到“RSA私钥/数据库密码/AKSK”等配置，假如明文存储这些信息，一旦</p><ul><li>源码库泄漏（比如没有二次认证，被员工上传到Github，开放的sonarqube仓库）</li><li>服务器OS被攻破/代码被逆向（比如简单的stings/strace命令，或者汇编逆向）</li><li>开发员工离职时拖库（因为拥有生产数据库的连接串）</li></ul><p>这时业务就会遭到重要损失。</p><p>对此，有如下方案将安全问题转嫁给更下层（PaaS与云服务）</p><h4>配置文件加密</h4><p>常见项目举例如下，这里一般仍然是对称加密，它们将问题转嫁给了某个密钥</p><ul><li>spring项目：参考jasypt，支持多种算法，支持加盐与自定义算法以提高破解困难，依赖<code>jasypt.encryptor.password</code></li><li>sonarqube：基于AES256对称加密，详见<a target="_blank" rel="noopener" href="https://docs.sonarqube.org/latest/instance-administration/security/">这里</a>，依赖<code>sonar.secretKeyPath</code>，注意sonar本身也是需要<a href="/tags/SonarQube">加固配置</a>的</li><li>nomad：将问题转嫁给了vault</li><li>Jenkins: 基于AES，依赖<code>$JENKINS_HOME/secrets/master.key</code>，实际上它解密位置过多，一点也不安全</li></ul><h4>密钥如何保存</h4><p>上述用来加密与还原的密钥，需要基于更底层的平台（trusted identity provider）来保存，比如需要chroot隔离，比如PID的env隔离与FS挂载隔离。或者权威安全服务。</p><p>在k8s中的secret配置就可以进行密钥注入，但是需要注意</p><ul><li>etcd本身应用、以及其物理存储介质的安全</li><li>sercet的ABAC配置（默认是base64编码，仍然namespace下的人都可以看）</li></ul><p>注意这里是与单点故障并存的，也涉及到一个key保存的递归问题。这种安全方案在开源产品中一般都不是很完善，而云厂商可以将Secret用硬件密码机等密钥管理服务（KMS， Secrets Manager等）的实现。</p><blockquote><p>上述操作只是提高了逆向难度，同时将安全问题仍给了PaaS层，而PaaS/云厂商本身是拥有解密密钥的，从技术角度上是可以读取到你的任何数据。</p></blockquote><h2>云上安全加固</h2><h4>Infra层加固</h4><ul><li>网络：配置独立的VPC、安全组等，比如只进不出策略。</li><li>OS：使用专用的加固OS，尤其是审计和防火墙</li></ul><h4>其他安全措施</h4><p>此外还有如下补充</p><ul><li>数据库/配置中心本身也需要部署到隔离的VPC，配置出入策略，仅允许应用服务器访问，而不是internet-exposed。</li><li>数据库/配置中心的IP地址，在应用侧推荐用VPC Endpoint/Peering/K8S external Service等类似Sidecar的方案去作为代理隐藏真实IP。</li><li>数据库与可视化可以用Pg-pool/redash等工具进行二层封装，并进行AOP拦截。</li></ul><h2>其他</h2><h4>投入产出</h4><p>在开源版本上集成社区的安全加固，需要专门的SRE团队来投入大量人力进行加固，一般来说是需要规模才有效益的，否则每天耗在CVE清单中就被耗死了。假如团队较小，建议直接用加固好的云服务。</p><h4>云服务厂商信任</h4><p>技术角度上，云服务商/权威数字签名提供商都能突破你的应用的机密性（比如偷看数据库，AI扫描你的S3）和完整性（比如CNNIC的签名）而且难以发现</p><ul><li>大部分国家有法律要求对内容进行本地化、审核和绿化（比如特斯拉、iCloud贵州），甚至法律制裁</li><li>云厂商的三权分立设计也是由程序开发，也可能有漏洞</li></ul><p>即使厂商本身不想看你的数据，也基于合规流程，雇佣了无数安全团队，通过了无数标准。它可以增强商业信心，但是无法形式化证明它的安全性，当前热点的有“全同态加密”方案，但是还没有普及。</p><h4>其他参考</h4><ul><li>常见编码安全问题：<a target="_blank" rel="noopener" href="https://owasp.org/www-project-top-ten/">https://owasp.org/www-project-top-ten/</a></li><li>常见标准：SOC标准（系统和组织控制 (SOC) 2），公安部安全等保等</li><li>H司的实践：<a target="_blank" rel="noopener" href="https://defense.one/d/12-sdl">https://defense.one/d/12-sdl</a> 这里文章吹太狠了，再次证明了PPT的强大</li></ul></div><div class="tags"><a class="tag-link" href="/tags/DevOps/" rel="tag">DevOps</a><a class="tag-link" href="/tags/Kubernetes/" rel="tag">Kubernetes</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>