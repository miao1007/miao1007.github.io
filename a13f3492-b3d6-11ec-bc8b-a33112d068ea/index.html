<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="本文整理了递归的历史和观点，并综述了各个时期的学者对递归的哲学思考。"><meta name="keyword" content="Ontologies,Philosophy,Recursion,Time"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>递归相关的形而上思考整理</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">递归相关的形而上思考整理</div><div class="date">2022-02-28 / modified at 2022-07-09</div><div class="content"><p>本文整理了递归的历史和观点，并综述了各个时期的学者对递归的哲学思考。</p><span id="more"></span><p>阅读注意</p><ul><li>递归是形而上的存在问题（研究分类事物的视角/范式/数量级），首先要先定义好时间观与存在观。不要用基于古典逻辑或延展的视角去“拆解”递归中的思路，甚至你掌握的逻辑工具越多，理解难度反而更大。</li><li>本文从开始思考到找到参考书，搁置接近两年，是当前难度最高的非IT技术写作了</li><li>本文无论是查资料，还是下定义，感觉对研究对象都充满了无力感，因此本文非专业论文，仅仅是非专业的随想。</li></ul><h2>阅读方法论</h2><ul><li>尽可能从历史的角度，综述各个学科的观点</li><li>反复二次阅读</li></ul><h2>递归的历史</h2><h4>主要历史事件</h4><p>尽可能按照时间排序</p><p>强调用符号体系去认识世界的时代：</p><ul><li>莱布尼茨（1646～1716）：全才。发明了<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E5%BE%AE%E7%A7%AF%E5%88%86">微积分</a>。设想通过形式化符号，即“普遍文字”（universalcharacteristic）作为符号来描述思考，当前他只是提出了初代的理论。同时基于八卦图验证必提出了二进制。他的《单子论》是跨时代的，但是过于还原主义/理性主义，对“关系”的表达也较弱。</li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E4%B9%94%E6%B2%BB%C2%B7%E5%B8%83%E5%B0%94">乔治·布尔</a>：将古典逻辑转为数学形式，当前编程中的Boolean值就是以他为命名的。</li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%88%88%E7%89%B9%E6%B4%9B%E5%B8%83%C2%B7%E5%BC%97%E9%9B%B7%E6%A0%BC">弗雷格</a>：他的《<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A6%82%E5%BF%B5%E6%96%87%E5%AD%97">概念文字</a>》是现代逻辑学的开山之作，可以精准地形式化描述，当前高中的数学逻辑基础课和这里基本上相同了</li><li>罗素（1872～1970）：英国哲学家、数学家和逻辑学家，创立了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%9E%90%E5%93%B2%E5%AD%B8">分析哲学</a>，提出了摹状词理论。</li></ul><p>递归产生</p><ul><li><p>大卫·希尔伯特 Hilbert（1862～1943）：第一次提出了递归。提了一堆问题的人。</p></li><li><p>库尔特·哥德尔（1906～1978）：1931，在证明“不完备”猜想中，他引入递归，并自创了类编程语言，主要关注“反思逻辑”。</p></li><li><p>阿隆佐·邱奇：1936年发表可计算函数的第一份精确定义（λ演算），他是图灵的老师</p></li><li><p>图灵：图灵奖的图灵。这位被王垠<a target="_blank" rel="noopener" href="https://www.yinwang.org/blog-cn/2015/10/18/turing">喷惨了</a>，比较尴尬，因为理论上λ演算已经是最优雅的，而落地工程又是冯诺依曼做的。</p></li><li><p>冯诺依曼：第一天真正能用起来的通用计算机。</p></li><li><p>维纳：控制论</p></li><li><p>戴克斯特拉（dijkstra）：结构化编程-递归程序，递归函数在1960年被<a target="_blank" rel="noopener" href="https://www.ics.uci.edu/~jajones/INF102-S18/readings/07_dijkstra.pdf">引入</a></p></li><li><p>近现代：逻辑式语言，比如Prolog或者miniKanren</p></li></ul><blockquote><p>关于西方哲学的主要事件，可以参考<a href="/1d5b3110-bcb9-11ec-9bf3-bd6f3e9f4198">另一篇文章</a>。</p></blockquote><h2>机械与有机的认知</h2><h4>机械论(Mechanism)：笛卡尔的线性因果认知</h4><p>常见的认知是基于目的（比如目的因）或者过程的认知方法。这是一种<a href="/tags/Reductionism">还原主义</a>，它一般隐含了因果、覆盖等线形思维（语言）来进行延展认知，通过直觉就可以感受。比如食谱可以这样定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先加入水，再放入鸡蛋，加热，加入菜，...，等待两分钟捞出。</span><br></pre></td></tr></table></figure><p>就算中间的步骤再多，只要“解剖分析”进行Top-down递推分解，这个事情就能解决。这些相关思考可以参考笛卡尔的《谈谈方法》或者机械论中的观点，也是工作中常见的西方的framework（比如WBS/PERT/MECE等方法论）。</p><h4>机器有机论（mechano-organicism）</h4><p>非线性思考：这里的“非线性”并不是指曲线思考，而是一种时刻自我调整的<strong>反馈</strong>过程<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。它与线性因果相比，加入了反馈（feedback）机制，操作命令的用户信息（甚至包含观测）也是算法的一部分。这里是由<strong>维纳</strong>最先发表，即控制论。可以参考《人有人的用处》</p><hr><h2>递归的定义</h2><p>定义</p><ul><li>在数学领域，属于离散数学集合论的<a target="_blank" rel="noopener" href="https://www.coursera.org/lecture/dmathgen/38-gui-na-ding-yi-dGmmR">归纳定义</a></li><li>在计算领域，最早由数学家哥德尔在“不完全定理”中提出，被称作“原始递归函数”，它与computability是等价的。定义为不断调用自己直至停机状态（预先规定、可执行的目标）的函数，递归函数一定是可计算的。可计算也一定是递归的。</li><li>在哲学领域，被分类为<code>有机体论/反馈</code> ，可以参考定义“循環因果關係的反身性（reflexive）運動”</li></ul><h4>数字芯片的定义</h4><p>比如<a target="_blank" rel="noopener" href="https://thesharanmohanblog.wordpress.com/2018/09/12/intro-to-fpgas-fibonacci-sequence/">这篇博文</a>就介绍了定义</p><h2>例子</h2><p>比如Fibonacci sequence，用Java定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本问题同时也是爬楼梯的问题</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(x-<span class="number">1</span>) + fibonacci(x-<span class="number">2</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前课本只能用经验手段，从fib(0),fib(1)···延展举例来模拟其定义，但是大脑把这个例子背诵后，甚至把树的遍历背诵后，可以刷LeetCode题了，就真的“掌握”了递归吗？课本中的消除栈溢出，如何用dp来缓存结果，这两个工程手段很重要吗？（在groovy等语言中，都有开箱方案）</p><h4>递归的第一因</h4><p>递归的开始只是时间性的，fib(0)并不能代表原因。我们不能简单地将递归看作发条，按照亚里士多德的四因说，递归中主要强调了</p><ul><li>动力因：初始值（或者代表着偶然性）。或者被德勒兹称作的“准原因（quasi cause）”，或者被称作必要条件，类似日语中的“ばかりに”</li><li>目的因：达到停机条件的函数。</li></ul><p>在宗教领域，类比如“相依缘起”，“因”是内因（即停机函数），“缘”是外因（即入参）</p><p>在法律领域，因果就是人类的报应情感。</p><h4>个人观点：公式等号的歧义</h4><p>以下公式，个人认为等号含义是不同的。第一个逻辑运算是不含时间特性的，如果非要说有，它也只有时刻</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主谓的定义，无时间特性</span></span><br><span class="line"><span class="number">2</span> = <span class="number">1</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>而第二个等号是对一个本体下定义，它表示“时间关系”作用的结果，不等于执行了2次的发条。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存在的定义，有综合时间的特性</span></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">2</span>) = <span class="title function_">fib</span>(<span class="number">1</span>) + <span class="title function_">fib</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>即使递归函数fib(k)的k在数字的角度上为离散的int类型，它在认识的解释中<strong>仍然是连续的</strong>，是衡量变化的尺度。不能用fib(k)的运动轨迹来代替fib本身。</p><h4>为什么有人刷题“理解”递归更快？</h4><p>刷题记忆不等于掌握了问题。这并不是一个理解力或者智力的问题，而是信念强度的问题。比如爬楼梯，很多人通过归纳猜想到了递归公式，就直接用了。而我是“怀疑论”者，除非从数学有证明猜想，甚至在计算时始终都会去想反例去自己推翻自己。所以刷题上优势全无。</p><p>刷题和真实工程的设计是对立的，它在为你带来QuickWin的同时，也让你失去了好奇心、主动探索的机会（比如本文的思考）。</p><h4>recursive与iteratively</h4><p>iteratively是典型的机械式发条思考，可以用草稿中的<code>1,2,3</code>的绘制来代表时间的均质延伸，比如这样画框框来思考for循环中的时刻，比如<code>two pointers</code>等算法。</p><p><img src="/images/merge-sorted-array-in-place.png" alt="merge-sorted-array-in-place"></p><center>From <a target="_blank" rel="noopener" href="https://youtu.be/P1Ic85RarKY?t=316">merge-sorted-array</a></center><p>相对于均质的iteratively思考， recursive 的思考是没有均质延伸的概念，而且是难以用图像来说明的，比如</p><ul><li>综合后的状态：比如回溯法backtrack</li><li>产生的后果：比如编辑距离的长度，爬楼梯方法总数等，而不是某个具体的路径实例</li></ul><h4>递归的工程优化</h4><p>一般来说,不推荐一步到位到工程级,常见工程优化两种</p><ul><li>Top-down的memorization优化,即加一个map作为缓存</li><li>Buttom-up的迭代,即dp的for循环求积分</li></ul><h4>递归与状态机</h4><p>递归中一定有状态机，可以为停机、回溯等操作，而且一定是可枚举的。</p><h4>彩蛋：dijkstra戴克斯特拉</h4><p>这位荷兰计算机专家有如下贡献，我们可以从他的背景/文章中更好地学习递归</p><ul><li>mergesort</li><li>Dijkstra算法（迷宫）</li><li>PV信号量（与哲学家就餐问题）</li></ul><p>更多可以看这里：<a target="_blank" rel="noopener" href="https://www.dijkstrascry.com/">https://www.dijkstrascry.com/</a></p><h4>递归的扩展</h4><ul><li>元胞自动机 cellular automata等仿真计算，复杂系统；所有的机器学习都是递归式的；所有机械在尽可能成为有机的机器</li><li>控制论</li></ul><h4>冯·诺依曼的运动学模型与自动复制机</h4><p>这种自动复制的机器人当前并未实现，但是在赛博朋克类型作品中大量存在，比如《Blame!》里的超構造体（Mega Structure），《Ghost In The Shell》的Ghost Dummy Machine 等。</p><h4>递归为什么难</h4><ul><li>理解层次：递归在于要用后天经验对象的运动轨迹去理解时间表象，进而分析纯粹理性的问题。</li><li>语言与符号：需要将自然语言改写为摹状函数。</li></ul><h4>Reference</h4><ul><li><p>《递归与偶然》《存在与时间》-许煜</p></li><li><p><a target="_blank" rel="noopener" href="https://indepth.dev/dijkstra-was-right-recursion-should-not-be-difficult/">https://indepth.dev/dijkstra-was-right-recursion-should-not-be-difficult/</a> 递归是经过可计算证明的，与<strong>可计算性理论</strong>是同一个含义，一定要信任自己的代码（try to imagine what happens <strong>inside</strong> the recursive call, instead of just <strong>trusting</strong> that it will return the correct result）</p></li><li><p><a target="_blank" rel="noopener" href="https://stanford.library.sydney.edu.au/archives/fall2013/entries/recursive-functions/">https://stanford.library.sydney.edu.au/archives/fall2013/entries/recursive-functions/</a></p></li><li><p><a target="_blank" rel="noopener" href="http://philosophyandtechnology.network/2262/the-time-of-execution-cn/">http://philosophyandtechnology.network/2262/the-time-of-execution-cn/</a></p></li><li><p>可计算性与复杂度：<a target="_blank" rel="noopener" href="http://hjemmesider.diku.dk/~neil/comp2book2007/book-whole.pdf">http://hjemmesider.diku.dk/~neil/comp2book2007/book-whole.pdf</a></p></li><li><p>《冯·诺伊曼的计算机科学哲学》–桂电的潘沁博士，主要是参考了综述。</p></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>《递归与偶然》-P155 <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section></div><div class="tags"><a class="tag-link" href="/tags/Ontologies/" rel="tag">Ontologies</a><a class="tag-link" href="/tags/Philosophy/" rel="tag">Philosophy</a><a class="tag-link" href="/tags/Recursion/" rel="tag">Recursion</a><a class="tag-link" href="/tags/Time/" rel="tag">Time</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>