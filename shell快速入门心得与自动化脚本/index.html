<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="本文结合博主这两个月(实际使用肯定有6～7年了)的Shell系统化学习经历，介绍如何在已有Shell的基础上开始解决业务问题。"><meta name="keyword" content="DevOps"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Shell快速入门心得与自动化脚本</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body class="container"><header id="header"><div class="header"><div class="header-left"><div class="author"><div class="author-name"><a href="/">諺</a></div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">Archives</a></li><li style="font-size:.9rem"><a href="/archives" rel="nofollow">zh</a></li><li style="font-size:.9rem"><a href="#" rel="nofollow">|</a></li><li style="font-size:.9rem"><a href="/en" rel="nofollow">en</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">Epistemology</a></li><li><a href="/books" rel="nofollow">読書</a></li></ul></div></div></header><div class="content-wrapper"><div class="post"><section class="article"><div class="title">Shell快速入门心得与自动化脚本</div><div class="date">2016-12-12に投稿</div><div class="content"><p>本文结合博主这两个月(实际使用肯定有6～7年了)的Shell系统化学习经历，介绍如何在已有Shell的基础上开始解决业务问题。</p><span id="more"></span><p>现在很多大小公司都有一个趋势，就是将开发与运维合并到一个人身上去做，即<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a>，保证最终产品运行的环境与开发环境部署一致。开发者不再是只编码业务，还要自己维护甚至开发工具。这样做的好处很明显，第一个就是发生故障后可以一个人立刻定位，不需要<strong>拉通</strong>一堆人开莫名其妙的会议；第二个就是在工具选择上不再受制于人，不怕被工具组的人吊；第三个就是使用自动化脚本，节约手工时间，提高生活质量。</p><p><strong>关键词: Shell, DevOps, StackOverflow</strong></p><h2>如何简单入门</h2><p>如果你还没有听过Shell，你需要入门一下。这里的入门指最简单的命令，比如: ls, cd, pwd 等等，此外还需要掌握正则表达式。</p><p>请直接看下面</p><ul><li><a target="_blank" rel="noopener" href="http://www.ituring.com.cn/book/1170">《Linux Shell脚本攻略（第2版） (图灵程序设计丛书)》</a></li><li><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/1d13fff3af46">高效学习正则表达式Regex</a></li></ul><p>上面的内容大概需要3～8小时初步跳读即可完成，看完了就对Shell有个概念。</p><h2>如何为Shell进行调试</h2><p>看完入门读物了，接下来可能需要自己尝试写脚本了。学一门语言很重要的一点就是要掌握调试，如果你不想在Shell中频繁的写<code>echo</code>的话，可以使用<code>set -x</code>参数，它将会把解释器的执行过程都打印出来，比如下面的<code>+</code>号就是输出的调试内容。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ <span class="built_in">set</span> -x</span><br><span class="line">➜  ~ <span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$USER</span>, today is `date`&quot;</span></span><br><span class="line">++ date</span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">&#x27;Hello BlackSwift, today is Sat Jan 21 12:26:07 CST 2017&#x27;</span></span><br><span class="line">Hello BlackSwift, today is Sat Jan 21 12:26:07 CST 2017</span><br></pre></td></tr></table></figure><p>调试完成后，想关闭调试输出的话，输入<code>set +x</code> 即可。</p><h2>How to copy and paste from StackOverflow</h2><p>掌握了基本命令与调试方法后，那么如何通过Shell解决实际业务问题呢？那当然是使用搜索引擎啦，它将可靠地降低编码时间。</p><p>比如老大现在出了一个需求，要求让某台机器每天<strong>定时</strong>去取某个Windows<strong>共享目录</strong>的SQL，接着<strong>刷</strong>到数据库中。</p><h4>分解需求</h4><ol><li>获取共享目录的文件</li><li>执行SQL刷入</li><li>设计定时任务</li></ol><h4>搜索需求</h4><h5>1. 获取共享目录的文件</h5><p>首先将本句翻译为英文关键词 <em>shell get windows shared folder</em>，接着通过谷歌去<a target="_blank" rel="noopener" href="https://www.google.com/search?q=shell+get+windows+share+folder&amp;oq=shell+get+windows+share+folder">搜索</a>，在结果中可以发现Stackoverflow中有个大神教了一个<a target="_blank" rel="noopener" href="http://unix.stackexchange.com/a/168484/162620">smbclient</a>的命令，通过阅读此答案，我就实现了此功能</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbclient <span class="string">&#x27;//windowsserver/c$&#x27;</span> -c <span class="string">&#x27;lcd /tmp; cd $PWD; get *.sql&#x27;</span> -U user%password</span><br></pre></td></tr></table></figure><p>这样，我们第一个需求就完成了</p><h5>2. 执行SQL刷入</h5><p>同样，将此句翻译为英文关键词，以oracle数据库为例，关键词是 <em>oracle sql shell import sql</em>，同样通过谷歌搜索，可以抄到一个命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlplus user/password@connect @/Nisarg/NEult/softpoint.sql</span><br></pre></td></tr></table></figure><p>但是，老大要求刷入所有的sql，这里需要有一个文件夹遍历操作，我们接着通过谷歌搜索 <em>shell dictionary loop file</em>, 可以发现Shell可以通过for循环或者find实现，最终脚本如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> *.sql</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">	sqlplus user/password@connect @<span class="variable">$f</span>.sql</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h5>3. 执行定时任务</h5><p>这个就很简单了，你甚至可以用百度中文进行搜索，本文略，这样，你的需求就完成了。</p><blockquote><p>Linux上面的命令是学不完的，不要像背六级单词那样去背下来，或者去自己造轮子，而是尽可能尝试谷歌<strong>英文</strong>搜索<code>shell + 功能描述</code>，你的需求基本上都有现成的库。</p></blockquote><h2>Shell的高级自动化</h2><p>在使用Shell过程中，一般会调用其他的工具，比如Redis、Zookeeper、SSH等，它们均自己又打开了一个终端窗口，需要手动输入非Shell的命令。对于这类需求，有两种实现方法，第一种是去找它们自带的<code>--help</code>中是否有支持，第二种使用万能的Expect命令。</p><h4>软件自带解析</h4><p>很多软件经过迭代发展，自己搞了一套出来，一般用<code>--help</code>可以搜索出来，比如Redis支持<a target="_blank" rel="noopener" href="https://redis.io/commands/eval">eval</a>执行lua脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ redis-cli --<span class="built_in">help</span></span><br><span class="line">....</span><br><span class="line">--<span class="built_in">eval</span> &lt;file&gt;      Send an EVAL <span class="built_in">command</span> using the Lua script at &lt;file&gt;.</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>甚至支持直接将参数放到后面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ redis-cli SET <span class="string">&#x27;key&#x27;</span> <span class="string">&#x27;val&#x27;</span></span><br><span class="line">OK</span><br><span class="line">➜  ~ redis-cli GET <span class="string">&#x27;key&#x27;</span>      </span><br><span class="line"><span class="string">&quot;val&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>很多常见的文字处理工具，比如perl, awk, sed, ex 等，都是支持自有语法的，它们明显比Shell用的更爽，跨平台、跨Shell也没有兼容性问题。</p></blockquote><h4>expect 自动化</h4><p>Expect 可以实现互动，直接输入<code>man expect</code>即可看到教程。</p><p>由于Expect命令一般不单独使用，而是通过Bash中调用<code>expect -c</code>使用，因此下面的脚本默认均在Bash中运行</p><p>举个例子，清空Redis的db0缓存</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">host=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">port=<span class="string">&quot;6379&quot;</span></span><br><span class="line">expect -c <span class="string">&#x27;</span></span><br><span class="line"><span class="string">    spawn redis-cli -h &#x27;</span><span class="variable">$&#123;host&#125;</span><span class="string">&#x27; -p &#x27;</span><span class="variable">$&#123;port&#125;</span><span class="string">&#x27; </span></span><br><span class="line"><span class="string">    expect &quot;&gt;&quot;</span></span><br><span class="line"><span class="string">    send &quot;select 0</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">    expect &quot;OK*&gt;&quot;</span></span><br><span class="line"><span class="string">    send &quot;flushall</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">    expect &quot;OK*&gt;&quot;</span></span><br><span class="line"><span class="string">    send &quot;exit</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="string">    expect eof</span></span><br><span class="line"><span class="string">    exit</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>再举个例子，登陆SSH</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">host=192.168.1.100</span><br><span class="line">user=<span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="built_in">pwd</span>=<span class="string">&quot;12345&quot;</span></span><br><span class="line">expect -c <span class="string">&#x27;</span></span><br><span class="line"><span class="string">    spawn ssh &#x27;</span><span class="variable">$&#123;user&#125;</span><span class="string">&#x27;@&#x27;</span><span class="variable">$&#123;host&#125;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">    expect &#123;</span></span><br><span class="line"><span class="string">        &quot;*yes/no*&quot; &#123;send &quot;yes</span></span><br><span class="line"><span class="string">&quot;;exp_continue&#125;</span></span><br><span class="line"><span class="string">        &quot;*assword&quot; &#123;send &#x27;</span><span class="variable">$&#123;pwd&#125;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    # 这里要具体看你的sh怎么配置了</span></span><br><span class="line"><span class="string">    # interact 表示开始手工操作</span></span><br><span class="line"><span class="string">    interact    </span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h4>Shell自动化</h4><ul><li><p>Ansible：这个对入门文章有点超纲了，它主要是运维侧的工作，你要知道有这个东西</p></li><li><p>PaaS自动化：通过部署Kubernetes/Nomad等PaaS平台，基于Yaml进行自动化，同样超纲了。</p></li></ul><h2>创建自己的dotfile</h2><p><a target="_blank" rel="noopener" href="https://medium.com/@webprolific/getting-started-with-dotfiles-43c3602fd789">dotfile</a>是Shell中的工具类，类似于Java中的<code>Utils.java</code>，你可以把下面的内容放入dotfile：</p><ol><li>网上搜索到的工具类函数</li><li>某个业务提炼出来的函数</li><li>常见的alias、变量、路径</li></ol><p>最后不妨把它放到Git中进行管理，以进行统一管理，并在调用时使用source/ln引用，这样你就不用写重复的命令，代码维护也更加简单。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /dev/stdin &lt;&lt;&lt; <span class="string">&quot;<span class="subst">$(curl -s http://raw.github.com/.profile)</span>&quot;</span></span><br><span class="line"><span class="comment"># todo: 这时可以调用上面sh中封装的方法了，有点类似C中的头文件</span></span><br></pre></td></tr></table></figure><h2>总结</h2><p>个人认为，Shell是一个历史遗留问题过多的语言，其语法并不友好，Trick过多导致需要“经验”大于&quot;流程&quot;，<strong>没有必要为了精通Shell而本末倒置</strong>。</p><ol><li>能使用awk、perl，gradle等跨平台DSL的工具，尽量用跨平台工具去实现，一般来说它们的坑更少一些。</li><li>写Shell时切忌一上来就考虑复用，Shell是用来解决问题的，是要计算<strong>时间投入收益比</strong>的。比如某个Shell只在一台机器上跑，把路径硬编码也是无所谓的。如果以后出现复用需求后，后续再迭代改进，最后再封装下沉为自己的工具类。</li><li>写Shell切忌反客为主，它只是一个自动化工具，不像JAVA等饭碗工具，没有必要花费太多的时间</li><li>有时间学下Gradle是极好的，内置dsl可以把mvn、ant、sh都搞定，而且美观。</li></ol><h2>附录</h2><h4>关于单双引号</h4><p>单引号<code>'</code>：</p><p>除了<code>'</code>中的<code>'</code>，否则将所有的字符串都看作文本，不进行dereference操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ <span class="built_in">echo</span> <span class="string">&#x27;`whoami` is using java at &quot;$JAVA_HOME&quot;&#x27;</span></span><br><span class="line">`whoami` is using java at <span class="string">&quot;<span class="variable">$JAVA_HOME</span>&quot;</span> </span><br><span class="line">➜  ~ <span class="built_in">echo</span> <span class="string">&#x27;`whoami` is using java at &#x27;</span><span class="variable">$JAVA_HOME</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">`whoami` is using java at /Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home</span><br></pre></td></tr></table></figure><p>双引号<code>&quot;</code></p><p>只对<code>$</code>与 ` 进行dereference</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;`whoami` is using java at <span class="variable">$JAVA_HOME</span>&quot;</span></span><br><span class="line">&gt; swift is using java at /Library/Java/JavaVirtualMachines/jdk1.8.0_101.jdk/Contents/Home</span><br></pre></td></tr></table></figure></div><div class="tags"><a class="tag-link" href="/tags/DevOps/" rel="tag">DevOps</a></div></section><ul class="nav"><li>Prev:<a href="/%E6%88%91%E7%9A%842016/">我的2016</a></li><li>Next:<a href="/dsl%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BB%8B%E7%BB%8D/">DSL编程技术的介绍</a></li></ul><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the<a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript></div></div></div></div><footer><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer><script>window.onload=function(){var a,e,n,t;a=window,e=document,t="script",n="ga",a.GoogleAnalyticsObject=n,a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=+new Date,n=e.createElement(t),t=e.getElementsByTagName(t)[0],n.async=1,n.src="//www.google-analytics.com/analytics.js",t.parentNode.insertBefore(n,t),ga("create","UA-102296742-1","auto"),ga("send","pageview")}</script></body></html>