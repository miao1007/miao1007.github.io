<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="本文是纯折腾兴趣，时间充裕的可以玩一玩。"><meta name="keyword" content="AST,LISP"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Racket实现计算器解释器</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-102296742-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-102296742-1")</script><meta name="generator" content="Hexo 5.4.0"></head><body><header><div class="header no-print"><div class="header-container"><div class="header-left"><a href="/">諺</a></div><ul class="header-right"><li><a href="/archives">Archives</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">認識論</a></li><li><a href="/books" rel="nofollow">読書</a></li><li><a href="/archives" rel="nofollow">zh</a><a href="#" rel="nofollow">/</a><a href="/en" rel="nofollow">en</a></li></ul></div></div></header><div class="container"><div class="content-wrapper"><div class="post"><section class="article"><div class="title">Racket实现计算器解释器</div><div class="date">2018-06-22 / modified at 2022-04-04</div><div class="content"><blockquote><span>️This article has been <strong>over 1 years</strong> since the last update.</span></blockquote><p>本文是纯折腾兴趣，时间充裕的可以玩一玩。</p><span id="more"></span><h4>面向读者</h4><p>LISP是世界上第二古老语言，目前国内折腾LISP的人并不多。首先明确本文目标是扩大视野，掌握FP编程范式，而不是学习Racket(LISP的一种实现)本身语法以及各种库，对读者要求如下</p><ul><li>掌握Java或一门动态语言</li><li>有足够多的时间去折腾LISP，看得懂英文文档</li><li>预先看完SICP的前两章</li></ul><h4>优缺点对比</h4><p>如果你打算花时间学习Lisp，要明确如下</p><p>不足</p><ul><li>学习曲线高，几乎全是英文文档，缺乏IDE，甚至StackoverFlow提问都不多</li><li>没有丰富的库，而且各种GPL协议对商业不友好</li><li>经济效益低，几乎没有公司招聘Lisp，实际项目LISP基本用不上</li></ul><p>优点</p><ul><li>学会了更多的编程思想，比如模式匹配，高阶函数，S表达式</li><li>类比学习设计模式/注解/JVM解释器时更加容易理解，比如Akka或者Erlang，直接上手是看不明白的</li><li>对后面折腾大数据/AI等高级数据的解析有一定帮助</li></ul><h2>S-Expression</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/S-expression">S表达式</a>是编程语言中最简洁的描述结构了(S-Expressions are a text-based representation of tree-structured data.)，比如``(+ 1 2)`。不用去直接操作各种字符串，而是通过内置函数(比如car,cdr,match)就可以直接操作SExpr，总之用一句话表达就是“括号大法好”。</p><p>借助S表达式，相比于Java可以更直观地理解</p><ul><li>各种树的遍历(不需要自己折腾native datastructure与模式匹配)</li><li>编译原理(直接操作AST)</li><li>eval</li></ul><p>在Racket中，直接可以用read进行解析，<a target="_blank" rel="noopener" href="https://github.com/racket/racket/blob/master/racket/src/racket/src/read.c">源码</a>基于C，有5000多行，用一堆表达式与Switch实现的。</p><p>在理解了S表达式后，后面才能实现计算器/Markdown等更难的解析</p><h4>类比: AngularJS</h4><p>在AngularJS中，有很多表达式也可类比为S表达式，比如<code>&lt;span ng-bind=&quot;x|json&quot;&gt;</code>，这里面在进行Direactive操作时，将会调用<code>scope.$eval(attr.ngBind)</code>对<code>x|json</code>进行解释执行，思想都是一样的。</p><h2>λ表达式语法</h2><p>λ表达式在js，以及各种JVM语言均有，Racket语法如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#lang racket</span><br><span class="line">(<span class="name">define</span> sum</span><br><span class="line">  <span class="comment">; 此处的(a b)括号不能省略</span></span><br><span class="line">  (λ (<span class="name">a</span> b)</span><br><span class="line">    (<span class="name">+</span> a b)))</span><br><span class="line">(<span class="name">sum</span> <span class="number">1</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>用Groovy的写法是这样的</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> sum = &#123;a, b -&gt; a + b&#125;</span><br><span class="line">sum.call(<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>用Java8的<code>BiFunction</code>接口进行模拟，可以看出是强类型，强参数的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;Integer,Integer,Integer&gt; sum = <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Integer <span class="title function_">apply</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum.apply(<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>我在后面所有的函数定义中，全部使用λ进行包装</p><blockquote><p>在DrRacket中使用<code>cmd</code>+<code>\</code>进行输入λ，<code>cmd</code>+<code>i</code>可以格式化代码</p></blockquote><h2>模式匹配(PatternMatch)</h2><p>模式匹配实际上就是一个有限状态机，看起来就是对<code>Map&lt;pattern, λ&gt;</code>执行的状态转移。在Racket中，连S表达式都可以匹配，而在C/Java中，只能匹配数字或者字符串。</p><h4>计算Fib</h4><p>计算<code>f(x)=f(x-1)+f(x-2)</code></p><p>实现方法</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#lang racket</span><br><span class="line">(<span class="name">define</span> fib</span><br><span class="line">  (λ (<span class="name">exp</span>)</span><br><span class="line">    (<span class="name">match</span> exp</span><br><span class="line">      [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">      [<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line">      [_ (<span class="name">+</span> (<span class="name">fib</span> (<span class="name">-</span> exp <span class="number">1</span>)) (<span class="name">fib</span> (<span class="name">-</span> exp <span class="number">2</span>)))])))</span><br><span class="line">(<span class="name">fib</span> <span class="number">10</span>)</span><br><span class="line"><span class="comment">;; =&gt; 55</span></span><br></pre></td></tr></table></figure><p>用Groovy的写法是这样的</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> fib;</span><br><span class="line">fib = &#123;exp-&gt;</span><br><span class="line">    <span class="keyword">switch</span> (exp)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="symbol">default:</span> <span class="keyword">return</span> fib.call(exp<span class="number">-1</span>) + fib.call(exp<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fib.call(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4>打印BinaryTree</h4><p>二叉树的深度遍历，方便进行直观理解</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; racket draw Binary Tree</span></span><br><span class="line">#lang racket</span><br><span class="line"><span class="comment">; 导入绘图工具类</span></span><br><span class="line">(<span class="name">require</span> pict pict/tree-layout)</span><br><span class="line"><span class="comment">; 判断Token是否是单个元素</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">atom</span>? x) (<span class="name">not</span> (<span class="name">or</span> (<span class="name">pair</span>? x) (<span class="name">null</span>? x))))</span><br><span class="line"><span class="comment">; 定义一个名为gen-ast,入参为exp的函数</span></span><br><span class="line">(<span class="name">define</span> gen-ast</span><br><span class="line">  (λ (<span class="name">exp</span>)</span><br><span class="line">    (<span class="name">match</span> exp</span><br><span class="line">      [(? atom? leaf)   <span class="comment">;如果为叶子</span></span><br><span class="line">       (<span class="name">tree-layout</span> #<span class="symbol">:pict</span> (<span class="name">text</span> (~v leaf)))] </span><br><span class="line">      [`(,op,l,r)        <span class="comment">;对S表达式进行遍历</span></span><br><span class="line">       (<span class="name">let</span> ([v1 (<span class="name">gen-ast</span> l)]</span><br><span class="line">             [v2 (<span class="name">gen-ast</span> r)])</span><br><span class="line">         (<span class="name">tree-layout</span> #<span class="symbol">:pict</span> (<span class="name">text</span> (~v op)) v1 v2))])))</span><br><span class="line"><span class="comment">; 将生成的 tree-layout 赋值到 tree 变量</span></span><br><span class="line">(<span class="name">define</span> tree (<span class="name">gen-ast</span> `(+ <span class="number">1</span> (+ (* <span class="number">2</span> <span class="number">5</span>) (/ <span class="number">2</span> <span class="number">4</span>)))))</span><br><span class="line"><span class="comment">; 执行绘图</span></span><br><span class="line">(<span class="name">naive-layered</span> tree)</span><br></pre></td></tr></table></figure><p>生成的结果是这样的</p><p><img src="http://upload-images.jianshu.io/upload_images/98641-4efd190b1cd29d84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ast.png"></p><h2>Racket与递归下降</h2><p>递归下降(RDP, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Recursive_descent_parser"><em>recursive-descent parser</em></a>)也称为左递归，它涉及到一种叫做BNF的DSL，本文暂且不引入，主要是提一下这个概念。</p><h2>Racket上实现计算器</h2><p>实现一个计算器一般有如下几步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String-(Lex)-&gt;Tokens-(Parser)-&gt;AST-&gt;(interp)-&gt;RESULT</span><br></pre></td></tr></table></figure><p>其中</p><ul><li>Lex: 指Lexical Analyzer，词法分析。可以使用lex这款工具(内部是通过正则表达式实现分词)或者自己写递归下降来实现</li><li>Parser: 指语法分析，将Token转为AST，可以通过YACC(Yet Another Compiler Compiler)实现。</li></ul><h4>Lexical Analyzer</h4><p>此部分实现将字符串解析为S表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;1+2*(5.5+3)&quot; =&gt; `(1 + 2 * ( 5.5 + 3))</span><br></pre></td></tr></table></figure><p>在Racket官方example中，使用了Lex工具搞定，本文结合多个demo，最终如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 引入工具库与前缀</span></span><br><span class="line">(<span class="name">require</span> parser-tools/lex)</span><br><span class="line">(<span class="name">require</span> (<span class="name">prefix-in</span> : parser-tools/lex-sre))</span><br><span class="line"><span class="comment">; +-x/的正则表达式</span></span><br><span class="line">(<span class="name">define-lex-abbrevs</span> (<span class="name">op</span> (<span class="symbol">:or</span> #\+ #\- #\* #\/)))</span><br><span class="line">; [a-z]|[A-Z]的正则表达式</span><br><span class="line">(define-lex-abbrevs (word (:or (char-range #\a #\z) (char-range #\A #\Z))))</span><br><span class="line">; \d 的正则表达式</span><br><span class="line">(define-lex-abbrevs (digest (char-range #\0 #\9)))</span><br><span class="line">; \d+\.?\d*</span><br><span class="line">(<span class="name">define-lex-abbrevs</span> (<span class="name">float</span> (:: (<span class="symbol">:+</span> digest) (:? #\.) (<span class="symbol">:*</span> digest))))</span><br><span class="line">(<span class="name">define</span> calc-lexer</span><br><span class="line">  (<span class="name">lexer</span></span><br><span class="line">   [(<span class="symbol">:+</span> word)</span><br><span class="line">    (<span class="name">cons</span> (<span class="name">string-&gt;symbol</span> lexeme)</span><br><span class="line">          (<span class="name">calc-lexer</span> input-port))]</span><br><span class="line">   [#\( </span><br><span class="line">    (<span class="name">cons</span> &#x27;L</span><br><span class="line">          (<span class="name">calc-lexer</span> input-port))]</span><br><span class="line">   [#\)</span><br><span class="line">    (<span class="name">cons</span> &#x27;R </span><br><span class="line">          (<span class="name">calc-lexer</span> input-port))]</span><br><span class="line">   [float</span><br><span class="line">    <span class="comment">; =&gt;</span></span><br><span class="line">    (<span class="name">cons</span> (<span class="name">string-&gt;number</span> lexeme)</span><br><span class="line">          (<span class="name">calc-lexer</span> input-port))]</span><br><span class="line">   [op</span><br><span class="line">    (<span class="name">cons</span> (<span class="name">string-&gt;symbol</span> lexeme)</span><br><span class="line">          (<span class="name">calc-lexer</span> input-port))]</span><br><span class="line">   [whitespace </span><br><span class="line">    (<span class="name">calc-lexer</span> input-port)]</span><br><span class="line">   [(<span class="name">eof</span>)</span><br><span class="line">    &#x27;()]))</span><br><span class="line">(<span class="name">calc-lexer</span> (<span class="name">open-input-string</span> <span class="string">&quot;-3*(88 + 12333.44444)-(4*5)&quot;</span>))</span><br></pre></td></tr></table></figure><p>上面本质上还是一个正则表达式的递归匹配，其中 lexeme 是历史遗留的全局变量(这是一个反模式，设计的极其糟糕)，用于存储结果</p><h4>Parser</h4><p>此部分将括号转为前缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`(1 + 2 * ( 5.5 + 3)) =&gt; `(+ 1 (* (+ 5.5 3) 2))</span><br></pre></td></tr></table></figure><h4>Eval</h4><p>此部分执行计算，入参是转换完成的前缀表达式，参考垠神写的<a target="_blank" rel="noopener" href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter">怎样写一个解释器</a></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#lang racket</span><br><span class="line"><span class="comment">; 定义一个名为 eval-ast,入参为exp的函数</span></span><br><span class="line">(<span class="name">define</span> eval-ast</span><br><span class="line">  (λ (<span class="name">exp</span>)</span><br><span class="line">    (<span class="name">match</span> exp</span><br><span class="line">      [(? number? leaf) leaf] <span class="comment">;说明已经是叶子</span></span><br><span class="line">      [`(,op,l,r)        <span class="comment">;对S表达式进行遍历</span></span><br><span class="line">       (<span class="name">let</span> ([v1 (<span class="name">eval-ast</span> l)]</span><br><span class="line">             [v2 (<span class="name">eval-ast</span> r)])</span><br><span class="line">         (<span class="name">match</span> op</span><br><span class="line">           [`+ (<span class="name">+</span> v1 v2)]</span><br><span class="line">           [`- (<span class="name">-</span> v1 v2)]</span><br><span class="line">           [`* (* v1 v2)]</span><br><span class="line">           [`/ (<span class="name">/</span> v1 v2)]))])))</span><br><span class="line"><span class="comment">; 执行计算</span></span><br><span class="line">(<span class="name">eval-ast</span> `(+ <span class="number">1</span> (+ (* <span class="number">2</span> <span class="number">5</span>) (/ <span class="number">2</span> <span class="number">4</span>))))</span><br><span class="line"><span class="comment">;; =&gt; 11.5</span></span><br></pre></td></tr></table></figure><p>相比Java中用String/枚举与<code>t.left == null</code>的实现，这里代码没有一行废话; 同时由于支持类型推导，避免了Java中各种int转换与小数点的问题</p><h2>附录</h2><ul><li><strong>Racket下载地址</strong>: <a target="_blank" rel="noopener" href="https://racket-lang.org/download/">https://racket-lang.org/download/</a></li><li><strong>Racket的Doc位置</strong>: 打开DrRacket程序-帮助-Racket文档</li><li><strong>Racket的源码与example</strong>: <code>/Applications/Racket v6.10/share/pkgs</code></li><li><strong>C语言实现</strong>: 《自制编程语言》</li><li><strong>在线E-Book</strong>: <a target="_blank" rel="noopener" href="https://www.gitbook.com/book/wizardforcel/diy-c-compiler">https://www.gitbook.com/book/wizardforcel/diy-c-compiler</a></li><li><strong>SICP</strong>: <a target="_blank" rel="noopener" href="https://github.com/twcamper/sicp-kindle">https://github.com/twcamper/sicp-kindle</a></li><li>专家<a target="_blank" rel="noopener" href="http://twitter.com/mattmight">MattMight</a>的博文: <a target="_blank" rel="noopener" href="http://matt.might.net/articles/implementing-a-programming-language/">http://matt.might.net/articles/implementing-a-programming-language/</a></li></ul></div><div class="tags"><a class="tag-link" href="/tags/AST/" rel="tag">AST</a><a class="tag-link" href="/tags/LISP/" rel="tag">LISP</a></div></section><div class="comments no-print"><noscript>Please enable JavaScript to view comments.</noscript><script async src="https://giscus.app/client.js" data-repo="miao1007/miao1007.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMzA1NTY1MDU=" data-category="General" data-category-id="DIC_kwDOB8giWc4COaTx" data-mapping="url" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="en" crossorigin="anonymous"></script></div></div></div><footer class="no-print"><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer></div></body></html>