<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content="本文从集中API Gateway到Sidecar介绍了抽象网络的多个方案，供读者参考。"><meta name="keyword" content="Consul,Nomad,PaaS,Sidecar"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>微服务中网络层抽象与改进</title><link rel="icon" href="data:image/svg+xml,%3Csvg width='24' height='28' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext font-size='24' y='24'%3E諺%3C/text%3E%3C/svg%3E" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body class="container"><header id="header"><div class="header"><div class="header-left"><div class="author"><div class="author-name"><a href="/">諺</a></div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">Archives</a></li><li style="font-size:.9rem"><a href="/archives" rel="nofollow">zh</a></li><li style="font-size:.9rem"><a href="#" rel="nofollow">|</a></li><li style="font-size:.9rem"><a href="/en" rel="nofollow">en</a></li><li><a href="/tags" rel="nofollow">Tags</a></li><li><a href="/about" rel="nofollow">About</a></li><li><a href="/epistemology" rel="nofollow">Epistemology</a></li><li><a href="/books" rel="nofollow">読書</a></li></ul></div></div></header><div class="content-wrapper"><div class="post"><section class="article"><div class="title">微服务中网络层抽象与改进</div><div class="date">2020-04-06に投稿</div><div class="content"><p>本文从集中API Gateway到Sidecar介绍了抽象网络的多个方案，供读者参考。</p><span id="more"></span><p>需要考虑的因素</p><ul><li>网络维护成本，应用适配SDK成本</li><li>负载均衡在哪里做，滚动升级，优雅停机，灰度发布</li><li>时延/带宽/容灾</li></ul><h3>什么是网络层抽象？</h3><p>指应用间通信时，将不会通过确切的IP地址进行连接，而只用知道服务名称即可，剩下全部交给DNS/代理。内部的实现将通过高层来执行，而应用不用关注。</p><p>在当前业界中，主要有如下方法</p><ul><li>基于L2 虚拟网络/L3 VRRP实现</li><li>基于中心转发: 将反向代理Nginx作为总转发中心，而不进行点对点通信</li><li>基于SDK: 比如Eureka/SpringCloud的命名服务，需要在Java项目中集成并与服务强绑定</li><li>基于vRouter/Service: 构造IP-on-IP网络与（看起来）中心化的Service定义</li><li>基于<a target="_blank" rel="noopener" href="https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-mapping-external-services">ExternalService</a>/<a target="_blank" rel="noopener" href="https://www.consul.io/docs/connect/registration/sidecar-service.html">Sidecar</a>: 基于前置代理实现服务间犹如对接localhost</li></ul><p>其中Sidecar是2018后开始大范围流行的技术，本文将以Consul+Nomad介绍它的作用。</p><h3>基于L2/L3实现</h3><p>L2: 此方案既可以在通信层做（比如实现城域网内更优的直通），也可以通过L2 on L3的软交换实现（比如vSwitch）。不过此方案在大部分场景中都属于基础设施，应用层不会涉及。</p><p>L3: 基于VRRP（虚拟路由冗余协议）实现，这个场景原本是用于Switch的主备流量，但是作为应用层的VIP也可以，但是配置要软路由或者基础指令，在云服务中一般买现成的ELB。此类方案如果涉及到应用层（比如Gitlab），需要各种应用级的健康检查，事实上运维与方案还是很繁琐的。</p><h3>基于中心化的L4/L7 Gateway实现</h3><p>这个是最简单的方案，比如将Nginx作为中心控制器，应用间互联全部通过Nginx的IP/域名即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App A -&gt; Nginx -&gt; App B</span><br></pre></td></tr></table></figure><p>这个方案虽然简单，但是环境搭建还是有一定的硬编码，负载均衡压力全部绑定到Nginx上了，而且高级的健康检查与调度转移还是很难做；更新时需要手动/Ansible操作。</p><h3>应用层基于SDK实现</h3><p>指应用不借助于任何PaaS工具，直接自己搞一套，比如SpringCloud</p><ul><li>控制面与数据面可以用任何协议、如何负载均衡完全自由定制，SpringCloud中基于Netflix OSS/Consul+七层负载均衡既可以完成一个简单的Java项目，也可以用Fabio实现一个中心化的动态网关。</li><li>但是应用侧与某个框架/SDK将绑定到一起，招聘与维护很麻烦</li><li>功能受限于SDK，比如SpringCloud很多不完善，ClientSide负载均衡是不支持blocking queries的，总会失效一段时间，需要配置wait+路由+命名服务，改Spring源码又很费时间（上述踩坑花了很多时间，但是收益很低，而且API更新很快）。</li><li>这类实现中，与Kubernetes集成事实上是维护了两份服务框架，因此部分投入浪费了</li></ul><p>我曾经接触过某些自己实现网络的项目，这种项目很容易成为烂摊子，比如</p><ul><li>将业务与网络通信细节绑定到一起（比如鉴权）。</li><li>跨语言集成（比如NodeJS/祖传Java项目）成本高</li></ul><p>我个人不太推荐这种集成SDK的方法，团队投入不增值。</p><blockquote><p>但是有一个例外，就是Erlang，它在应用层实现了全部上述功能，但是这个门槛较高，需要强团队才可以。</p></blockquote><h3>基于Kubernetes的L3的Service(VIP)实现私有网络</h3><p>此方案是在现有网络中实现一个可信的私有内网（IP networking fabric ），服务间对外需要NAT，对内可以直连，此方案需要另外加负载均衡（比如Kubernetes需要定义一个Service的yaml）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 外部请求</span><br><span class="line">网络流量 -&gt; Service(NAT与LB) -&gt; 多个pod管理(preHook, gracefullyShutdown)</span><br><span class="line">&#x2F;&#x2F; 服务间请求（请求VIP）</span><br><span class="line">PodA -&gt; ServiceB&#39;s VIP -&gt; 多个PodB</span><br></pre></td></tr></table></figure><p>以Kubernetes的tigera/calico为例，它在容器内通过虚拟网卡拦截请求，并将请求转发给网络虚拟层，内部通过iptable(IP-in-IP)/IPVS(Internet Protocol Virtual Server)进行NAT实现了一套内网</p><div style="overflow-x:scroll"><table><thead><tr><th>Plane</th><th>implementation</th><th>Comments</th></tr></thead><tbody><tr><td>Data Plane</td><td>iptable/IPVS+virtual network interface</td><td>CPU based</td></tr><tr><td>Control Plane</td><td>etcd</td><td>Simple LB</td></tr></tbody></table></div><p>应用间通信可以通过kubernetes自带的DNS服务直接解析到Service的VIP，而不是直连的场景</p><p>参考：</p><ul><li><a target="_blank" rel="noopener" href="https://www.tigera.io/blog/comparing-kube-proxy-modes-iptables-or-ipvs/">https://www.tigera.io/blog/comparing-kube-proxy-modes-iptables-or-ipvs/</a></li><li><a target="_blank" rel="noopener" href="https://docs.projectcalico.org/networking/use-ipvs">https://docs.projectcalico.org/networking/use-ipvs</a></li></ul><p>缺点</p><ul><li>安装与选型比较复杂，达到生产级有很多运维成本，部分云服务不支持此虚拟化方案</li><li>YAML配置文件很粗放，定制全靠修改label/annotaion/CRD，就像Java把业务逻辑扔到XML一样。由于嵌套逻辑被flatten，导致初学者很难掌握各个YAML间的层次关系</li><li>环境依存非常明显，需要一整套生态，有Vendor lock-in的风险</li><li>它会在机器上配置非常多的路由表，本地进行remoteDebug需要层层跳转与NAT转发，配置复杂</li></ul><h3>基于前置Sidecar代理</h3><h4>什么是Sidecar？</h4><p>Sidecar在英文上的翻译是摩托车一侧的小车，苹果也把Mac旁边的iPad显示器也叫做Sidecar。从纸面含义上，sidecar表示核心业务组件周边的支撑组件。在Azure等云厂商中把这种主业务与支撑组件共同部署的模式叫做<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar">Sidecar</a>。通过引入主容器应用的辅助容器，可在不修改原生应用源码的基础上快速实现网络代理、健康检测、收集日志等通用功能。简单的说，它就是容器级别的AOP。</p><p>下面是在部署中三种AOP的实现形式</p><div style="overflow-x:scroll"><table><thead><tr><th>Level</th><th>implementation</th><th>Comments</th></tr></thead><tbody><tr><td>ByteCode</td><td>Java/SDK/AOP</td><td>strong bind with logic</td></tr><tr><td>Process</td><td>Linux namespace</td><td>Works only on single machine</td></tr><tr><td>Container</td><td>Sidecar(Pod/DaemonSet)</td><td>rely on cloud storage/container network interface</td></tr></tbody></table></div><p>举个例子，假如我有个祖传CURD的Java项目，想集成命名服务，那么有如下多个方法进行改造</p><ul><li>Java层引入SDK包进行集成，在DNS请求等位置进行AOP编码。但是Jar包冲突，硬编码配置肯定是要走一趟的，而且改造祖传代码还要做各种兼容与测试验证，很麻烦</li><li>容器层在构建Dockerfile时，将另一个命名服务的代理也打进去，让它们内部在一个Docker镜像中互相通信。这是一种折衷的方法，但是后续升级命名服务/优雅停机比较难</li><li>基于PasS平台实现，比如在Kubernetes/Nomad中的Pod定义两个Container，一个为业务逻辑，一个为命名服务。第二个服务可以把DNS/负载均衡全部给搞定。</li></ul><h4>Sidecar与网络虚拟化</h4><p>虽然Sidecar的术语很高端，但是本质就是基于CNI的流量穿透，让调用方只用知道某个服务的名称与端口既可使用，但是在底层，需要实现网络的控制面与数据面。</p><table><thead><tr><th>Plane</th><th>implementation</th><th>Comments</th></tr></thead><tbody><tr><td>Data Plane</td><td>CNI/TLS proxy</td><td></td></tr><tr><td>Control Plane</td><td>consul/etcd</td><td>Service rules</td></tr></tbody></table><p>它的优点</p><ul><li>可以不依赖vRouter虚拟网络，支持在公网上点对点加密连接</li><li>在TCP层实现了控制面与数据面，也是软交换，性能肯定没有网卡强，但是配置灵活简单</li><li>支持localhost代理模式，现有应用不用修改代码，如同本地开发，调试成本比网关层层配置更加简单</li><li>实现有ExternalService/Envoy/Istio/Consul Connect等实现了L4/L7透明穿透，有成熟的LB方法</li></ul><p>缺点</p><ul><li>学习成本高，需要掌握很多概念，目前尚没有类似K8s这种垄断级的项目</li><li>引入了更多的组件，攻击面与排错成本会更高</li></ul><p>这种方案对应用变更最低，应该是后续主流。</p><h4>Nomad+Consul例子解析</h4><p>以<a target="_blank" rel="noopener" href="https://nomadproject.io/docs/integrations/consul-connect/">Nomad Connect</a>官网的例子实验，它的HCL默认部署了如下服务</p><ul><li>count-api: 业务API（一个计数器），端口为9001，但是没有显示配置，它没有集成任何SDK</li><li>count-dashboard: 消费者，它想消费<code>count-api:8080</code>的数据来显示到前端网页(9002)</li></ul><blockquote><p>注意这里网络里的配置<code>mode = &quot;bridge&quot;</code>指cni插件，而不是广义的桥接</p></blockquote><p>当启动完成后，可以发现</p><ul><li>count-api/count-dashboard: 业务组件没有集成任何Consul SDK就实现服务注册了，调用服务犹如请求localhost一样</li><li>两个sidecar服务: 是envoy代理，它们是业务组件的前置Proxy</li></ul><p>在Nomad下，自动开启了如下网络端口</p><div style="overflow-x:scroll"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Dynamic?</th><th style="text-align:left">Host Address</th><th style="text-align:left">Mapped Port</th></tr></thead><tbody><tr><td style="text-align:left">connect-proxy-count-dashboard</td><td style="text-align:left">Yes</td><td style="text-align:left">10.211.55.40:20968</td><td style="text-align:left">20968</td></tr><tr><td style="text-align:left">count-dashboard</td><td style="text-align:left">No</td><td style="text-align:left">10.211.55.40:9002</td><td style="text-align:left">9002</td></tr><tr><td style="text-align:left">connect-proxy-count-api</td><td style="text-align:left">Yes</td><td style="text-align:left">10.211.55.40:31706</td><td style="text-align:left">31706</td></tr></tbody></table></div><p>在应用层，将完全不用关心任何IP信息，全部走localhost请求即可。</p><p>在底层，通过envoy/pause代理屏蔽网络细节，调用链大致如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count-dashboard -&gt; sidecar proxy -(加密流量)-&gt; sidecar proxy -&gt; count-api</span><br></pre></td></tr></table></figure><p>参考</p><ul><li><a target="_blank" rel="noopener" href="https://jimmysong.io/blog/service-mesh-the-microservices-in-post-kubernetes-era/">https://jimmysong.io/blog/service-mesh-the-microservices-in-post-kubernetes-era/</a></li><li><a target="_blank" rel="noopener" href="https://www.slideshare.net/yokawasa/istio-114360124">https://www.slideshare.net/yokawasa/istio-114360124</a></li></ul><h2>总结</h2><h4>对比</h4><p>多种对比如下</p><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">基于Nginx转发</th><th style="text-align:left">基于SpringCloud</th><th style="text-align:left">基于Kubernetes</th><th style="text-align:left">基于SideCar</th></tr></thead><tbody><tr><td style="text-align:left">命名服务</td><td style="text-align:left">中心域名</td><td style="text-align:left">Consul/Eureka</td><td style="text-align:left">Service/etcd</td><td style="text-align:left">Consul</td></tr><tr><td style="text-align:left">负载均衡</td><td style="text-align:left">中心代理</td><td style="text-align:left">Ribbon，需要定制</td><td style="text-align:left">ServiceVIP</td><td style="text-align:left">Envoy</td></tr><tr><td style="text-align:left">滚动发布</td><td style="text-align:left">自己实现</td><td style="text-align:left">SpringGateway, 需要定制</td><td style="text-align:left">ReplicatedSet</td><td style="text-align:left">Consul/Nomad</td></tr><tr><td style="text-align:left">优点</td><td style="text-align:left">搭建简单</td><td style="text-align:left">教程多，堆人快</td><td style="text-align:left">应用层不用关注</td><td style="text-align:left">二进制部署开发方便</td></tr><tr><td style="text-align:left">成本&amp;&amp;缺点</td><td style="text-align:left">运维后期复杂</td><td style="text-align:left">日志/调用/重试等需要配置</td><td style="text-align:left">边际成本高</td><td style="text-align:left">学习与网络定位成本</td></tr><tr><td style="text-align:left">推荐场景</td><td style="text-align:left">单体应用</td><td style="text-align:left">中小应用</td><td style="text-align:left">覆盖边际成本</td><td style="text-align:left">覆盖边际成本或涉及公网流量</td></tr></tbody></table><p>我个人推荐如下</p><ul><li>假如当前项目是SpringCloud（Eureka/Consul），要么基于Java继续完善填充；要么接入PaaS，抛弃业务层的微服务；</li><li>假如你是从头开始做项目，建议直接基于Kubernetes/Sidecar开发，直接抛弃SpringCloud，不要去折腾各种starter了。</li></ul><h4>当前技术选型方案一览</h4><p>以下是当前（2020年）我比较推荐的方案，以下两个方案均很少有硬编码，而且都是declarative语言，而非过程时语言。</p><ul><li>HCL: 基于Consul/Nomad搭建项目，对外暴露使用<a target="_blank" rel="noopener" href="https://learn.hashicorp.com/nomad/load-balancing/fabio">Fabio</a>/<a target="_blank" rel="noopener" href="https://learn.hashicorp.com/nomad/load-balancing/traefik">Traefik</a>作为LB，服务间使用Consul Connect作为SideCar，访问外部服务<a target="_blank" rel="noopener" href="https://www.hashicorp.com/blog/consul-and-external-services/">同样使用</a>SideCar。</li><li>YAML: 基于Kubernetes，对外暴露使用Traefik+CRD实现LB，服务间使用ServiceVIP中转，访问外部服务全部使用ExternalService进行port-forwading。</li></ul><p>优点如下</p><ul><li>这两套PaaS间相互转换（以及后续升级，甚至退化为Nginx）时，不会有Vendor lock-in问题</li><li>应用层无任何SDK需要引入，只借助了DNS/FS/SIGNAL即可交互</li><li>所有的外部IP/域名均被代理转发简化，所有的配置文件/密钥均可挂载，意味着代码中没有绑死的IP</li><li>常见的滚动升级/限流/灰度均基于代理（的filter/middleware/splitter）实现，业务层不用加一堆starter</li></ul><p>缺点如下</p><ul><li>规模低时都有边际成本，规模上来后社区版PaaS运维负担也很重，最终可能还是要买企业版/招人维护PaaS</li><li>由于流量基于软交换代理，网络定位更复杂，时延有一定提高</li></ul><p>如果你当前没有现成的PaaS环境，我推荐试下基于HCL的方案，单机搭建也就一下午不到，它的边际成本相比更低，而且HCL的表达能力的确比YAML<a target="_blank" rel="noopener" href="https://github.com/hashicorp/hcl">强</a>，在POC阶段到正式上线均没太大的负担。</p><h4>未来</h4><ul><li>在不远的将来，SpringCloud这种基于SDK的方案由于经济效益差，难以分工，后期可能越来越少；但是SpringBoot作为单体应用还将继续发展。</li><li>IP-on-IP/Service-on-IP等网络虚拟化将越来越普遍</li><li>Sidecar方案上手成本越来越低，后续可能基于Sidecar出现更多的高可用方案。</li></ul><p>最后又回到知识的宽度与广度的问题，我曾经投入大量时间去分析研究Eureka与SpringCloud等某个技术细节，但是目前来看基本上全部过时了。虽然分析能力（基于实证的演绎）有提升，但是这个是舍本逐末，产出是很低效的，后续要基于形而上的思维去分析。</p></div><div class="tags"><a class="tag-link" href="/tags/Consul/" rel="tag">Consul</a><a class="tag-link" href="/tags/Nomad/" rel="tag">Nomad</a><a class="tag-link" href="/tags/PaaS/" rel="tag">PaaS</a><a class="tag-link" href="/tags/Sidecar/" rel="tag">Sidecar</a></div></section><ul class="nav"><li>Prev:<a href="/seci%E7%9A%84%E7%9F%A5%E8%AF%86%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/">SECI的知识模型介绍</a></li><li>Next:<a href="/nomad%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E5%AF%B9cgroups%E7%9A%84%E4%BD%BF%E7%94%A8/">Nomad调度框架对CGroups的使用</a></li></ul><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the<a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript></div></div></div></div><footer><div class="rights"><a href="/feed.xml" rel="external nofollow">RSS</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" rel="external nofollow" target="_blank">Curry</a><span>.</span></div></footer><script>window.onload=function(){var a,e,n,t;a=window,e=document,t="script",n="ga",a.GoogleAnalyticsObject=n,a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=+new Date,n=e.createElement(t),t=e.getElementsByTagName(t)[0],n.async=1,n.src="//www.google-analytics.com/analytics.js",t.parentNode.insertBefore(n,t),ga("create","UA-102296742-1","auto"),ga("send","pageview")}</script></body></html>